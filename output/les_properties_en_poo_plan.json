{
  "introduction": "Les properties en Python sont un outil puissant pour encapsuler les attributs de classe, offrant un contrôle précis sur la manière dont les attributs sont accédés, modifiés ou supprimés. Elles permettent d'implémenter une logique personnalisée lors de ces opérations, tout en conservant une syntaxe intuitive et claire pour l'utilisateur de la classe. Cet article explore en profondeur le concept des properties en Python, leurs avantages et leur mise en œuvre pratique.",
  "sections": [
    {
      "title": "Comprendre le concept de Property en Python",
      "subsections": [
        {
          "title": "Définition et motivation",
          "description": "Une property est un objet qui gère l'accès à un attribut de classe. Elle permet de définir des méthodes 'getter', 'setter', et 'deleter' qui sont appelées respectivement lors de la lecture, de la modification et de la suppression de l'attribut. La motivation principale est d'encapsuler l'accès aux attributs pour contrôler leur comportement et maintenir l'intégrité des données."
        },
        {
          "title": "Avantages de l'utilisation des properties",
          "description": "L'utilisation des properties offre plusieurs avantages, notamment : l'encapsulation des attributs, la validation des données lors de la modification, la possibilité d'implémenter une logique complexe lors de l'accès ou de la modification, et la simplification de l'API de la classe pour l'utilisateur."
        }
      ]
    },
    {
      "title": "Création de Properties avec la fonction `property()`",
      "subsections": [
        {
          "title": "Syntaxe de la fonction `property()`",
          "description": "La fonction `property()` prend jusqu'à quatre arguments : `fget` (getter), `fset` (setter), `fdel` (deleter) et `doc` (docstring). Elle renvoie un objet property qui peut être assigné à un attribut de classe. Exemple : `nom = property(get_nom, set_nom, del_nom, 'Nom de la personne')`."
        },
        {
          "title": "Exemple d'implémentation avec `property()`",
          "description": "Un exemple concret d'utilisation de `property()` pourrait être une classe `Personne` avec un attribut `_nom`. Le getter retourne la valeur de `_nom`, le setter valide que le nom n'est pas vide avant de l'assigner, et le deleter supprime l'attribut. La fonction `property()` permet de lier ces méthodes à un attribut `nom` public."
        }
      ]
    },
    {
      "title": "Utilisation des Décorateurs `@property`, `@nom.setter`, `@nom.deleter`",
      "subsections": [
        {
          "title": "Syntaxe des décorateurs",
          "description": "Python fournit des décorateurs pour simplifier la création de properties. `@property` décore la méthode getter, `@nom.setter` décore la méthode setter pour l'attribut `nom`, et `@nom.deleter` décore la méthode deleter. Exemple : `@property def nom(self): ...`"
        },
        {
          "title": "Avantages des décorateurs par rapport à `property()`",
          "description": "Les décorateurs offrent une syntaxe plus concise et lisible que la fonction `property()`. Ils permettent de définir les getters, setters et deleters directement dans la définition de la classe, améliorant ainsi la clarté du code. Ils sont considérés comme la méthode privilégiée pour définir les properties en Python."
        },
        {
          "title": "Exemple d'implémentation avec les décorateurs",
          "description": "Reprenons l'exemple de la classe `Personne`. Avec les décorateurs, le getter, le setter et le deleter de l'attribut `nom` seraient définis directement au sein de la classe, les uns après les autres, ce qui rend le code plus facile à lire et à comprendre. Par exemple: `@property\ndef nom(self):\n  return self._nom`"
        }
      ]
    },
    {
      "title": "Validation des données avec les Properties",
      "subsections": [
        {
          "title": "Implémentation de la validation dans le Setter",
          "description": "Le setter d'une property est l'endroit idéal pour valider les données avant de les assigner à l'attribut. On peut vérifier le type, la plage de valeurs, ou d'autres contraintes spécifiques. Si la validation échoue, on peut lever une exception pour signaler l'erreur."
        },
        {
          "title": "Gestion des erreurs et exceptions",
          "description": "Lors de la validation des données, il est crucial de gérer les erreurs et les exceptions de manière appropriée. On peut utiliser des blocs `try...except` pour capturer les exceptions levées lors de la validation et fournir des messages d'erreur clairs et informatifs à l'utilisateur."
        }
      ]
    },
    {
      "title": "Properties en Lecture Seule et en Écriture Seule",
      "subsections": [
        {
          "title": "Création de Properties en Lecture Seule",
          "description": "Une property en lecture seule est une property qui possède un getter mais pas de setter. Cela empêche la modification de l'attribut en dehors de la classe. Pour créer une property en lecture seule, il suffit de ne pas définir de setter."
        },
        {
          "title": "Création de Properties en Écriture Seule (rare)",
          "description": "Bien que moins courantes, les properties en écriture seule peuvent être utiles dans certains cas, par exemple pour enregistrer un événement sans permettre de lire l'état de cet événement. Pour créer une property en écriture seule, il suffit de ne pas définir de getter. Il est important de noter que cette pratique est généralement déconseillée, car elle peut rendre le code difficile à comprendre."
        }
      ]
    },
    {
      "title": "Héritage et Properties",
      "subsections": [
        {
          "title": "Héritage des properties",
          "description": "Les properties sont héritées par les classes filles de la même manière que les autres attributs et méthodes. Les classes filles peuvent redéfinir les properties héritées pour modifier leur comportement, par exemple en ajoutant une validation supplémentaire ou en modifiant la logique du getter ou du setter."
        },
        {
          "title": "Redéfinition des properties dans les classes filles",
          "description": "Pour redéfinir une property dans une classe fille, on utilise la même syntaxe que pour la définition d'une nouvelle property, en utilisant les décorateurs `@property`, `@nom.setter`, et `@nom.deleter`. Il est possible d'appeler la méthode de la classe parente en utilisant `super()` pour réutiliser la logique existante."
        }
      ]
    }
  ],
  "conclusion": "Les properties sont un outil essentiel pour l'encapsulation et le contrôle d'accès aux attributs en Python. Elles offrent une grande flexibilité et permettent d'implémenter une logique personnalisée lors de la lecture, de la modification et de la suppression des attributs, tout en conservant une syntaxe claire et intuitive. L'utilisation des décorateurs `@property`, `@nom.setter`, et `@nom.deleter` simplifie grandement la création et la maintenance des properties.",
  "cas_d_utilisation_pratiques": [
    {
      "title": "Contrôle de l'accès à des données sensibles",
      "description": "Une property peut être utilisée pour masquer un attribut interne contenant des données sensibles (mot de passe, clé API) et fournir un accès contrôlé à ces données, par exemple en les chiffrant avant de les retourner."
    },
    {
      "title": "Calcul d'attributs dérivés",
      "description": "Une property peut être utilisée pour calculer un attribut dérivé à partir d'autres attributs de la classe, par exemple le périmètre d'un rectangle à partir de sa largeur et de sa hauteur. Cela permet de maintenir la cohérence des données et d'éviter de recalculer l'attribut à chaque fois qu'il est nécessaire."
    },
    {
      "title": "Gestion des états d'un objet",
      "description": "Une property peut être utilisée pour gérer l'état d'un objet et effectuer des actions spécifiques en fonction de cet état, par exemple activer ou désactiver certaines fonctionnalités en fonction de la valeur d'un attribut."
    }
  ],
  "exercices": [
    {
      "title": "Exercice 1 : Classe Température",
      "description": "Créez une classe `Temperature` avec un attribut privé `_celsius`. Utilisez une property pour fournir un accès public à la température en degrés Celsius et Fahrenheit. Le setter doit valider que la température en Celsius est comprise entre -273.15 (zéro absolu) et une valeur raisonnable (par exemple, 100).",
      "code": "class Temperature:\n    def __init__(self, celsius):\n        self.celsius = celsius\n\n    @property\n    def celsius(self):\n        return self._celsius\n\n    @celsius.setter\n    def celsius(self, value):\n        if value < -273.15:\n            raise ValueError(\"Temperature cannot be below absolute zero\")\n        self._celsius = value\n\n    @property\n    def fahrenheit(self):\n        return (self._celsius * 9/5) + 32\n\n    @fahrenheit.setter\n    def fahrenheit(self, value):\n        self.celsius = (value - 32) * 5/9",
      "correction": "Voir le code ci-dessus."
    },
    {
      "title": "Exercice 2 : Classe Rectangle",
      "description": "Créez une classe `Rectangle` avec des attributs privés `_largeur` et `_hauteur`. Utilisez des properties pour fournir un accès public à la largeur et à la hauteur, avec validation pour s'assurer qu'elles sont positives. Ajoutez une property en lecture seule pour calculer l'aire du rectangle.",
      "code": "class Rectangle:\n    def __init__(self, largeur, hauteur):\n        self.largeur = largeur\n        self.hauteur = hauteur\n\n    @property\n    def largeur(self):\n        return self._largeur\n\n    @largeur.setter\n    def largeur(self, value):\n        if value <= 0:\n            raise ValueError(\"Largeur doit être positive\")\n        self._largeur = value\n\n    @property\n    def hauteur(self):\n        return self._hauteur\n\n    @hauteur.setter\n    def hauteur(self, value):\n        if value <= 0:\n            raise ValueError(\"Hauteur doit être positive\")\n        self._hauteur = value\n\n    @property\n    def aire(self):\n        return self._largeur * self._hauteur",
      "correction": "Voir le code ci-dessus."
    },
    {
      "title": "Exercice 3 : Classe Mot de Passe",
      "description": "Créez une classe `MotDePasse` avec un attribut privé `_mot_de_passe`. Utilisez une property pour fournir un accès en écriture au mot de passe. Le setter doit valider que le mot de passe a une longueur minimale de 8 caractères et contient au moins une lettre majuscule, une lettre minuscule et un chiffre.",
      "code": "import re\n\nclass MotDePasse:\n    def __init__(self, mot_de_passe):\n        self.mot_de_passe = mot_de_passe\n\n    @property\n    def mot_de_passe(self):\n        return self._mot_de_passe  # Ne pas retourner le vrai mot de passe pour des raisons de sécurité\n\n    @mot_de_passe.setter\n    def mot_de_passe(self, value):\n        if len(value) < 8:\n            raise ValueError(\"Le mot de passe doit avoir au moins 8 caractères\")\n        if not re.search(r'[A-Z]', value):\n            raise ValueError(\"Le mot de passe doit contenir au moins une lettre majuscule\")\n        if not re.search(r'[a-z]', value):\n            raise ValueError(\"Le mot de passe doit contenir au moins une lettre minuscule\")\n        if not re.search(r'[0-9]', value):\n            raise ValueError(\"Le mot de passe doit contenir au moins un chiffre\")\n        self._mot_de_passe = value",
      "correction": "Voir le code ci-dessus."
    }
  ],
  "resume_et_comparaisons": [
    {
      "title": "Résumé des avantages et inconvénients",
      "description": "Les properties offrent une encapsulation et un contrôle d'accès puissants, mais peuvent ajouter une certaine complexité au code. Elles sont particulièrement utiles lorsque la validation des données ou une logique personnalisée est nécessaire lors de l'accès aux attributs."
    },
    {
      "title": "Comparaison avec l'accès direct aux attributs",
      "description": "L'accès direct aux attributs est plus simple, mais ne permet pas d'encapsulation ni de validation. Les properties offrent une meilleure flexibilité et une plus grande sécurité, mais nécessitent un peu plus de code."
    },
    {
      "title": "Properties vs. Méthodes getter et setter classiques",
      "description": "Les properties offrent une syntaxe plus élégante et intuitive que les méthodes getter et setter classiques. Elles permettent d'accéder aux attributs comme s'il s'agissait d'attributs publics, tout en conservant le contrôle d'accès et la validation."
    }
  ]
}