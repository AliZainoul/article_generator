<!DOCTYPE html>
<html class="style-orange-3 custom_fonts comps live_website" lang="fr">
  <head>
    <!------------------- Essential Meta Tags ------------------>    
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta property="og:type" content="website" />
    <!------------------- Essential Meta Tags ------------------>    

    <!-------------------- Core SEO Elements -------------------->    
    <!-- Essential Title and SEO Meta Tags PLACEHOLDER -->
    <title>Le polymorphisme en compiletime en Python | Formateur</title>
    <meta name="description" content="Découvrez tout sur Le polymorphisme en compiletime en Python dans cet article détaillé." />
    <meta property="og:title" content="Le polymorphisme en compiletime en Python | Formateur" />
    <meta property="og:description" content="Découvrez tout sur Le polymorphisme en compiletime en Python dans cet article détaillé." />
    <meta name="twitter:title" content="Le polymorphisme en compiletime en Python | Formateur" />
    <meta name="twitter:description" content="Découvrez tout sur Le polymorphisme en compiletime en Python dans cet article détaillé." />
    <!-- Essential Title and SEO Meta Tags PLACEHOLDER -->
    <!-------------------- Core SEO Elements -------------------->    

    <!-- Structured Data PLACEHOLDER -->
    <!-- Structured Data -->

    <!-- End Structured Data -->
    <!-- Structured Data PLACEHOLDER -->

    <!-------------- Canonical and Alternate Links PLACEHOLDER ------------->
    <!-------------- Canonical and Alternate Links ------------->

    <!-------------- Canonical and Alternate Links ------------->
    <!-------------- Canonical and Alternate Links PLACEHOLDER ------------->

    <!----------------- Favicon and Assets ------------------->
    <!-- Favicon and Social Media Images -->
    <link
      rel="icon"
      type="image/png"
      href="https://www.clearcode.fr/assets/icons/favicon.ico"
      sizes="48x48"
    />
    <meta
      property="og:image"
      content="https://www.clearcode.fr/assets/images/og-image.png"
    />
    <meta property="og:image:width" content="1200" />
    <meta property="og:image:height" content="630" />
    <meta
      property="og:image:alt"
      content="ClearCode - Formations en mathématiques et programmation IT"
    />
    <meta property="og:image:type" content="image/png" />
    <!-- Fallback image format -->
    <meta
      property="og:image"
      content="https://www.clearcode.fr/assets/images/og-image.webp"
    />
    <meta
      name="twitter:image"
      content="https://www.clearcode.fr/assets/images/og-image.png"
    />
    <!----------------- Favicon and Assets ------------------->

    <script src="/src/js/code-preprocessor.js"></script>

    <!-- Stylesheets -->
    <link rel="stylesheet" href="/src/css/main.css" />
    <link rel="stylesheet" href="/src/css/dropdown.css" />
    <link rel="stylesheet" href="/src/css/mobile-course-navbar.css" />

    <!-- Prism.js core script -->
    <script
      src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"
      defer
    ></script>
    <!-- Prism.js language support for Python -->
    <script
      src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-python.min.js"
      defer
    ></script>
    <script 
      src="/src/js/reduce-prism-dom.js" 
      defer>
    </script>


    <!-- Python Code CSS -->
    <link rel="stylesheet" href="/src/css/python-code.css" />

    <!-- Scripts -->
  </head>

  <body class="comps">
    <main class="container">
      <!-- 0. TITRE -->
      <div class="content_box">
        <h1 class="heading heading--accent">Le polymorphisme en compiletime en Python</h1>
      </div>

<div class="content_box">
  <section>
    <h2 class="heading">Introduction</h2>
    <p><p>Le polymorphisme en compiletime, souvent éclipsé par son pendant runtime en Python, joue un rôle subtil mais crucial dans la flexibilité et la généricité du langage. Contrairement à des langages comme C++ ou Java, où le polymorphisme de compiletime s'appuie sur des mécanismes rigides tels que les templates ou la surcharge de méthodes statiques, Python privilégie une approche plus dynamique et souple. Cet article explore les différentes facettes de ce polymorphisme en Python, en mettant en lumière comment il se manifeste à travers le <em>duck typing</em> et l'utilisation du module <code class="language-python">typing</code> pour le typage statique optionnel.</p>

<p>Le <em>duck typing</em>, un principe central en Python, incarne parfaitement le polymorphisme de compiletime. L'idée sous-jacente est simple : si un objet possède les méthodes et propriétés attendues, il est traité comme étant du type attendu, sans qu'il soit nécessaire de vérifier explicitement son type. Cela permet de concevoir du code qui fonctionne avec une variété d'objets, à condition qu'ils implémentent les interfaces nécessaires. Par exemple, une fonction peut accepter un objet et appeler sa méthode <code class="language-python">.walk()</code>, sans se préoccuper de la classe exacte de l'objet. Tant que l'objet a une méthode <code class="language-python">.walk()</code>, tout fonctionne.</p>

<p>L'introduction du module <code class="language-python">typing</code> a apporté une forme de typage statique optionnel, renforçant ainsi les possibilités de polymorphisme en compiletime. Bien que Python demeure un langage à typage dynamique, l'utilisation de generics et d'annotations de type permet de détecter des erreurs potentielles avant l'exécution, d'améliorer la lisibilité du code et de faciliter sa maintenance.  Prenons l'exemple suivant :</p>

<pre><code class="language-python">
from typing import List, TypeVar, Optional

T = TypeVar('T')

def get_first_element(items: List[T]) -> Optional[T]:
    """
    Returns the first element of a list.

    Args:
        items: A list of elements of type T.

    Returns:
        The first element of the list, or None if the list is empty.
    """
    if items:
        return items[0]
    else:
        return None

numbers: List[int] = [1, 2, 3]
first_number: Optional[int] = get_first_element(numbers)

strings: List[str] = ["hello", "world"]
first_string: Optional[str] = get_first_element(strings)
</code></pre>

<p>Dans cet exemple, <code class="language-python">TypeVar</code> permet de définir un type générique <code class="language-python">T</code>. La fonction <code class="language-python">get_first_element</code> peut alors être utilisée avec des listes de différents types (<code class="language-python">int</code>, <code class="language-python">str</code>, etc.), tout en bénéficiant de la vérification de type statique. L'annotation <code class="language-python">List[T]</code> indique que la fonction accepte une liste d'éléments de type <code class="language-python">T</code> et renvoie un élément de ce même type, ou <code class="language-python">None</code> si la liste est vide. Bien que l'outil <code class="language-python">mypy</code> soit généralement utilisé pour valider le code avec des annotations de type, cette pratique permet une détection précoce des erreurs et une meilleure compréhension du code.</p>

<p>En résumé, le polymorphisme en compiletime en Python se manifeste principalement à travers le <em>duck typing</em>, qui offre une flexibilité maximale, et le module <code class="language-python">typing</code>, qui ajoute une couche de vérification statique optionnelle. En combinant ces techniques, les développeurs peuvent écrire du code à la fois générique et robuste, en exploitant pleinement la puissance de Python tout en minimisant les risques d'erreurs d'exécution. L'adoption du typage statique optionnel améliore la maintenabilité et la lisibilité du code, rendant les applications Python plus fiables et plus faciles à comprendre.</p>
</p>
  </section>
</div>


<div class="content_box">
  <section>
    <h2 class="heading">1. Duck Typing: Le Polymorphisme Implicite en Python</h2>
    <p><p>Le "Duck Typing" est un concept fondamental en Python qui illustre le polymorphisme implicite. L'expression "If it walks like a duck and quacks like a duck, then it must be a duck" (Si ça marche comme un canard et que ça fait coin-coin comme un canard, alors c'est probablement un canard) est à l'origine de son nom. En clair, cela signifie que le type exact d'un objet importe moins que les méthodes et attributs qu'il possède. Python se concentre sur ce que l'objet *peut faire*, plutôt que sur ce qu'il *est*.</p>

<p>À la différence des langages à typage statique (comme Java ou C++), Python effectue la vérification des types dynamiquement, au moment de l'exécution. Cela signifie qu'il n'y a pas de vérification stricte des types lors de la compilation. Si un objet possède les méthodes ou attributs requis pour une opération donnée, il est considéré comme compatible, quel que soit son type déclaré.</p>

<p>Pour illustrer ce concept, prenons un exemple concret avec deux classes, <code class="language-python">Duck</code> et <code class="language-python">Dog</code>, chacune ayant une méthode <code class="language-python">speak()</code> :</p>

<pre><code class="language-python">
class Duck:
    def speak(self):
        print("Quack quack!")

class Dog:
    def speak(self):
        print("Woof woof!")

def make_animal_speak(animal):
    animal.speak()

my_duck = Duck()
my_dog = Dog()

make_animal_speak(my_duck)  # Output: Quack quack!
make_animal_speak(my_dog)  # Output: Woof woof!
</code></pre>

<p>Dans cet exemple, la fonction <code class="language-python">make_animal_speak</code> ne se préoccupe pas du type précis de l'objet <code class="language-python">animal</code>. Elle vérifie simplement si cet objet possède une méthode nommée <code class="language-python">speak()</code>. Que <code class="language-python">Duck</code> et <code class="language-python">Dog</code> soient des classes distinctes n'a aucune importance. Du point de vue de <code class="language-python">make_animal_speak</code>, tout objet qui "fait coin-coin" est traité comme un canard.</p>

<p>Un autre exemple pertinent concerne les opérations arithmétiques. Imaginons une fonction simple qui additionne deux valeurs :</p>

<pre><code class="language-python">
def add(a, b):
    return a + b

x = 5
y = 10
print(add(x, y))  # Output: 15

string1 = "Hello"
string2 = " world"
print(add(string1, string2))  # Output: Hello world
</code></pre>

<p>La fonction <code class="language-python">add</code> fonctionne aussi bien avec des entiers qu'avec des chaînes de caractères car l'opérateur <code class="language-python">+</code> est défini (surchargé) pour les deux types. Python ne génère pas d'erreur tant que les objets passés à la fonction supportent l'opération d'addition, même si leurs types sont différents.</p>

<p>Le Duck Typing confère au code Python une flexibilité et une réutilisabilité accrues. Il permet de concevoir des fonctions et des classes capables de fonctionner avec une grande variété de types d'objets, à condition qu'ils implémentent les méthodes ou attributs requis. Cette approche contribue à la nature dynamique et expressive du langage.</p>

<p>Il est cependant crucial de noter que le Duck Typing peut aussi être source d'erreurs d'exécution si un objet ne possède pas les méthodes ou attributs attendus. C'est pourquoi il est impératif de mettre en place des tests unitaires rigoureux afin de s'assurer que le code fonctionne correctement avec différents types d'objets et de gérer les exceptions potentielles, en particulier l'exception <code class="language-python">AttributeError</code>.</p>

<p>En conclusion, le Duck Typing est un mécanisme central du polymorphisme en Python, offrant une grande souplesse et permettant d'écrire du code plus générique et adaptable. Il repose sur le principe que ce sont les *capacités* des objets, et non leurs types, qui importent réellement. Maîtriser le Duck Typing est essentiel pour exploiter pleinement la puissance et la flexibilité de Python.</p>
</p>
    <h3>1.1 Définition et Principe du Duck Typing</h3>
    <p><p>Le "duck typing", que l'on peut traduire littéralement par "typage canard", est un concept fondamental en Python, illustrant sa nature de langage à typage dynamique. L'idée maîtresse est la suivante : "Si ça ressemble à un canard, nage comme un canard, et cancane comme un canard, alors c'est probablement un canard". En d'autres termes, ce n'est pas le type explicite d'un objet qui importe, mais plutôt la présence des méthodes et attributs nécessaires pour qu'il puisse être utilisé d'une certaine manière.</p>

<p>Contrairement à des langages comme Java ou C++, Python ne procède pas à une vérification stricte des types au moment de la compilation. Au lieu de cela, il se concentre sur le comportement de l'objet au moment de l'exécution. Si un objet possède les méthodes et attributs attendus pour une opération donnée, Python l'acceptera, quel que soit son type déclaré. C'est ce qui confère à Python sa flexibilité et sa capacité à écrire du code plus concis.</p>

<p>Pour illustrer le "duck typing", considérons l'exemple suivant :</p>

<pre><code class="language-python">
class Task:
    def execute(self):
        print("Task is being executed")

class Job:
    def execute(self):
        print("Job is being executed")

def process_item(item):
    item.execute()  # Calls the execute method of the item

task = Task()
job = Job()

process_item(task) # Output: Task is being executed
process_item(job) # Output: Job is being executed
</code></pre>

<p>Dans cet exemple, les classes <code class="language-python">Task</code> et <code class="language-python">Job</code> n'héritent pas d'une interface commune. Cependant, toutes deux possèdent une méthode <code class="language-python">execute()</code>. La fonction <code class="language-python">process_item()</code> accepte n'importe quel objet qui possède une méthode <code class="language-python">execute()</code>, démontrant ainsi le principe du "duck typing". Peu importe que ce soit une <code class="language-python">Task</code> ou un <code class="language-python">Job</code>, tant que l'objet peut "exécuter", il est accepté.</p>

<p>Un autre exemple concret serait l'utilisation d'une fonction qui attend un objet avec une méthode <code class="language-python">__len__()</code> :</p>

<pre><code class="language-python">
def get_length(obj):
    return len(obj)

my_list = [1, 2, 3]
my_string = "hello"

print(get_length(my_list))  # Output: 3
print(get_length(my_string)) # Output: 5
</code></pre>

<p>Ici, <code class="language-python">my_list</code> et <code class="language-python">my_string</code> sont de types différents, mais tous deux implémentent la méthode <code class="language-python">__len__()</code>, ce qui permet à la fonction <code class="language-python">get_length()</code> de fonctionner correctement avec les deux.</p>

<p>En conclusion, le "duck typing" est un aspect essentiel du polymorphisme en Python. Il permet une plus grande flexibilité et réutilisabilité du code en se concentrant sur le comportement des objets plutôt que sur leur type spécifique. Cela conduit à un code plus adaptable et moins rigide, un avantage majeur dans un langage dynamique comme Python.</p>
</p>
    <h3>1.2 Exemple de Duck Typing en Action</h3>
    <p><p>Le "duck typing" est un concept fondamental en Python, représentant une forme élégante de polymorphisme implicite. L'adage qui le définit le mieux est : "Si ça marche comme un canard et que ça cancane comme un canard, alors c'est un canard".  Autrement dit, le type spécifique d'un objet importe peu, pourvu qu'il possède les méthodes et les attributs nécessaires pour être utilisé dans un contexte donné. Cette approche confère une grande flexibilité et dynamisme au langage.</p>

<p>Prenons un exemple concret. Imaginons deux classes, <code class="language-python">Guitar</code> et <code class="language-python">Microphone</code>, chacune disposant d'une méthode <code class="language-python">make_sound()</code>.  Bien que l'implémentation de cette méthode diffère entre les classes, l'interface, elle, reste identique.</p>

<pre><code class="language-python">
class Guitar:
    def make_sound(self):
        return "Strumming guitar chords..."  # Simulate guitar sound

class Microphone:
    def make_sound(self):
        return "Amplifying voice through the microphone..."  # Simulate microphone sound
</code></pre>

<p>Définissons maintenant une fonction, <code class="language-python">play_instrument</code>, qui accepte un objet en argument et invoque sa méthode <code class="language-python">make_sound()</code>, sans se préoccuper de son type intrinsèque.</p>

<pre><code class="language-python">
def play_instrument(instrument):
    print(instrument.make_sound())  # Calls the make_sound method of the instrument object
</code></pre>

<p>Grâce au duck typing, la fonction <code class="language-python">play_instrument</code> peut accepter une instance de <code class="language-python">Guitar</code>, une instance de <code class="language-python">Microphone</code>, ou tout autre objet doté d'une méthode <code class="language-python">make_sound()</code>, sans nécessiter de connaissance préalable de son type précis ni d'héritage d'une classe de base particulière. Cette capacité à s'adapter à différents types d'objets est au cœur du duck typing.</p>

<pre><code class="language-python">
my_guitar = Guitar()
my_microphone = Microphone()

play_instrument(my_guitar)  # Plays the guitar
play_instrument(my_microphone)  # Plays the microphone
</code></pre>

<p>L'exécution de ce code produira le résultat suivant :</p>

<pre><code class="language-python">
Strumming guitar chords...
Amplifying voice through the microphone...
</code></pre>

<p>Illustrons davantage ce concept en créant une troisième classe, <code class="language-python">Drum</code>, qui implémente également la méthode <code class="language-python">make_sound()</code> :</p>

<pre><code class="language-python">
class Drum:
    def make_sound(self):
        return "Hitting drums..."  # Simulate drum sound

my_drum = Drum()
play_instrument(my_drum)  # Plays the drum
</code></pre>

<p>Ce qui affichera :</p>

<pre><code class="language-python">
Hitting drums...
</code></pre>

<p>Cet exemple illustre avec clarté le principe fondamental du duck typing : la fonction <code class="language-python">play_instrument</code> se focalise uniquement sur la présence et la capacité d'invocation de la méthode <code class="language-python">make_sound()</code>, et non sur le type effectif de l'objet passé en argument. C'est cette souplesse qui confère au duck typing sa puissance et explique sa prévalence dans le développement Python.  Il encourage une approche plus flexible et dynamique de la programmation, favorisant la réutilisation du code et la création d'interfaces plus génériques.</p>
</p>
    <h3>1.3 Avantages et Inconvénients du Duck Typing</h3>
    <p><p>Le <em>duck typing</em> est un concept fondamental du polymorphisme implicite en Python. L'expression consacrée est : "Si ça marche comme un canard et que ça cancane comme un canard, alors c'est un canard". En d'autres termes, le type d'un objet importe peu, seule sa capacité à répondre à un ensemble d'actions (méthodes) est prise en compte.</p>

<p><strong>Avantages du <em>Duck Typing</em> :</strong></p>
<ul>
    <li><strong>Flexibilité :</strong> Le <em>duck typing</em> permet d'écrire du code qui fonctionne avec des objets de types différents, à condition qu'ils implémentent les méthodes nécessaires. Ceci favorise la réutilisation du code et réduit le couplage entre les classes.</li>
    <li><strong>Simplicité :</strong> Il n'est pas nécessaire de déclarer explicitement une interface ou une classe de base pour bénéficier du polymorphisme. Le code devient plus concis et plus facile à lire.</li>
</ul>

<p>Illustrons cela avec un exemple. Imaginons une fonction qui interagit avec un objet capable de produire un son:</p>

<pre><code class="language-python">
def play_sound(animal):
    # Checks if the animal has a 'make_sound' method and if it's callable
    if hasattr(animal, 'make_sound') and callable(animal.make_sound):
        animal.make_sound()
    else:
        print("This object cannot make a sound.")
</code></pre>

<p>Nous pouvons maintenant créer différentes classes qui implémentent la méthode <code class="language-python">make_sound</code> :</p>

<pre><code class="language-python">
class Chat:
    def make_sound(self):
        print("Miaou !")

class Reveil:
    def make_sound(self):
        print("Drrr !")

class Casserole:
    pass
</code></pre>

<p>Et les utiliser avec la fonction <code class="language-python">play_sound</code> :</p>

<pre><code class="language-python">
my_cat = Chat()
my_alarm = Reveil()
my_pot = Casserole()

play_sound(my_cat)  # Output: Miaou !
play_sound(my_alarm) # Output: Drrr !
play_sound(my_pot)   # Output: This object cannot make a sound.
</code></pre>

<p>Dans cet exemple, les classes <code class="language-python">Chat</code> et <code class="language-python">Reveil</code> ne partagent pas une classe de base commune, mais la fonction <code class="language-python">play_sound</code> peut fonctionner avec les deux car elles implémentent la méthode <code class="language-python">make_sound</code>. C'est le principe du <em>duck typing</em> en action.</p>

<p><strong>Inconvénients du <em>Duck Typing</em> :</strong></p>
<ul>
    <li><strong>Erreurs potentielles détectées uniquement au runtime :</strong> Puisqu'il n'y a pas de vérification de type statique, les erreurs dues à l'absence d'une méthode requise ne sont détectées qu'au moment de l'exécution, lorsque la méthode est appelée. Cela peut rendre le débogage plus difficile.</li>
    <li><strong>Manque de documentation implicite :</strong> Il peut être difficile de savoir quelles méthodes un objet doit implémenter pour être compatible avec une fonction donnée. Une bonne documentation (docstrings) et des tests unitaires sont essentiels pour pallier ce manque. L'utilisation d'outils de "type hinting" peut aussi aider à améliorer la lisibilité et la maintenabilité du code.</li>
</ul>

<p>Pour illustrer l'inconvénient, si on passe un objet qui ne possède pas la méthode attendue à la fonction <code class="language-python">play_sound</code>, on obtiendra une erreur en runtime (si on n'avait pas le <code class="language-python">hasattr</code> dans la fonction) ou le comportement par défaut défini dans le <code class="language-python">else</code>:</p>

<pre><code class="language-python">
class Stylo:
    def write(self):
        print("J'écris.")

my_pen = Stylo()
play_sound(my_pen) # Output: This object cannot make a sound.
</code></pre>

<p>Dans cet exemple, si la fonction <code class="language-python">play_sound</code> n'utilisait pas <code class="language-python">hasattr</code>, l'appel à <code class="language-python">my_pen.make_sound()</code> lèverait une exception <code class="language-python">AttributeError</code>.  L'utilisation de <code class="language-python">hasattr</code> permet d'éviter cette erreur et de gérer le cas où l'objet ne possède pas la méthode attendue.</p>

<p>En conclusion, le <em>duck typing</em> offre une grande flexibilité et simplicité en Python, mais exige une attention particulière à la gestion des erreurs et à la documentation. Il est particulièrement adapté aux situations où la performance est plus importante que la vérification de type statique et où la collaboration entre différents objets est nécessaire. Combiné avec des pratiques de développement rigoureuses, comme le "type hinting" et les tests unitaires, le <em>duck typing</em> peut conduire à un code Python élégant et maintenable.</p>
</p>
  </section>
</div>


<div class="content_box">
  <section>
    <h2 class="heading">2. Generics et Type Hints: Introduction du Polymorphisme explicite</h2>
    <p><p>Les generics et les type hints introduisent une forme de polymorphisme explicite en Python, offrant une plus grande flexibilité et sécurité. Contrairement au polymorphisme implicite, où le type est déterminé lors de l'exécution, les generics et les type hints permettent de spécifier les types attendus dès la conception, facilitant ainsi la détection statique des erreurs par des outils comme MyPy.</p>

<p>Le module <code class="language-python">typing</code> est essentiel pour l'utilisation des generics. Il fournit des types génériques tels que <code class="language-python">List</code>, <code class="language-python">Dict</code>, <code class="language-python">Tuple</code> et <code class="language-python">Callable</code>, qui peuvent être paramétrés avec d'autres types pour une plus grande précision.</p>

<p>Prenons un exemple simple : créer une fonction qui renvoie le premier élément d'une liste. Sans type hints, on pourrait écrire ceci :</p>

<pre><code class="language-python">
def get_first_element(data):
    """
    Returns the first element of a list.
    """
    if data:
        return data[0]
    return None
</code></pre>

<p>Cette fonction est fonctionnelle, mais elle manque d'informations sur le type des éléments contenus dans la liste. En utilisant les generics et les type hints, nous pouvons améliorer la précision et la sécurité du code :</p>

<pre><code class="language-python">
from typing import List, TypeVar

T = TypeVar('T')  # Define a type variable

def get_first_element(data: List[T]) -> T:
    """
    Returns the first element of a list.
    Uses generics to specify the type of the elements.
    """
    if data:
        return data[0]
    return None
</code></pre>

<p>Dans cet exemple, <code class="language-python">T</code> est une variable de type (Type Variable). <code class="language-python">List[T]</code> spécifie que la fonction accepte une liste d'éléments de type <code class="language-python">T</code>, et <code class="language-python">-> T</code> indique que la fonction retourne un élément de type <code class="language-python">T</code>. L'avantage principal est que les outils de vérification de type peuvent s'assurer que le type de retour correspond bien au type des éléments de la liste, améliorant ainsi la robustesse du code.</p>

<p>L'utilisation des generics ne se limite pas aux fonctions. Ils peuvent également être utilisés pour définir des classes génériques, offrant ainsi une flexibilité accrue dans la conception de classes :</p>

<pre><code class="language-python">
from typing import Generic, TypeVar

T = TypeVar('T')

class Box(Generic[T]):
    """
    A generic class that can hold a value of any type.
    """
    def __init__(self, content: T):
        self.content = content

    def get_content(self) -> T:
        return self.content

# Example usage
int_box = Box[int](10)
print(int_box.get_content())  # Output: 10

str_box = Box[str]("Hello")
print(str_box.get_content())  # Output: Hello
</code></pre>

<p>Dans cet exemple, la classe <code class="language-python">Box</code> est une classe générique capable de contenir une valeur de n'importe quel type. La variable de type <code class="language-python">T</code> est utilisée pour paramétrer la classe. Lors de la création d'une instance, comme dans <code class="language-python">Box[int](10)</code>, on spécifie que cette instance de <code class="language-python">Box</code> contiendra un entier.</p>

<p>En conclusion, les generics et les type hints représentent un mécanisme puissant pour introduire du polymorphisme explicite dans le code Python. Ils permettent de définir les types attendus au moment de la conception, facilitant ainsi la détection des erreurs et améliorant la maintenabilité du code. Bien que Python soit un langage à typage dynamique, l'utilisation des generics et des type hints offre les avantages de la vérification statique des types, tout en préservant la flexibilité du langage, permettant de créer du code plus robuste et plus facile à comprendre.</p>
</p>
    <h3>2.1 Introduction aux Generics avec 'typing'</h3>
    <p><p>Python, bien que dynamiquement typé, offre des mécanismes pour introduire un typage statique, notamment grâce au module <code class="language-python">typing</code>. Ce module permet de définir des types plus précis et d'utiliser les generics, améliorant ainsi la lisibilité du code, la maintenabilité et facilitant la détection d'erreurs par les outils d'analyse statique comme MyPy.</p>

<p>L'annotation de types est une fonctionnalité clé introduite par le module <code class="language-python">typing</code>. Elle permet de spécifier le type attendu pour les variables, les arguments de fonctions et les valeurs de retour. Bien que ces annotations n'affectent pas l'exécution du code en Python standard, elles fournissent des informations précieuses aux outils d'analyse statique. Voici un exemple simple:</p>

<pre><code class="language-python">
from typing import List

def greet(name: str) -> str:
    """
    Greets a person by name.

    Args:
        name (str): The name of the person to greet.

    Returns:
        str: A greeting message.
    """
    return f"Hello, {name}!"

names: List[str] = ["Alice", "Bob", "Charlie"]

for name in names:
    print(greet(name))
</code></pre>

<p>Les generics permettent de paramétrer des types. Par exemple, au lieu de créer une classe spécifique pour stocker des entiers et une autre pour stocker des chaînes de caractères, on peut créer une classe générique qui fonctionne avec n'importe quel type. Cela favorise la réutilisation du code et réduit la duplication. Voici un exemple avec une classe conteneur :</p>

<pre><code class="language-python">
from typing import TypeVar, Generic

# Declare a type variable T, which can be any type
T = TypeVar('T')

class Container(Generic[T]):
    """
    A generic container class that can hold an item of any type.
    """
    def __init__(self, item: T):
        """
        Initializes the container with an item.

        Args:
            item (T): The item to store in the container.
        """
        self.item = item

    def get_item(self) -> T:
        """
        Returns the item stored in the container.

        Returns:
            T: The item.
        """
        return self.item

# Usage with an integer
int_container: Container[int] = Container(10)
print(int_container.get_item())

# Usage with a string
str_container: Container[str] = Container("hello")
print(str_container.get_item())
</code></pre>

<p>Dans cet exemple, <code class="language-python">TypeVar('T')</code> crée une variable de type <code class="language-python">T</code>, qui peut être remplacée par n'importe quel type.  On peut contraindre les types possibles pour <code class="language-python">T</code> en passant une liste de types à <code class="language-python">TypeVar</code>. La classe <code class="language-python">Container</code> est ensuite définie comme <code class="language-python">Generic[T]</code>, ce qui signifie qu'elle est paramétrée par le type <code class="language-python">T</code>. Lorsqu'on crée une instance de <code class="language-python">Container</code>, on spécifie le type réel à utiliser (par exemple, <code class="language-python">Container[int]</code> ou <code class="language-python">Container[str]</code>). Cela permet une réutilisation du code tout en conservant une vérification de type rigoureuse et en évitant les erreurs de type au runtime.  L'outil MyPy vérifiera que le type passé à <code class="language-python">Container</code> est bien respecté.</p>

<p>L'utilisation de <code class="language-python">typing</code> et des generics améliore significativement la robustesse du code Python en permettant une détection précoce des erreurs de type. Cela rend le code plus facile à maintenir, à comprendre et à faire évoluer, tout en ouvrant la voie à un polymorphisme plus explicite et contrôlé, essentiel dans les grandes applications et les bibliothèques complexes.</p>
</p>
    <h3>2.2 Utilisation de TypeVar pour Définir des Types Génériques</h3>
    <p><p>L'introduction des generics en Python, via le module <code class="language-python">typing</code>, offre une approche puissante pour écrire du code plus flexible et plus sûr. <code class="language-python">TypeVar</code> est un outil central pour définir ces types génériques, permettant d'introduire une forme de polymorphisme explicite lors de la compilation et de l'analyse statique du code.</p>

<p><code class="language-python">TypeVar</code> permet de créer une variable de type qui peut représenter différents types. Cette variable de type est ensuite utilisée dans les signatures de fonctions, de classes ou de méthodes, indiquant ainsi que ces entités peuvent opérer avec divers types de données tout en maintenant une cohérence de type. C'est particulièrement utile pour les structures de données, comme les listes ou les dictionnaires, et pour les algorithmes qui doivent fonctionner indépendamment du type des éléments qu'ils manipulent.</p>

<p>Prenons l'exemple d'une fonction qui inverse une liste. Nous voulons que cette fonction puisse inverser une liste d'entiers, de chaînes de caractères, ou tout autre type. Sans generics, nous pourrions utiliser le type <code class="language-python">Any</code>, mais cela désactiverait la vérification de type. Avec <code class="language-python">TypeVar</code>, nous pouvons définir un type générique et l'utiliser pour spécifier que la fonction accepte une liste de n'importe quel type, tout en s'assurant que tous les éléments de la liste soient du même type.</p>

<pre><code class="language-python">
from typing import TypeVar, List

# Define a type variable 'T'
T = TypeVar('T')

# Function to reverse a list of any type T
def reverse_list(input_list: List[T]) -> List[T]:
    """
    Reverses a list of elements of any type.

    Args:
        input_list (List[T]): The list to reverse.

    Returns:
        List[T]: The reversed list.
    """
    return input_list[::-1]

# Example usage with a list of integers
numbers: List[int] = [1, 2, 3, 4, 5]
reversed_numbers: List[int] = reverse_list(numbers)
print(f"Original list: {numbers}")
print(f"Reversed list: {reversed_numbers}")

# Example usage with a list of strings
words: List[str] = ["hello", "world", "python"]
reversed_words: List[str] = reverse_list(words)
print(f"Original list: {words}")
print(f"Reversed list: {reversed_words}")

# This would raise a type checking error (if a type checker is used) because the list contains mixed types.
# mixed_list: List[str] = reverse_list([1, "hello"])
</code></pre>

<p>Dans cet exemple, <code class="language-python">T = TypeVar('T')</code> crée un type variable appelé <code class="language-python">T</code>. La signature de la fonction <code class="language-python">reverse_list</code> utilise <code class="language-python">List[T]</code> pour indiquer que la fonction accepte une liste d'éléments de type <code class="language-python">T</code> et renvoie une liste d'éléments du même type <code class="language-python">T</code>. L'utilisation de <code class="language-python">TypeVar</code> garantit ainsi la cohérence des types, tout en offrant la flexibilité nécessaire pour travailler avec différents types de données. Un outil de vérification de type comme <code class="language-python">mypy</code> peut être utilisé pour détecter les erreurs de type potentielles.</p>

<p>En conclusion, <code class="language-python">TypeVar</code> est un outil puissant pour introduire les generics en Python, permettant d'écrire du code plus flexible, réutilisable et sûr. Il offre un moyen d'exprimer des relations de type complexes et de bénéficier des avantages du typage statique, tout en préservant la nature dynamique de Python, rendant le code plus robuste et plus facile à maintenir.</p>
</p>
    <h3>2.3 Contraintes de Type avec 'typing.Protocol'</h3>
    <p><p>Alors que les types génériques offrent une flexibilité considérable, il est parfois nécessaire de contraindre ces types à satisfaire des exigences spécifiques. C'est là que <code class="language-python">typing.Protocol</code> entre en jeu. Il permet de définir des interfaces implicites, basées sur la présence de certaines méthodes ou attributs, sans nécessiter d'héritage explicite.</p>

<p>Un <code class="language-python">Protocol</code> définit une structure qu'un type doit suivre, et tout type qui possède les attributs et méthodes définis par le <code class="language-python">Protocol</code> est considéré comme un sous-type de ce <code class="language-python">Protocol</code>, indépendamment de sa hiérarchie d'héritage. Cette approche, appelée typage structurel (ou duck typing statique), offre une flexibilité accrue par rapport à l'héritage classique en vérifiant la compatibilité des types en fonction de leur structure plutôt que de leur ascendance.</p>

<p>Considérons un exemple. Supposons que nous ayons besoin d'une fonction qui puisse interagir avec des objets ayant une méthode pour s'exprimer. Nous pouvons définir un <code class="language-python">Protocol</code> appelé <code class="language-python">Speaker</code>:</p>

<pre><code class="language-python">
from typing import Protocol

class Speaker(Protocol):
    def speak(self) -> str:
        ...

def announce(speaker: Speaker, message: str) -> None:
    """
    Announces a message using the given speaker.
    The speaker must implement the 'speak' method.
    """
    print(f"{speaker.speak()}: {message}")

class Parrot:
    def speak(self) -> str:
        return "Squawk"

class Human:
    def speak(self) -> str:
        return "Hello"

my_parrot = Parrot()
my_human = Human()

announce(my_parrot, "It's a cracker!")  # Valid
announce(my_human, "The meeting is starting.")  # Valid
</code></pre>

<p>Dans cet exemple, <code class="language-python">Parrot</code> et <code class="language-python">Human</code> n'héritent pas explicitement de <code class="language-python">Speaker</code>, mais comme ils implémentent la méthode <code class="language-python">speak</code> avec la signature correcte, ils sont considérés comme des sous-types valides de <code class="language-python">Speaker</code>. La fonction <code class="language-python">announce</code> accepte donc ces instances sans erreur de type.  Ceci illustre comment <code class="language-python">Protocol</code> permet un typage flexible basé sur la structure, plutôt que sur l'héritage.</p>

<p>On peut utiliser <code class="language-python">typing.Protocol</code> pour contraindre un type générique. Par exemple, imaginons une fonction qui doit interagir avec un objet capable d'enregistrer des informations :</p>

<pre><code class="language-python">
from typing import Protocol, TypeVar, Generic

class Logger(Protocol):
    def log(self, message: str) -> None:
        ...

T = TypeVar('T', bound=Logger)

class DataProcessor(Generic[T]):
    def __init__(self, logger: T):
        self.logger = logger

    def process_data(self, data: str) -> None:
        self.logger.log(f"Processing data: {data}")

class MyLogger:
    def log(self, message: str) -> None:
        print(f"MyLogger: {message}")

my_logger = MyLogger()
processor = DataProcessor(my_logger)
processor.process_data("example data")  # Valid
</code></pre>

<p>Dans cet exemple, <code class="language-python">Logger</code> est un <code class="language-python">Protocol</code>. La variable de type <code class="language-python">T</code> est contrainte à être un sous-type de <code class="language-python">Logger</code>.  La classe <code class="language-python">DataProcessor</code> utilise ce type générique pour s'assurer que l'objet <code class="language-python">logger</code> passé au constructeur implémente la méthode <code class="language-python">log</code>.  Ainsi, <code class="language-python">MyLogger</code>, bien qu'il n'hérite pas de <code class="language-python">Logger</code>, est un type valide pour <code class="language-python">T</code> car il implémente la méthode requise.</p>

<p><code class="language-python">typing.Protocol</code> offre une manière puissante et flexible de définir des interfaces implicites et de contraindre les types génériques en Python. Cela permet d'écrire du code plus robuste et plus facile à maintenir, tout en tirant parti des avantages du typage statique et du duck typing, en combinant la vérification de type statique avec la flexibilité du polymorphisme.</p>
</p>
  </section>
</div>


<div class="content_box">
  <section>
    <h2 class="heading">3. Surcharge de Méthodes (Method Overloading) et Dispatching en Python</h2>
    <p><p>En Python, la surcharge de méthodes, telle qu'implémentée dans des langages comme Java ou C++, n'est pas directement prise en charge via des signatures multiples. Dans ces langages, vous pouvez définir plusieurs méthodes avec le même nom dans une classe, à condition qu'elles diffèrent par le nombre ou le type de leurs arguments. Python, en revanche, utilise une approche différente, s'appuyant sur les arguments par défaut, les arguments variables (<code class="language-python">*args</code> et <code class="language-python">**kwargs</code>), et le typage dynamique pour offrir une flexibilité comparable, voire supérieure.</p>

<p>L'approche Python consiste à créer une seule méthode capable de gérer différents types et nombres d'arguments. Cela est accompli principalement grâce aux arguments par défaut et aux arguments variables.</p>

<p>Voici un exemple illustrant l'utilisation des arguments par défaut pour simuler la surcharge de méthodes :</p>

<pre><code class="language-python">
class Calculator:
    def add(self, a, b=None, c=None):
        # Method that adds two or three numbers
        if b is not None and c is not None:
            return a + b + c
        elif b is not None:
            return a + b
        else:
            return a

# Example Usage
calculator = Calculator()
print(calculator.add(5))
print(calculator.add(5, 3))
print(calculator.add(5, 3, 2))
</code></pre>

<p>Dans cet exemple, la méthode <code class="language-python">add</code> peut être appelée avec un, deux ou trois arguments. La logique interne de la méthode s'adapte en fonction de la présence ou de l'absence des arguments optionnels (<code class="language-python">b</code> et <code class="language-python">c</code>). Si <code class="language-python">b</code> et <code class="language-python">c</code> sont tous les deux différents de <code class="language-python">None</code>, la somme des trois nombres est retournée. Si seul <code class="language-python">b</code> est fourni, la somme de <code class="language-python">a</code> et <code class="language-python">b</code> est calculée. Sinon, si aucun argument optionnel n'est fourni, la méthode retourne simplement la valeur de <code class="language-python">a</code>. Cela permet de simuler la surcharge de méthodes en vérifiant les valeurs par défaut.</p>

<p>On peut également utiliser les arguments variables (<code class="language-python">*args</code>) pour gérer un nombre arbitraire d'arguments :</p>

<pre><code class="language-python">
class Summer:
    def sum_all(self, *args):
        # Method that sums all the given arguments
        total = 0
        for num in args:
            total += num
        return total

# Example Usage
summer = Summer()
print(summer.sum_all(1, 2, 3))
print(summer.sum_all(1, 2, 3, 4, 5))
print(summer.sum_all()) # No arguments passed
</code></pre>

<p>Ici, la méthode <code class="language-python">sum_all</code> peut accepter un nombre quelconque d'arguments, qui sont ensuite additionnés. La flexibilité de <code class="language-python">*args</code> permet de gérer divers scénarios d'appel sans nécessiter la définition de multiples méthodes <code class="language-python">sum_all</code>. Si aucun argument n'est passé, la méthode retourne 0.</p>

<p>Enfin, la surcharge de méthodes peut être simulée en effectuant une vérification explicite du type des arguments à l'aide de fonctions comme <code class="language-python">isinstance()</code>. Cela permet d'adapter le comportement de la méthode en fonction des types d'arguments fournis :</p>

<pre><code class="language-python">
class TypeChecker:
    def process_value(self, value):
        # Method that processes a value based on its type
        if isinstance(value, int):
            return f"Integer: {value}"
        elif isinstance(value, str):
            return f"String: {value}"
        elif isinstance(value, list):
            return f"List: {len(value)} elements"
        else:
            return "Unknown type"

# Example Usage
checker = TypeChecker()
print(checker.process_value(10))
print(checker.process_value("hello"))
print(checker.process_value([1, 2, 3]))
</code></pre>

<p>Dans cet exemple, la méthode <code class="language-python">process_value</code> vérifie le type de l'argument <code class="language-python">value</code> et retourne une chaîne de caractères différente en fonction de son type (entier, chaîne de caractères ou liste). Si le type n'est pas reconnu, un message "Unknown type" est retourné. Cette approche permet de gérer différents types d'entrée avec une seule méthode, simulant ainsi le comportement de la surcharge de méthodes.</p>

<p>En conclusion, bien que Python ne prenne pas en charge la surcharge de méthodes au sens strict comme certains autres langages, les arguments par défaut, les arguments variables (<code class="language-python">*args</code> et <code class="language-python">**kwargs</code>) et la vérification de type offrent des mécanismes puissants et flexibles pour obtenir un comportement polymorphe similaire, parfaitement adapté à la nature dynamique du langage. Ces outils permettent aux développeurs de créer des interfaces élégantes et adaptables sans la complexité de la surcharge de méthodes traditionnelle.</p>
</p>
    <h3>3.1 Le Concept de Surcharge de Méthodes en Python</h3>
    <p><p>La surcharge de méthodes, telle qu'elle existe dans des langages comme Java ou C++, n'est pas directement supportée en Python. Dans ces langages, la surcharge permet de définir plusieurs méthodes avec le même nom au sein d'une classe, à condition que leurs signatures soient différentes (nombre ou types d'arguments). Python, étant un langage à typage dynamique, aborde ce concept différemment.</p>

<p>En Python, définir plusieurs méthodes avec le même nom dans une classe conduit à ce que la dernière définition écrase les précédentes. Il n'y a donc pas de surcharge au sens strict. Cependant, Python propose des alternatives pour obtenir un comportement similaire, notamment en utilisant des arguments par défaut, des arguments variables (<code class="language-python">*args</code> et <code class="language-python">**kwargs</code>), ou par introspection des types d'arguments.</p>

<p>L'exemple suivant illustre l'absence de surcharge native et une façon de la contourner :</p>

<pre><code class="language-python">
class Printer:
    def print_value(self, value):
        print("Printing:", value)

    def print_value(self, value1, value2):
        print("Printing two values:", value1, value2)

my_printer = Printer()

# Only the last definition is effective
# my_printer.print_value("Hello")  # This will raise a TypeError
my_printer.print_value("Hello", "World")  # This works
</code></pre>

<p>Dans cet exemple, la première définition de <code class="language-python">print_value</code> est remplacée par la seconde. Si on essayait d'appeler <code class="language-python">my_printer.print_value("Hello")</code>, une erreur <code class="language-python">TypeError</code> serait levée car Python ne connaît que la version de <code class="language-python">print_value</code> qui attend deux arguments.</p>

<p>Pour simuler la surcharge, l'utilisation d'arguments par défaut est une approche courante :</p>

<pre><code class="language-python">
class FlexiblePrinter:
    def print_value(self, value1, value2=None):
        if value2 is None:
            print("Printing:", value1)
        else:
            print("Printing two values:", value1, value2)

flexible_printer = FlexiblePrinter()
flexible_printer.print_value("Hello")
flexible_printer.print_value("Hello", "World")
</code></pre>

<p>Ici, la méthode <code class="language-python">print_value</code> peut être appelée avec un ou deux arguments. Si <code class="language-python">value2</code> n'est pas fourni, il prend la valeur par défaut <code class="language-python">None</code>, et le code s'adapte en conséquence. C'est une méthode répandue pour imiter la surcharge en Python.</p>

<p>Une autre méthode consiste à utiliser <code class="language-python">*args</code> et <code class="language-python">**kwargs</code> pour accepter un nombre variable d'arguments :</p>

<pre><code class="language-python">
class ArgumentPrinter:
    def print_values(self, *args):
        if len(args) == 1:
            print("Printing one value:", args[0])
        elif len(args) == 2:
            print("Printing two values:", args[0], args[1])
        else:
            print("Printing multiple values:", args)

argument_printer = ArgumentPrinter()
argument_printer.print_values("Hello")
argument_printer.print_values("Hello", "World")
argument_printer.print_values("Hello", "World", "!")
</code></pre>

<p>Dans cet exemple, la méthode <code class="language-python">print_values</code> peut recevoir n'importe quel nombre d'arguments positionnels. La logique interne de la fonction détermine comment traiter ces arguments en fonction de leur quantité. Bien que cela ne constitue pas une surcharge au sens strict, cela permet d'obtenir un comportement analogue en fonction des arguments fournis.</p>

<p>En conclusion, bien que Python ne propose pas de surcharge de méthodes native comme Java ou C++, des mécanismes comme les arguments par défaut et les arguments variables permettent d'imiter cette fonctionnalité, offrant ainsi une souplesse comparable dans la conception de classes et de méthodes.</p>
</p>
    <h3>3.2 Utilisation de Decorators pour le Dispatching</h3>
    <p><p>La surcharge de méthodes, telle qu'elle est implémentée dans des langages comme Java ou C++, n'est pas directement supportée en Python. Cependant, on peut obtenir un comportement similaire grâce au <em>dispatching</em> basé sur le type des arguments. Le décorateur <code class="language-python">@singledispatch</code> du module <code class="language-python">functools</code> est couramment utilisé à cet effet.</p>

<p>Ce mécanisme permet de définir différentes implémentations d'une même fonction, chacune étant exécutée en fonction du type du premier argument qui lui est passé. Ceci offre une forme de polymorphisme au moment de l'exécution (runtime polymorphism), permettant d'adapter le comportement d'une fonction en fonction du type de données qu'elle reçoit.</p>

<pre><code class="language-python">
from functools import singledispatch

@singledispatch
def my_function(arg):
    # Generic implementation if no specific type is found
    print("Generic implementation for type:", type(arg))

@my_function.register(int)
def _(arg):
    # Implementation for integer type
    print("Integer implementation:", arg)

@my_function.register(str)
def _(arg):
    # Implementation for string type
    print("String implementation:", arg)

@my_function.register(list)
def _(arg):
    # Implementation for list type
    print("List implementation:", arg)
    for item in arg:
        print("  -", item)

# Example calls
my_function("hello")
my_function(10)
my_function([1, 2, 3])
my_function(10.5)
</code></pre>

<p>Dans cet exemple :</p>
<ul>
    <li><code class="language-python">@singledispatch</code> est utilisé pour décorer la fonction de base <code class="language-python">my_function</code>. Cette fonction agit comme l'implémentation par défaut.</li>
    <li><code class="language-python">@my_function.register(type)</code> est utilisé pour enregistrer des implémentations spécifiques pour différents types (<code class="language-python">int</code>, <code class="language-python">str</code>, <code class="language-python">list</code>). Le nom de la fonction décorée (<code class="language-python">_</code>) est une convention pour indiquer que le nom n'est pas important car elle est dispatchée via le type.</li>
    <li>Lors de l'appel de <code class="language-python">my_function</code> avec un argument, Python détermine quelle implémentation exécuter en fonction du type du premier argument. Si aucun type spécifique n'est enregistré, l'implémentation générique est exécutée.</li>
</ul>

<p>Cette technique est particulièrement utile dans les situations où une fonction doit gérer une variété de types d'entrée différents, tout en maintenant un code propre et organisé. Elle représente une alternative élégante à l'utilisation de multiples instructions <code class="language-python">if/elif/else</code> pour vérifier le type des arguments, améliorant ainsi la lisibilité et la maintenabilité du code.  De plus, l'utilisation de <code class="language-python">@singledispatch</code> favorise l'extensibilité, car de nouvelles implémentations peuvent être ajoutées facilement pour supporter des types supplémentaires sans modifier le code existant.</p>
</p>
    <h3>3.3 Limites et Alternatives au Dispatching</h3>
    <p><p>Bien que le dispatching offre une certaine flexibilité pour simuler la surcharge de méthodes en Python, cette approche présente des limitations significatives. La complexité du code peut augmenter rapidement, en particulier avec un grand nombre de types d'arguments différents. De plus, la résolution du type au moment de l'exécution (runtime) rend cette technique moins performante qu'une surcharge statique, où le compilateur pourrait déterminer la méthode à appeler au moment de la compilation.</p>

<p>Un des inconvénients majeurs est la perte de la vérification statique des types. Le choix de la méthode étant reporté à l'exécution, les erreurs potentielles ne sont détectées qu'à ce moment-là, ce qui rend le débogage plus difficile. Les outils d'analyse statique de code, comme MyPy, ne peuvent pas détecter les erreurs de type potentielles liées au dispatching.</p>

<p>Heureusement, Python offre des alternatives intéressantes pour gérer le polymorphisme sans recourir à des implémentations complexes de dispatching, en tirant parti de son typage dynamique et des outils de typage disponibles.</p>

<p><strong>Duck Typing</strong>: Python étant un langage à typage dynamique, le duck typing est une approche naturelle et idiomatique. Elle repose sur le principe que "si ça ressemble à un canard, nage comme un canard et cancane comme un canard, alors c'est probablement un canard". Au lieu de vérifier explicitement le type d'un objet, on vérifie s'il possède les méthodes et attributs nécessaires pour effectuer une opération. Cette approche favorise la flexibilité et la réutilisation du code.</p>

<pre><code class="language-python">
class Duck:
    def quack(self):
        print("Quack!")

    def fly(self):
        print("Duck is flying")

class Person:
    def quack(self):
        print("Person is imitating a duck")

    def fly(self):
        print("Person is pretending to fly")

def make_it_quack(animal):
    # We don't care about the type of 'animal'
    # We only care if it has a 'quack' method
    animal.quack()

def make_it_fly(animal):
     # Same for the 'fly' method
    animal.fly()


duck = Duck()
person = Person()

make_it_quack(duck)   # Output: Quack!
make_it_quack(person) # Output: Person is imitating a duck
make_it_fly(duck)   # Output: Duck is flying
make_it_fly(person) # Output: Person is pretending to fly
</code></pre>

<p>Dans cet exemple, les fonctions <code class="language-python">make_it_quack</code> et <code class="language-python">make_it_fly</code> fonctionnent avec n'importe quel objet possédant les méthodes <code class="language-python">quack()</code> et <code class="language-python">fly()</code>, sans se soucier de son type spécifique. Ceci illustre la flexibilité du duck typing et la façon dont Python gère le polymorphisme.</p>

<p><strong>Generics (avec le module <code class="language-python">typing</code>)</strong>: Bien que Python ne supporte pas les generics de la même manière que Java ou C#, le module <code class="language-python">typing</code> permet de définir des types paramétrés et d'utiliser des type hints pour améliorer la vérification statique du code et rendre le code plus lisible. Les generics permettent de créer des classes et des fonctions qui fonctionnent avec différents types de données tout en conservant une certaine sécurité de type.</p>

<pre><code class="language-python">
from typing import TypeVar, Generic

# Define a type variable T
T = TypeVar('T')

# Create a generic class Box that can hold any type T
class Box(Generic[T]):
    def __init__(self, content: T):
        self.content = content

    def get_content(self) -> T:
        return self.content

# Create a Box that holds an integer
box_integer = Box[int](10)
integer_value: int = box_integer.get_content()  # Type checker knows this is an int

# Create a Box that holds a string
box_string = Box[str]("Hello")
string_value: str = box_string.get_content()  # Type checker knows this is a string
</code></pre>

<p>Ici, <code class="language-python">Box</code> est une classe générique qui peut contenir un objet de n'importe quel type. Les type hints permettent au type checker (comme MyPy) de vérifier que le type du contenu est correct et d'aider à la détection précoce des erreurs.</p>

<p>En conclusion, bien que le dispatching soit une technique possible pour simuler la surcharge de méthodes en Python, ses limitations en termes de complexité et de performance, ainsi que la perte de vérification statique, font du duck typing et des generics (avec le module <code class="language-python">typing</code>) des alternatives plus appropriées dans de nombreux cas. Ces alternatives exploitent les forces du typage dynamique de Python tout en offrant des mécanismes pour améliorer la robustesse, la lisibilité et la maintenabilité du code.</p>
</p>
  </section>
</div>


<div class="content_box">
  <section>
    <h2 class="heading">4. Méta-programmation et Polymorphisme: Un Aperçu Avancé</h2>
    <p><p>La méta-programmation en Python offre des outils puissants pour manipuler le code source pendant l'exécution. Combinée au polymorphisme, elle permet une flexibilité et une expressivité accrues, ouvrant la voie à la création de frameworks et de bibliothèques complexes et hautement personnalisables.</p>

<p>Un aspect fondamental de la méta-programmation réside dans la capacité d'inspecter et de modifier les classes dynamiquement. En Python, tout est objet, y compris les classes elles-mêmes. Cela signifie que l'on peut utiliser des fonctions, des classes, et des décorateurs pour créer, modifier ou même supprimer d'autres classes à l'exécution.</p>

<p>Prenons un exemple où l'on souhaite ajouter automatiquement une méthode à plusieurs classes différentes, en fonction de la présence d'un attribut spécifique.</p>

<pre><code class="language-python">
def add_method_if_attribute_exists(attribute_name, method):
    """
    Adds a method to a class if it contains a specific attribute.
    Args:
        attribute_name (str): The name of the attribute to check for.
        method (function): The method to add to the class.
    Returns:
        function: A decorator that adds the method to the class if the attribute exists.
    """
    def wrapper(cls):
        if hasattr(cls, attribute_name):
            setattr(cls, cls.__name__ + "_" + method.__name__, method) # Add method with a unique name
        return cls
    return wrapper

def display_info(self):
    """
    Displays information about the object, assuming it has a 'name' and 'value' attribute.
    """
    print(f"Name: {self.name}, Value: {self.value}")

@add_method_if_attribute_exists('name', display_info)
class DataPoint:
    def __init__(self, name, value):
        self.name = name
        self.value = value

@add_method_if_attribute_exists('label', display_info) # This will not add the method
class Configuration:
    def __init__(self, setting, config_value):
        self.setting = setting
        self.config_value = config_value

my_data_point = DataPoint("Temperature", 25)
my_data_point.DataPoint_display_info() # Output: Name: Temperature, Value: 25

my_configuration = Configuration("Timeout", 10)
# my_configuration.Configuration_display_info()  # This will raise an AttributeError because 'label' doesn't exist

</code></pre>

<p>Dans cet exemple, la fonction <code class="language-python">add_method_if_attribute_exists</code> est un décorateur qui prend le nom d'un attribut et une méthode en arguments. Si la classe décorée possède l'attribut spécifié, la méthode est ajoutée à la classe, avec un nom unique pour éviter les conflits. Ceci permet une extension dynamique des classes en fonction de leurs caractéristiques.</p>

<p>Ce type de méta-programmation est particulièrement puissant lorsqu'il est combiné avec le polymorphisme.  Imaginez une fonction qui traite une liste d'objets de types différents, chacun pouvant potentiellement avoir une méthode <code class="language-python">display_info</code>. La méta-programmation permet de garantir que cette méthode existe uniquement pour les objets qui possèdent les attributs requis, évitant ainsi des erreurs d'exécution et permettant un comportement polymorphe basé sur les capacités réelles des objets.</p>

<p>Bien que la méta-programmation offre une grande flexibilité, elle doit être utilisée avec parcimonie. Un usage excessif peut rendre le code difficile à comprendre, à maintenir et à déboguer. Néanmoins, dans les contextes appropriés, elle permet de créer des solutions élégantes, performantes et adaptées aux besoins spécifiques, tirant pleinement parti du polymorphisme dynamique de Python.</p>
</p>
    <h3>4.1 Utilisation de Métaclasses pour Modifier le Comportement des Classes</h3>
    <p><p>La méta-programmation en Python offre une flexibilité remarquable en permettant de modifier le comportement des classes au moment de leur création. Un outil puissant pour cela est l'utilisation de métaclasses. Les métaclasses sont des "classes de classes" ; elles définissent comment les classes sont créées et peuvent ainsi injecter ou modifier des comportements, ajouter des attributs ou même valider la structure d'une classe.</p>

<p>Prenons un exemple concret : imaginons que nous voulions automatiquement ajouter une méthode d'affichage, nommée <code class="language-python">display_info</code>, à toutes les classes que nous créons. Nous pouvons le faire en définissant une métaclasse personnalisée.</p>

<pre><code class="language-python">
class AutoDisplayMeta(type):
    """
    A metaclass that automatically adds a display_info method to classes.
    """
    def __new__(cls, name, bases, attrs):
        """
        This method is called before the class is created.
        It modifies the attributes dictionary to add the display_info method.
        Args:
            cls (type): The metaclass itself.
            name (str): The name of the class being created.
            bases (tuple): A tuple of the class's base classes.
            attrs (dict): A dictionary of attributes for the class.
        Returns:
            type: The newly created class.
        """
        def display_info(self):
            """
            A method to display information about the instance.
            """
            return f"Class: {name}, Attributes: {self.__dict__}"

        attrs['display_info'] = display_info
        return super().__new__(cls, name, bases, attrs)
</code></pre>

<p>Dans cet exemple, <code class="language-python">AutoDisplayMeta</code> est une métaclasse qui hérite de <code class="language-python">type</code>, la métaclasse par défaut en Python. La méthode <code class="language-python">__new__</code> est une méthode spéciale (un hook) qui est appelée avant que la classe ne soit réellement créée. Dans cette méthode, nous définissons une fonction <code class="language-python">display_info</code> qui prend <code class="language-python">self</code> comme argument (représentant l'instance de la classe) et renvoie une chaîne formatée contenant le nom de la classe et ses attributs.  Nous ajoutons cette fonction au dictionnaire des attributs (<code class="language-python">attrs</code>) de la classe en cours de création.  Finalement, nous appelons la méthode <code class="language-python">__new__</code> de la classe parente (<code class="language-python">type</code>) en utilisant <code class="language-python">super()</code> pour finaliser la création de la classe.</p>

<p>Pour utiliser cette métaclasse, il suffit de la spécifier à l'aide du mot-clé <code class="language-python">metaclass</code> lors de la définition d'une classe :</p>

<pre><code class="language-python">
class Product(metaclass=AutoDisplayMeta):
    """
    A simple Product class.
    """
    def __init__(self, name, price):
        """
        Initializes a Product instance.
        Args:
            name (str): The name of the product.
            price (float): The price of the product.
        """
        self.name = name
        self.price = price

# Create an instance of Product
my_product = Product("Laptop", 1200)

# Call the automatically added display_info method
print(my_product.display_info())
</code></pre>

<p>Comme vous pouvez le constater, la classe <code class="language-python">Product</code> n'a pas de méthode <code class="language-python">display_info</code> définie explicitement. Cependant, grâce à la métaclasse <code class="language-python">AutoDisplayMeta</code>, elle en hérite automatiquement. L'exécution de ce code affichera des informations sur l'instance de <code class="language-python">Product</code>, démontrant ainsi comment les métaclasses permettent de modifier dynamiquement le comportement des classes. En définissant <code class="language-python">metaclass=AutoDisplayMeta</code>, nous disons à Python d'utiliser <code class="language-python">AutoDisplayMeta</code> pour créer la classe <code class="language-python">Product</code>.</p>

<p>Les métaclasses sont un concept avancé, mais elles offrent un contrôle puissant sur la création des classes et peuvent être utilisées pour implémenter des patrons de conception complexes, des validations automatiques d'attributs, l'enregistrement automatique de classes dans un système ou des modifications dynamiques du comportement des classes. Elles permettent une abstraction de haut niveau et une personnalisation profonde du processus de création de classes en Python.</p>
</p>
    <h3>4.2 Manipulation d'Attributs avec '__getattr__' et '__setattr__'</h3>
    <p><p>En Python, la méta-programmation permet de manipuler le comportement des objets au moment de l'exécution. Les méthodes spéciales <code class="language-python">__getattr__</code> et <code class="language-python">__setattr__</code> sont des outils puissants pour intercepter et personnaliser l'accès aux attributs d'une classe. Elles offrent la possibilité de créer des attributs dynamiques, de valider les données assignées, ou encore d'implémenter des mécanismes de délégation complexes.</p>

<p>La méthode <code class="language-python">__getattr__(self, name)</code> est invoquée lorsqu'on tente d'accéder à un attribut inexistant d'un objet. Au lieu de déclencher une exception <code class="language-python">AttributeError</code>, Python exécute cette méthode, lui offrant l'opportunité de gérer l'accès à l'attribut de manière spécifique. Cette fonctionnalité est particulièrement pratique pour implémenter des attributs "virtuels" dont la valeur est calculée à la demande.</p>

<pre><code class="language-python">
class DynamicAttributes:
    def __init__(self, values):
        self.values = values

    def __getattr__(self, name):
        # This method is called when attempting to access an attribute that doesn't exist.
        if name in self.values:
            return self.values[name]
        else:
            raise AttributeError(f"'{type(self).__name__}' object has no attribute '{name}'")

# Example Usage:
data = DynamicAttributes({'x': 10, 'y': 20})
print(data.x) # Output: 10
print(data.y) # Output: 20

try:
    print(data.z)  # This will raise an AttributeError because 'z' is not defined.
except AttributeError as e:
    print(e) # Output: 'DynamicAttributes' object has no attribute 'z'
</code></pre>

<p>Dans cet exemple, la classe <code class="language-python">DynamicAttributes</code> utilise la méthode <code class="language-python">__getattr__</code> pour accéder aux valeurs stockées dans un dictionnaire interne. Si l'attribut demandé correspond à une clé existante dans le dictionnaire, sa valeur est renvoyée. Sinon, une exception <code class="language-python">AttributeError</code> est levée pour signaler l'absence de l'attribut.</p>

<pre><code class="language-python">
class ValidatedAttributes:
    def __init__(self):
        self._attributes = {}

    def __setattr__(self, name, value):
        # This method is called whenever an attribute is set.
        if name != '_attributes' and not isinstance(value, (int, float)):
            raise ValueError("Only numeric values are allowed")
        # Use the base class's __setattr__ to avoid infinite recursion when setting _attributes for the first time.
        super().__setattr__('_attributes', self._attributes)
        self._attributes[name] = value

    def __getattr__(self, name):
        # This method is called when attempting to access an attribute that doesn't exist.
        if name in self._attributes:
            return self._attributes[name]
        else:
            raise AttributeError(f"'{type(self).__name__}' object has no attribute '{name}'")


# Example Usage:
validator = ValidatedAttributes()
try:
    validator.age = 30
    print(validator.age)
    validator.name = "Alice" # This will raise a ValueError
except ValueError as e:
    print(e) # Output: Only numeric values are allowed

</code></pre>

<p>Dans cet exemple, la classe <code class="language-python">ValidatedAttributes</code> met en œuvre une validation pour s'assurer que seuls des nombres (entiers ou flottants) peuvent être assignés comme valeurs d'attributs. Si une valeur non numérique est tentée, une exception <code class="language-python">ValueError</code> est déclenchée. L'attribut <code class="language-python">_attributes</code> est utilisé en interne pour stocker les attributs validés.</p>

<p>La combinaison de <code class="language-python">__getattr__</code> et <code class="language-python">__setattr__</code> permet de concevoir des classes dotées d'un comportement d'attributs extrêmement flexible et personnalisable, ouvrant ainsi la voie à des abstractions puissantes et à une méta-programmation avancée pour répondre à des besoins spécifiques.</p>
</p>
    <h3>4.3 Impact de la Méta-programmation sur le Polymorphisme</h3>
    <p><p>La méta-programmation en Python offre une flexibilité remarquable pour transformer la structure du code, que ce soit pendant son exécution ou même avant, lors de la définition des classes. Cette capacité permet de créer des abstractions expressives et d'étendre les possibilités du polymorphisme, tout en ajoutant une certaine complexité.</p>

<p>L'un des mécanismes les plus utilisés pour influencer le polymorphisme grâce à la méta-programmation est l'utilisation de métaclasses. Une métaclasse contrôle la création des classes, permettant ainsi d'injecter ou de modifier des méthodes et des attributs de manière dynamique.</p>

<p>Prenons un exemple où l'on souhaite automatiser la validation de type pour certains attributs d'une classe. On peut créer une métaclasse qui ajoute une méthode de validation pour chaque attribut annoté avec un type:</p>

<pre><code class="language-python">
class ValidateType(type):
    def __new__(cls, name, bases, attrs):
        # Iterate through the type annotations of the class
        for attr_name, attr_type in attrs.get('__annotations__', {}).items():
            # Create a validator function for each annotated attribute
            def validator(self, value, expected_type=attr_type):
                if not isinstance(value, expected_type):
                    raise TypeError(f"Expected {expected_type}, got {type(value)}")
                # Store the validated value in a private attribute
                setattr(self, f'_{attr_name}', value)

            # Define a getter and setter for the attribute, including validation
            attrs[attr_name] = property(
                fget=lambda self: getattr(self, f'_{attr_name}'),
                fset=validator,
                fdel=None,
                doc=f"Validated property of type {attr_type}"
            )
        # Call the parent's __new__ method to complete class creation
        return super().__new__(cls, name, bases, attrs)


class Person(metaclass=ValidateType):
    name: str
    age: int

    def __init__(self, name: str, age: int):
        self.name = name
        self.age = age


# Example usage:
person = Person("Alice", 30)
print(person.name)

try:
    person.age = "wrong type"
except TypeError as e:
    print(e)
</code></pre>

<p>Dans cet exemple, la métaclasse <code class="language-python">ValidateType</code> intercepte la création de la classe <code class="language-python">Person</code>. Elle examine les annotations de type (contenues dans <code class="language-python">__annotations__</code>) et crée des propriétés (getter/setter) qui effectuent une validation de type avant d'assigner la valeur à l'attribut sous-jacent.  Ainsi, toutes les instances de <code class="language-python">Person</code> bénéficient de cette validation automatique lors de l'initialisation et de la modification des attributs.</p>

<p>L'impact sur le polymorphisme est indirect, mais significatif. Si plusieurs classes utilisent cette métaclasse, elles partageront toutes le même mécanisme de validation. Cela permet de créer des interfaces implicites, où les classes sont compatibles non pas par héritage explicite, mais parce qu'elles respectent les mêmes contraintes de type définies via la métaclasse. On pourrait envisager différentes classes, représentant des "composants" d'un système, validant leurs attributs critiques de cette manière, assurant ainsi une certaine cohérence et permettant des interactions plus fiables et prévisibles.</p>

<p>Cette approche introduit cependant une complexité. La logique de validation est encapsulée dans la métaclasse, ce qui peut rendre le code plus difficile à comprendre et à déboguer, surtout pour ceux qui ne sont pas familiers avec la méta-programmation. De plus, la méta-programmation peut compliquer l'introspection (l'examen de la structure du code au moment de l'exécution), car la structure des classes est modifiée dynamiquement. Il est donc essentiel de bien évaluer les avantages et les inconvénients avant d'utiliser la méta-programmation pour étendre le polymorphisme, en mettant l'accent sur la clarté, la lisibilité et la maintenabilité du code.</p>
</p>
  </section>
</div>


<div class="content_box">
  <section>
    <h2 class="heading">5. L'Importance des Tests et de la Validation Statique</h2>
    <p><p>Les tests et la validation statique sont essentiels pour développer des applications Python robustes et fiables, particulièrement avec le polymorphisme en compiletime. Ils permettent de détecter les erreurs potentielles tôt dans le cycle de développement, réduisant ainsi les coûts et les efforts de débogage.</p>

<p>Les tests unitaires, par exemple, vérifient que chaque composant du code fonctionne correctement. Dans le contexte du polymorphisme en compiletime, ils assurent que les différentes implémentations d'une interface ou d'une classe abstraite se comportent comme prévu, même si elles sont utilisées de manière interchangeable. Voici un exemple de tests unitaires utilisant le module <code class="language-python">unittest</code> de Python et les <code class="language-python">Protocols</code> pour valider le polymorphisme:</p>

<pre><code class="language-python">
import unittest
from typing import Protocol, runtime_checkable

@runtime_checkable
class Displayable(Protocol):
    def display(self) -> str:
        ...

class TextDisplay:
    def __init__(self, text: str):
        self.text = text

    def display(self) -> str:
        return f"Text: {self.text}"

class ImageDisplay:
    def __init__(self, image_path: str):
        self.image_path = image_path

    def display(self) -> str:
        return f"Image Path: {self.image_path}"

class TestDisplayable(unittest.TestCase):
    def test_text_display(self):
        # Create an instance of TextDisplay
        text_display = TextDisplay("Hello, world!")
        # Assert that it is an instance of Displayable
        self.assertTrue(isinstance(text_display, Displayable))
        # Assert that the display method returns the expected string
        self.assertEqual(text_display.display(), "Text: Hello, world!")

    def test_image_display(self):
        # Create an instance of ImageDisplay
        image_display = ImageDisplay("path/to/image.jpg")
        # Assert that it is an instance of Displayable
        self.assertTrue(isinstance(image_display, Displayable))
        # Assert that the display method returns the expected string
        self.assertEqual(image_display.display(), "Image Path: path/to/image.jpg")

if __name__ == '__main__':
    unittest.main()
</code></pre>

<p>Dans cet exemple, un protocole <code class="language-python">Displayable</code> est défini avec une méthode <code class="language-python">display</code>. Deux classes, <code class="language-python">TextDisplay</code> et <code class="language-python">ImageDisplay</code>, implémentent ce protocole. Les tests unitaires vérifient que les deux classes sont des instances de <code class="language-python">Displayable</code> et que leur méthode <code class="language-python">display</code> renvoie les résultats attendus.</p>

<p>La validation statique, utilisant des outils comme <code class="language-python">mypy</code>, vérifie la cohérence des types dans le code. Elle détecte les erreurs de type avant l'exécution, ce qui est crucial avec le polymorphisme, garantissant que les opérations sont effectuées sur des types compatibles. <code class="language-python">mypy</code> peut identifier les erreurs liées au typage incorrect des arguments ou des valeurs de retour, améliorant la robustesse du code. L'utilisation de "typing" et de "protocols" en Python permet à <code class="language-python">mypy</code> de travailler plus efficacement et d'améliorer la qualité du code. Les annotations de type aident <code class="language-python">mypy</code> à comprendre les intentions du développeur, rendant la validation statique plus précise.</p>

<p>Voici un exemple illustrant comment <code class="language-python">mypy</code> peut détecter une erreur de type en utilisant <code class="language-python">Protocol</code>:</p>

<pre><code class="language-python">
from typing import Protocol

class Readable(Protocol):
    def read(self) -> str:
        ...

class File:
    def __init__(self, filename: str):
        self.filename = filename

    def read(self) -> str:
        with open(self.filename, 'r') as f:
            return f.read()

class NetworkConnection:
    def __init__(self, url: str):
        self.url = url

    def read(self) -> bytes: # Intentionally incorrect return type
        # Assume this fetches data from the network and returns bytes
        return b"Data from network"

def process_data(reader: Readable):
    data = reader.read()
    print(data.upper())

file = File("my_file.txt")
process_data(file) # This will work

network_connection = NetworkConnection("http://example.com")
process_data(network_connection) # This will cause a mypy error
</code></pre>

<p>Dans cet exemple, <code class="language-python">NetworkConnection</code> a une méthode <code class="language-python">read</code> qui renvoie <code class="language-python">bytes</code> au lieu de <code class="language-python">str</code>, ce qui provoquera une erreur lors de la validation statique avec <code class="language-python">mypy</code> car la fonction <code class="language-python">process_data</code> s'attend à ce que <code class="language-python">reader.read()</code> renvoie une chaîne de caractères.</p>

<p>En conclusion, les tests et la validation statique sont essentiels pour garantir la qualité et la fiabilité du code Python, en particulier avec le polymorphisme en compiletime. Ils permettent de détecter les erreurs potentielles tôt, de réduire les coûts de débogage et d'améliorer la maintenabilité du code.</p>
</p>
    <h3>5.1 Tests Unitaires et Polymorphisme</h3>
    <p><p>Les tests et la validation statique sont essentiels pour développer des applications robustes utilisant le polymorphisme, en particulier en Python où le <em>duck typing</em> est courant. Bien que Python soit un langage à typage dynamique, ce qui signifie que le type d'une variable est vérifié à l'exécution, l'écriture de tests unitaires complets permet de s'assurer que notre code fonctionne comme prévu avec différents types d'objets.</p>

<p>Le <em>duck typing</em> repose sur l'idée que "si un objet ressemble à un canard, nage comme un canard et cancane comme un canard, alors c'est probablement un canard". Autrement dit, ce qui compte n'est pas le type de l'objet, mais le fait qu'il implémente les méthodes ou attributs nécessaires. Cette approche offre une grande flexibilité, mais exige une attention particulière lors des tests.</p>

<p>Pour illustrer ce concept, prenons une fonction qui interagit avec des objets ayant une méthode <code class="language-python">afficher()</code> :</p>

<pre><code class="language-python">
def afficher_details(objet):
    """
    Displays the details of an object using its afficher() method.

    Args:
        objet: An object that has an afficher() method.
    """
    objet.afficher()
</code></pre>

<p>Nous pouvons tester cette fonction avec différentes classes implémentant la méthode <code class="language-python">afficher()</code> :</p>

<pre><code class="language-python">
import unittest

class Article:
    def __init__(self, titre, contenu):
        self.titre = titre
        self.contenu = contenu

    def afficher(self):
        print(f"Article: {self.titre}\\n{self.contenu}")


class Image:
    def __init__(self, chemin, description):
        self.chemin = chemin
        self.description = description

    def afficher(self):
        print(f"Image: {self.chemin}\\nDescription: {self.description}")


class TestAfficherDetails(unittest.TestCase):
    def test_afficher_article(self):
        article = Article("Mon super article", "Ceci est le contenu de l'article.")
        # We capture the standard output to assert that the correct output is printed.
        import io, sys
        capturedOutput = io.StringIO()
        sys.stdout = capturedOutput
        afficher_details(article)
        sys.stdout = sys.__stdout__
        self.assertEqual(capturedOutput.getvalue(), "Article: Mon super article\\nCeci est le contenu de l'article.\\n")


    def test_afficher_image(self):
        image = Image("chemin/vers/image.jpg", "Une belle image.")
        # We capture the standard output to assert that the correct output is printed.
        import io, sys
        capturedOutput = io.StringIO()
        sys.stdout = capturedOutput
        afficher_details(image)
        sys.stdout = sys.__stdout__
        self.assertEqual(capturedOutput.getvalue(), "Image: chemin/vers/image.jpg\\nDescription: Une belle image.\\n")

if __name__ == '__main__':
    unittest.main()
</code></pre>

<p>Dans cet exemple, nous définissons deux classes, <code class="language-python">Article</code> et <code class="language-python">Image</code>, qui possèdent toutes deux une méthode <code class="language-python">afficher()</code>. Les tests unitaires vérifient que la fonction <code class="language-python">afficher_details()</code> fonctionne correctement avec les deux types d'objets. Il est crucial de tester avec divers objets implémentant l'interface attendue pour assurer la robustesse du code.</p>

<p>Il est important de noter que le <em>duck typing</em>, bien que flexible, peut dissimuler des erreurs potentielles. Un objet peut implémenter une méthode avec le même nom, mais avec un comportement différent de celui attendu. Les tests unitaires permettent de déceler ces incohérences et de garantir que les objets se comportent de manière prévisible. En résumé, des tests unitaires bien conçus sont essentiels pour assurer la qualité et la fiabilité du code qui exploite le polymorphisme en Python.</p>
</p>
    <h3>5.2 Utilisation de 'mypy' pour la Validation Statique</h3>
    <p><p>Les tests sont cruciaux pour assurer la qualité et la fiabilité du code. Cependant, les tests seuls ne peuvent pas garantir l'absence de bugs, surtout dans des langages dynamiques comme Python. La validation statique, en revanche, permet de détecter des erreurs potentielles avant même d'exécuter le code. C'est là qu'un outil comme <code class="language-python">mypy</code> entre en jeu.</p>

<p><code class="language-python">mypy</code> est un vérificateur de type statique pour Python. Il analyse le code source et vérifie les types de variables, les arguments de fonction, et les valeurs de retour, en se basant sur les annotations de type (<em>type hints</em>) que vous fournissez. Si <code class="language-python">mypy</code> détecte une incohérence, il signale une erreur, vous permettant de corriger le problème avant qu'il ne cause des problèmes lors de l'exécution.</p>

<p>Voyons un exemple concret d'utilisation de <code class="language-python">mypy</code> avec du code utilisant des generics. Imaginons une classe générique <code class="language-python">Stock</code> qui représente un stock d'éléments d'un type spécifique:</p>

<pre><code class="language-python">
from typing import TypeVar, Generic

# Define a type variable T
T = TypeVar('T')

# Stock class is now generic over the type T
class Stock(Generic[T]):
    def __init__(self, item: T, quantity: int):
        self.item = item
        self.quantity = quantity

    def add_stock(self, quantity: int) -> None:
        self.quantity += quantity

    def get_item(self) -> T:
        return self.item
</code></pre>

<p>Maintenant, essayons d'utiliser cette classe <code class="language-python">Stock</code> de manière incorrecte et voyons comment <code class="language-python">mypy</code> réagit:</p>

<pre><code class="language-python">
class Book:
    def __init__(self, title: str, author: str):
        self.title = title
        self.author = author

# This will cause a mypy error
book_stock = Stock[Book]("The Lord of the Rings", 10) # Error: Argument 1 to "Stock" has incompatible type "str"; expected "Book"
</code></pre>

<p>Dans cet exemple, nous avons créé une instance de <code class="language-python">Stock[Book]</code>, indiquant que le stock contient des objets de type <code class="language-python">Book</code>. Cependant, nous avons initialisé le stock avec une chaîne de caractères ("The Lord of the Rings") au lieu d'un objet <code class="language-python">Book</code>. Si vous exécutez <code class="language-python">mypy</code> sur ce code, il signalera une erreur de type, car l'argument fourni au constructeur ne correspond pas au type attendu (<code class="language-python">Book</code>). L'erreur retournée par mypy est explicite: <code class="language-python">Argument 1 to "Stock" has incompatible type "str"; expected "Book"</code>. Cela vous permet de corriger rapidement l'erreur et de vous assurer que votre code est type-safe.</p>

<p>Pour corriger l'erreur, il faudrait créer une instance de la classe <code class="language-python">Book</code>:</p>

<pre><code class="language-python">
class Book:
    def __init__(self, title: str, author: str):
        self.title = title
        self.author = author

# Create an instance of the Book class
book = Book("The Lord of the Rings", "J.R.R. Tolkien")
# Correct usage: passing an instance of Book
book_stock = Stock[Book](book, 10) # No error
</code></pre>

<p>L'utilisation de <code class="language-python">mypy</code>, en conjonction avec des annotations de type appropriées, permet donc de détecter de nombreuses erreurs potentielles liées aux types de données dès la phase de développement, améliorant ainsi significativement la robustesse et la maintenabilité du code Python. En intégrant <code class="language-python">mypy</code> dans votre workflow de développement, vous pouvez transformer votre code Python en un code plus sûr et plus fiable.</p>
</p>
    <h3>5.3 Intégration Continue et Analyse de Code</h3>
    <p><p>L'intégration continue (CI) est une pierre angulaire du développement logiciel moderne. En automatisant les tests et la validation statique à chaque modification du code, elle permet de détecter les erreurs de polymorphisme statique et d'autres anomalies potentielles dès les premières phases du cycle de développement. Cette approche réduit considérablement les coûts et les risques associés aux bugs en production.</p>

<p>La mise en place d'un pipeline CI efficace en Python repose sur la combinaison de plusieurs outils et techniques. Voici une approche détaillée, illustrée par des exemples concrets:</p>

<ol>
    <li><strong>Analyse Statique du Code avec Pylint et MyPy:</strong>
        <p>L'analyse statique du code est une étape cruciale pour garantir la qualité et la maintenabilité du code. Pylint analyse le code source à la recherche d'erreurs de style, de violations des conventions de codage (PEP 8) et de potentielles erreurs logiques. MyPy, quant à lui, effectue une vérification de type statique, permettant de détecter les incompatibilités de types qui pourraient survenir lors de l'utilisation du polymorphisme. Ces outils s'intègrent parfaitement aux pipelines CI et fournissent un retour d'information immédiat aux développeurs.</p>
        <pre><code class="language-python">
# Example configuration of Pylint and MyPy in a CI environment (excerpt from a .gitlab-ci.yml file)
stages:
  - lint

lint:
  stage: lint
  image: python:3.9-slim-buster
  before_script:
    - pip install pylint mypy
  script:
    - pylint your_module.py  # Replace your_module.py with your actual module name
    - mypy --strict your_module.py   # Replace your_module.py with your actual module name
</code></pre>
        <p>Dans cet exemple, le pipeline CI exécute Pylint et MyPy sur le code source à chaque commit. L'option <code class="language-python">--strict</code> de MyPy active toutes les vérifications de type, garantissant une analyse plus rigoureuse.  Toute erreur détectée par ces outils entraînera l'échec du pipeline, alertant les développeurs et bloquant la fusion du code jusqu'à résolution des problèmes.</p>
    </li>
    <li><strong>Tests Unitaires avec Pytest:</strong>
        <p>Les tests unitaires sont essentiels pour valider le comportement individuel de chaque composant du code, y compris les aspects polymorphes. Pytest est un framework de test puissant et flexible qui simplifie l'écriture et l'exécution de tests unitaires en Python. Il offre de nombreuses fonctionnalités avancées telles que la découverte automatique des tests, les fixtures et les plugins.</p>
        <pre><code class="language-python">
# Example of unit tests for a function using polymorphism (tests/test_shapes.py)
import pytest

class Shape:
    def area(self):
        raise NotImplementedError

class Circle(Shape):
    def __init__(self, radius):
        self.radius = radius

    def area(self):
        return 3.14159 * self.radius * self.radius

class Square(Shape):
    def __init__(self, side):
        self.side = side

    def area(self):
        return self.side * self.side

def calculate_area(shape: Shape) -> float:
    return shape.area()

def test_circle_area():
    circle = Circle(5)
    assert calculate_area(circle) == pytest.approx(78.53975)

def test_square_area():
    square = Square(4)
    assert calculate_area(square) == 16
</code></pre>
        <p>Ces tests vérifient que les méthodes <code class="language-python">area()</code> des classes <code class="language-python">Circle</code> et <code class="language-python">Square</code> renvoient les valeurs attendues, illustrant ainsi le comportement polymorphe de la fonction <code class="language-python">calculate_area()</code>.  La fonction <code class="language-python">pytest.approx()</code> est utilisée pour comparer des nombres à virgule flottante en tenant compte des erreurs d'arrondi.</p>
        <p>Pour intégrer ces tests dans votre pipeline CI, ajoutez une étape d'exécution de Pytest:</p>
        <pre><code class="language-python">
# Example of Pytest integration in the .gitlab-ci.yml file
test:
  stage: test
  image: python:3.9-slim-buster
  before_script:
    - pip install pytest
  script:
    - pytest tests/
</code></pre>
    </li>
    <li><strong>Couverture de Code:</strong>
        <p>L'analyse de la couverture de code permet de mesurer le pourcentage de lignes de code source qui sont effectivement exécutées lors de l'exécution des tests unitaires. Un taux de couverture élevé indique que le code est bien testé et que les différents cas d'utilisation sont couverts par les tests, renforçant ainsi la confiance dans la qualité du code. L'outil <code class="language-python">coverage.py</code> est couramment utilisé pour générer des rapports de couverture de code, qui peuvent être intégrés au pipeline CI.</p>
        <pre><code class="language-python">
# Example of using coverage.py in the .gitlab-ci.yml file
test:
  stage: test
  image: python:3.9-slim-buster
  before_script:
    - pip install pytest coverage
  script:
    - coverage run -m pytest tests/
    - coverage report -m
    - coverage xml
  artifacts:
    reports:
      coverage_xml: coverage.xml
</code></pre>
        <p>L'option <code class="language-python">coverage xml</code> génère un rapport au format XML, ce qui permet son intégration dans les outils CI/CD pour visualiser l'évolution de la couverture du code au fil du temps. L'attribut <code class="language-python">artifacts</code> permet de conserver le rapport de couverture en tant qu'artefact du pipeline.</p>
    </li>
</ol>

<p>Bien que l'adoption de l'intégration continue avec analyse statique et tests unitaires puisse représenter un investissement initial en termes de temps et de ressources, les avantages à long terme en termes de qualité du code, de réduction des coûts de maintenance et d'amélioration de la productivité des développeurs sont indéniables. Cette approche proactive permet de détecter et de corriger les erreurs plus rapidement, contribuant ainsi à la livraison de logiciels plus fiables et robustes.</p>
</p>
  </section>
</div>


<div class="content_box">
  <section>
    <h2 class="heading">6. Considérations de Performance avec le Polymorphisme en Python</h2>
    <p><p>Le polymorphisme, bien que puissant, peut introduire des considérations de performance en Python. Contrairement aux langages compilés où le polymorphisme est souvent résolu au moment de la compilation (statiquement), en Python, un langage interprété, la résolution du type se fait dynamiquement, c'est-à-dire au moment de l'exécution. Cette résolution dynamique peut entraîner un léger surcoût en termes de performance.</p>

<p>Pour illustrer cela, considérons un exemple simple avec une classe de base et une classe dérivée :</p>

<pre><code class="language-python">
import time

class Base:
    def operation(self):
        pass  # Do nothing

class Derived(Base):
    def operation(self):
        pass  # Still do nothing, but in a derived class

def measure_time(func, iterations):
    """
    Measures the execution time of a function.
    Args:
        func: The function to measure.
        iterations: The number of times to execute the function.
    Returns:
        The total execution time in seconds.
    """
    start_time = time.time()
    for _ in range(iterations):
        func()
    end_time = time.time()
    return end_time - start_time

# Create instances
base_instance = Base()
derived_instance = Derived()

# Number of iterations for the benchmark
iterations = 1000000

# Measure time for calling operation on Base instance
time_base = measure_time(base_instance.operation, iterations)
print(f"Time for Base.operation(): {time_base:.6f} seconds")

# Measure time for calling operation on Derived instance
time_derived = measure_time(derived_instance.operation, iterations)
print(f"Time for Derived.operation(): {time_derived:.6f} seconds")
</code></pre>

<p>Dans cet exemple, nous mesurons le temps nécessaire pour appeler la méthode <code class="language-python">operation()</code> sur une instance de la classe de base et sur une instance de la classe dérivée. La différence de temps, bien que minime dans ce cas, peut s'accumuler lors d'opérations répétées, en particulier dans des programmes où la performance est critique. Ce surcoût est dû à la nécessité pour l'interpréteur Python de déterminer le type de l'objet et la méthode à appeler à chaque exécution.</p>

<p>Il est crucial de noter que l'impact du polymorphisme sur la performance est généralement négligeable pour la plupart des applications. Cependant, dans les sections de code les plus critiques, où la performance est primordiale, des alternatives comme le *duck typing* ou des optimisations spécifiques au problème peuvent être envisagées. Le *duck typing*, bien que subtil, permet de se concentrer sur le comportement d'un objet (s'il "ressemble à un canard et nage comme un canard, alors c'est un canard") plutôt que sur son type spécifique, ce qui peut réduire le besoin de hiérarchies de classes complexes et potentiellement améliorer la performance.  Cette approche exploite la nature dynamique de Python pour gagner en flexibilité et, potentiellement, en vitesse.</p>

<p>Par exemple, au lieu de s'appuyer sur une classe de base et des classes dérivées avec des méthodes spécifiques, on pourrait écrire :</p>

<pre><code class="language-python">
def process_object(obj):
    """
    Processes an object based on its 'perform' method, if it exists.
    This exemplifies duck typing: we care about the 'perform' method, not the object's type.
    """
    if hasattr(obj, 'perform') and callable(obj.perform):
        obj.perform()  # Call the 'perform' method if it exists
    else:
        print("Object does not have a 'perform' method.")

class MyObject:
    def perform(self):
        print("MyObject is performing an action.")

class AnotherObject:
    def perform(self):
        print("AnotherObject is executing its task.")

# Create instances
obj1 = MyObject()
obj2 = AnotherObject()

# Process the objects
process_object(obj1)
process_object(obj2)
</code></pre>

<p>Dans cet exemple, la fonction <code class="language-python">process_object</code> ne vérifie pas le type de l'objet, mais simplement si l'objet possède une méthode nommée <code class="language-python">perform</code>. Si c'est le cas, elle l'appelle. Cela offre une grande flexibilité et évite le surcoût lié à la résolution du type lors de l'exécution.</p>

<p>En conclusion, bien que le polymorphisme soit un outil puissant pour écrire du code flexible et maintenable, il est important de prendre en compte les implications potentielles en termes de performance, en particulier dans les applications sensibles à la latence. L'utilisation judicieuse du *duck typing* et d'autres techniques d'optimisation peut aider à atténuer ces problèmes et à garantir que votre code Python reste performant. Comprendre ces compromis permet de prendre des décisions éclairées lors de la conception de systèmes complexes et performants en Python.</p>
</p>
    <h3>6.1 Impact du Duck Typing sur la Performance</h3>
    <p><p>Le duck typing, principe fondamental du polymorphisme en Python, offre une flexibilité considérable, mais cette souplesse a un impact sur les performances. Contrairement aux langages à typage statique où le compilateur effectue des vérifications de type au moment de la compilation, permettant ainsi des optimisations, Python effectue ces vérifications à l'exécution. Ce processus peut engendrer une surcharge.</p>

<p>Considérons une fonction effectuant une opération sur un objet:</p>

<pre><code class="language-python">
def operate(item):
    """
    Performs an operation on an item.

    Args:
        item: An object expected to have a 'compute' method.
    """
    return item.compute()
</code></pre>

<p>Dans cet exemple, Python ne vérifie pas si l'objet <code class="language-python">item</code> possède une méthode <code class="language-python">compute()</code> avant de l'appeler. Si cette méthode est absente, une exception <code class="language-python">AttributeError</code> sera levée lors de l'exécution. Un langage à typage statique aurait détecté cette erreur lors de la compilation, évitant ainsi un plantage à l'exécution.</p>

<p>Cependant, l'impact sur les performances n'est pas toujours critique. Pour des opérations simples comme l'appel de méthodes, la surcharge est minime. Le coût devient plus significatif dans les boucles intensives ou lors d'un grand nombre d'appels polymorphes.</p>

<p>Voici quelques stratégies pour atténuer l'impact du duck typing sur les performances :</p>

<ul>
    <li><strong>Utiliser des profilers :</strong> Identifiez les sections de code qui ralentissent l'exécution pour concentrer vos efforts d'optimisation. L'utilisation de <code class="language-python">cProfile</code> est fortement recommandée.</li>
    <li><strong>Éviter les vérifications de type inutiles :</strong> Le duck typing repose sur le principe que "si une chose se comporte comme un canard, alors c'est un canard". Évitez donc d'utiliser <code class="language-python">isinstance()</code> pour effectuer des vérifications de type explicites, sauf si cela est absolument nécessaire.</li>
    <li><strong>Exploiter les structures de données natives :</strong> Utilisez les structures de données et les fonctions intégrées de Python, car elles sont généralement optimisées pour des performances maximales.</li>
    <li><strong>Compiler avec Cython :</strong> Pour les sections de code les plus critiques en termes de performance, envisagez de compiler le code Python en C à l'aide de Cython. Cela peut apporter des améliorations significatives.</li>
</ul>

<p>Voici un exemple d'utilisation de <code class="language-python">isinstance()</code> à éviter, sauf nécessité absolue :</p>

<pre><code class="language-python">
def process_item(item):
    """
    Processes an item, but avoids unnecessary type checking.

    Args:
        item: The item to process.
    """
    # Avoid this unless absolutely necessary
    if isinstance(item, SomeClass):
        item.process()
    else:
        # Handle the case where item is not an instance of SomeClass
        pass
</code></pre>

<p>Dans la plupart des cas, il est préférable de simplement appeler la méthode <code class="language-python">process()</code> de l'objet <code class="language-python">item</code> et de laisser une exception se produire si l'objet ne possède pas cette méthode.  C'est le principe du duck typing.</p>

<p>En conclusion, le duck typing offre une grande flexibilité en Python, mais il est crucial de comprendre son impact potentiel sur les performances. En appliquant des techniques d'optimisation judicieuses et en minimisant les vérifications de type superflues, il est possible de créer un code performant tout en exploitant les avantages du polymorphisme.</p>
</p>
    <h3>6.2 Optimisation du Code Polymorphe</h3>
    <p><p>Le polymorphisme, bien que puissant pour concevoir du code flexible et maintenable, peut introduire des considérations de performance en raison des appels dynamiques. L'optimisation du code polymorphe vise à minimiser ces surcoûts. Voici quelques techniques clés pour améliorer la performance dans vos applications Python.</p>

<p><strong>Réduction des appels dynamiques:</strong> En Python, le polymorphisme repose sur le "duck typing" et la résolution dynamique des méthodes au moment de l'exécution. Chaque appel de méthode à travers une interface polymorphe implique une recherche dans la table des méthodes de l'objet, ce qui peut être coûteux en termes de performance. Réduire le nombre de ces appels peut améliorer significativement les performances. Une approche consiste à déplacer les opérations coûteuses hors des boucles internes ou des fonctions fréquemment appelées, en les précalculant ou en les mettant en cache. Par exemple, si une opération polymorphe effectue des calculs complexes qui ne dépendent pas de chaque instance, vous pouvez précalculer ces résultats et les stocker pour une utilisation ultérieure.</p>

<pre><code class="language-python">
class Shape:
    def __init__(self, color):
        self.color = color

    def area(self):
        # This method should be overridden by subclasses
        raise NotImplementedError("Subclasses must implement the area method")

class Circle(Shape):
    def __init__(self, color, radius):
        super().__init__(color)
        self.radius = radius
        self._area = None # Cache for area

    def area(self):
        if self._area is None:
            self._area = 3.14159 * self.radius * self.radius # Calculate area only once
        return self._area

# Example Usage
circle = Circle("red", 5)
print(circle.area()) # First call calculates and caches the area
print(circle.area()) # Subsequent calls return the cached area
</code></pre>

<p>Dans cet exemple, la classe <code class="language-python">Circle</code> calcule la surface uniquement lors du premier appel à la méthode <code class="language-python">area()</code>. Les appels suivants renvoient la valeur mise en cache, ce qui évite des calculs redondants.</p>

<p><strong>Utilisation de structures de données optimisées:</strong> Le choix des structures de données peut avoir un impact significatif sur les performances du code polymorphe, surtout lorsque de grandes collections d'objets sont impliquées. Par exemple, utiliser des tableaux NumPy pour des opérations numériques peut être beaucoup plus rapide que d'utiliser des listes Python standard, même si les objets dans le tableau sont d'une classe polymorphe. NumPy est optimisé pour les opérations vectorielles, ce qui peut réduire considérablement le temps d'exécution.</p>

<pre><code class="language-python">
import numpy as np

class VectorOperation:
    def __init__(self, data):
        self.data = np.array(data)  # Use NumPy array for efficient operations

    def sum(self):
        return np.sum(self.data) # Use NumPy's sum function

# Example usage
data = [1, 2, 3, 4, 5]
vector_op = VectorOperation(data)
print(vector_op.sum()) # Output: 15
</code></pre>

<p>Ici, l'utilisation de <code class="language-python">numpy.array</code> dans la classe <code class="language-python">VectorOperation</code> permet d'exploiter les opérations vectorisées de NumPy, ce qui est généralement plus rapide que d'itérer sur une liste Python standard.</p>

<p><strong>Profilage et analyse comparative (Benchmarking):</strong> L'optimisation doit être basée sur des mesures concrètes. Utilisez des outils de profilage comme <code class="language-python">cProfile</code> pour identifier les goulots d'étranglement dans votre code polymorphe. Effectuez des analyses comparatives (benchmarks) avec différents algorithmes et structures de données pour déterminer l'approche la plus performante pour votre cas d'utilisation spécifique. <code class="language-python">timeit</code> est également un module utile pour mesurer le temps d'exécution de petits extraits de code.</p>

<pre><code class="language-python">
import cProfile
import timeit

# Example functions for benchmarking
def list_sum(data):
    return sum(data)

def numpy_sum(data):
    return np.sum(data)

# Setup data
data = list(range(1000))
numpy_data = np.array(data)

# Benchmark using timeit
list_time = timeit.timeit(lambda: list_sum(data), number=10000)
numpy_time = timeit.timeit(lambda: numpy_sum(numpy_data), number=10000)

print(f"Time for list sum: {list_time}")
print(f"Time for NumPy sum: {numpy_time}")

# Example function to profile
def combined_operation():
    list_sum(data)
    numpy_sum(numpy_data)

# Profile the function using cProfile
cProfile.run('combined_operation()')
</code></pre>

<p>Ce code profile la fonction <code class="language-python">combined_operation</code> et mesure son temps d'exécution, ce qui permet d'identifier les sections du code qui nécessitent une optimisation. De même, <code class="language-python">timeit</code> est utilisé pour comparer les performances de l'addition de liste native de Python et de l'addition NumPy.</p>

<p>En conclusion, l'optimisation du code polymorphe en Python exige une compréhension des compromis entre flexibilité et performance. En réduisant les appels dynamiques grâce à la mise en cache, en utilisant des structures de données optimisées comme NumPy, et en profilant votre code pour identifier les goulots d'étranglement, vous pouvez améliorer considérablement les performances de vos applications polymorphes. N'oubliez pas que l'optimisation prématurée peut être contre-productive, il est donc important de mesurer et de valider les améliorations de performance.</p>
</p>
    <h3>6.3 Profiling et Benchmarking</h3>
    <p><p>Le polymorphisme, tout en offrant une grande souplesse dans la conception logicielle, peut engendrer des complexités en matière de performance. La capacité d'un objet à adopter différentes formes peut entraîner une surcharge lors de l'exécution, notamment pendant la résolution dynamique des méthodes. Afin de comprendre et d'optimiser l'impact du polymorphisme sur la performance, le profiling et le benchmarking sont des outils essentiels.</p>

<p>Le <strong>profiling</strong> consiste à mesurer le temps d'exécution et la fréquence d'appel des différentes parties du code. En Python, plusieurs outils de profiling sont disponibles, tels que <code class="language-python">cProfile</code> (pour un profiling déterministe) et <code class="language-python">line_profiler</code> (pour un profiling ligne par ligne plus précis). Ces outils permettent d'identifier les points de contention, c'est-à-dire les portions de code qui consomment le plus de temps, afin de concentrer les efforts d'optimisation.</p>

<p>Considérons un exemple où différentes classes implémentent une méthode de calcul, et où le polymorphisme est utilisé pour appeler cette méthode sur une collection d'objets de ces classes.</p>

<pre><code class="language-python">
import cProfile
import pstats
import io

class Shape:
    def area(self):
        raise NotImplementedError("Subclasses must implement area method")

class Rectangle(Shape):
    def __init__(self, width, height):
        self.width = width
        self.height = height

    def area(self):
        return self.width * self.height

class Triangle(Shape):
    def __init__(self, base, height):
        self.base = base
        self.height = height

    def area(self):
        return 0.5 * self.base * self.height

def calculate_total_area(shapes):
    total_area = 0
    for shape in shapes:
        total_area += shape.area()
    return total_area

# Create a list of shapes
shapes = [Rectangle(5, 10), Triangle(4, 8), Rectangle(3, 6)] * 1000

# Profile the calculate_total_area function
pr = cProfile.Profile()
pr.enable()
total_area = calculate_total_area(shapes)
pr.disable()

# Print profiling results
s = io.StringIO()
sortby = 'cumulative' # Sort by cumulative time
ps = pstats.Stats(pr, stream=s).sort_stats(sortby)
ps.print_stats(20) # Show only the top 20 lines

print(s.getvalue())
</code></pre>

<p>L'exécution de ce code avec <code class="language-python">cProfile</code> révèle le temps passé dans chaque appel de la méthode <code class="language-python">area()</code> des classes <code class="language-python">Rectangle</code> et <code class="language-python">Triangle</code>. Si le profiling montre que ces appels représentent une part importante du temps d'exécution, des optimisations peuvent être envisagées. Par exemple, on pourrait utiliser la spécialisation du code pour certains types d'objets ou employer des techniques de mémoïsation pour réduire les calculs redondants.</p>

<p>Le <strong>benchmarking</strong>, quant à lui, sert à mesurer la performance d'un code dans des conditions contrôlées. Il consiste à répéter l'exécution un grand nombre de fois et à calculer des statistiques (temps moyen, écart-type, etc.). L'outil <code class="language-python">timeit</code> de Python est particulièrement adapté à cette fin.</p>

<pre><code class="language-python">
import timeit

# Benchmark the calculate_total_area function
setup_code = """
from __main__ import Rectangle, Triangle, calculate_total_area

shapes = [Rectangle(5, 10), Triangle(4, 8), Rectangle(3, 6)] * 1000
"""

stmt = "calculate_total_area(shapes)"

# Run the benchmark
number_of_runs = 1000
execution_time = timeit.timeit(stmt, setup=setup_code, number=number_of_runs)

print(f"Execution time for {number_of_runs} runs: {execution_time:.6f} seconds")
print(f"Average execution time per run: {execution_time / number_of_runs:.6f} seconds")
</code></pre>

<p>Le benchmarking permet de comparer différentes implémentations d'un même algorithme ou diverses optimisations potentielles. Par exemple, si l'on envisage de remplacer le polymorphisme par une approche basée sur des structures de données plus spécifiques, on peut mesurer l'impact de ce changement sur la performance grâce au benchmarking et déterminer si cette modification apporte une amélioration significative.</p>

<p>En résumé, le profiling et le benchmarking sont des outils essentiels pour comprendre et optimiser la performance du code polymorphe en Python. Ils permettent d'identifier les points de contention et de valider l'efficacité des optimisations apportées. En utilisant ces techniques, on peut garantir un code qui est à la fois flexible et performant, tirant le meilleur parti du polymorphisme tout en minimisant son impact sur la vitesse d'exécution.</p>
</p>
  </section>
</div>


<div class="content_box">
  <section>
    <h2 class="heading">7. Cas d'utilisation pratiques</h2>
    <p><p>Le polymorphisme en compiletime offre des avantages significatifs dans divers scénarios. Explorons quelques cas d'utilisation pratiques où cette technique peut améliorer la flexibilité et la maintenabilité du code.</p>

<p><strong>Surcharge d'opérateurs pour des types personnalisés</strong></p>

<p>En Python, il est possible de définir le comportement des opérateurs (<code class="language-python">+</code>, <code class="language-python">-</code>, <code class="language-python">*</code>, etc.) pour des classes personnalisées. La surcharge d'opérateurs est une forme de polymorphisme en compiletime car la méthode à appeler est déterminée en fonction du type des opérandes lors de la définition de la classe. Cela permet d'écrire du code plus expressif et lisible, en utilisant les opérateurs standards avec des objets complexes. La résolution de la méthode se fait statiquement, avant l'exécution.</p>

<pre><code class="language-python">
class Fraction:
    def __init__(self, numerator, denominator):
        self.numerator = numerator
        self.denominator = denominator

    def __add__(self, other):
        # Implementation of addition between two fractions
        if isinstance(other, Fraction):
            new_numerator = self.numerator * other.denominator + other.numerator * self.denominator
            new_denominator = self.denominator * other.denominator
            return Fraction(new_numerator, new_denominator)
        else:
            raise TypeError("Can only add Fraction objects to other Fraction objects")


    def __str__(self):
        return f"{self.numerator}/{self.denominator}"

# Example usage:
fraction1 = Fraction(1, 2)
fraction2 = Fraction(1, 3)
sum_fractions = fraction1 + fraction2
print(sum_fractions) # Output: 5/6

# Example with error handling
try:
    sum_fractions = fraction1 + 5
except TypeError as e:
    print(e)  # Output: Can only add Fraction objects to other Fraction objects
</code></pre>

<p>Dans cet exemple, l'opérateur <code class="language-python">+</code> est surchargé pour la classe <code class="language-python">Fraction</code>. Lorsque l'on additionne deux objets <code class="language-python">Fraction</code>, la méthode <code class="language-python">__add__</code> est appelée, permettant de définir une logique d'addition spécifique aux fractions. Une vérification de type est ajoutée pour assurer que l'addition se fait uniquement entre objets <code class="language-python">Fraction</code>, améliorant ainsi la robustesse du code.</p>

<p><strong>Fonctions génériques avec décorateurs</strong></p>

<p>Les décorateurs, en particulier <code class="language-python">@singledispatch</code> du module <code class="language-python">functools</code>, peuvent être utilisés pour créer des fonctions génériques qui se comportent différemment en fonction du type de l'argument.  Bien que le typage dynamique de Python ne permette pas une résolution complètement statique comme dans les langages compilés, <code class="language-python">@singledispatch</code> effectue une forme de résolution statique au moment de la définition des fonctions décorées. Ceci est utile pour adapter une fonction à plusieurs types d'entrée, évitant la duplication de code et rendant le code plus maintenable.</p>

<pre><code class="language-python">
from functools import singledispatch

@singledispatch
def describe(arg):
    print("I don't know how to describe this object.")

@describe.register(int)
def _(arg):
    print(f"This is an integer: {arg}")

@describe.register(str)
def _(arg):
    print(f"This is a string: {arg}")

@describe.register(list)
def _(arg):
    print(f"This is a list: {arg}")
    for i, item in enumerate(arg):
        print(f"  Element {i+1}: {item}")


# Example usage:
describe(10)       # Output: This is an integer: 10
describe("Hello")  # Output: This is a string: Hello
describe([1, 2, 3]) # Output: This is a list: [1, 2, 3] \n Element 1: 1 \n Element 2: 2 \n Element 3: 3
describe(10.5) # Output: I don't know how to describe this object.
</code></pre>

<p>Ici, la fonction <code class="language-python">describe</code> est un exemple de fonction générique. Le décorateur <code class="language-python">@singledispatch</code> permet de définir une implémentation par défaut, et <code class="language-python">@describe.register(type)</code> permet d'enregistrer des implémentations spécifiques pour chaque type. L'appel de <code class="language-python">describe</code> avec différents types d'arguments sélectionnera l'implémentation appropriée. Un exemple avec une liste est ajouté pour illustrer comment traiter des types de données plus complexes.</p>

<p><strong>Création de DSL (Domain Specific Languages) internes</strong></p>

<p>Le polymorphisme en compiletime (ou son équivalent approché en Python) facilite la création de DSL internes, où une syntaxe spécifique est définie pour un domaine particulier. En utilisant la surcharge d'opérateurs et les décorateurs, on peut créer une interface plus expressive et intuitive pour interagir avec le code. Cela permet de masquer la complexité sous-jacente et de fournir une abstraction de haut niveau pour les utilisateurs du DSL.</p>

<pre><code class="language-python">
class Query:
    def __init__(self, field):
        self.field = field
        self.criteria = []

    def equals(self, value):
        self.criteria.append((self.field, "=", value))
        return self

    def greater_than(self, value):
        self.criteria.append((self.field, ">", value))
        return self

    def less_than(self, value):
        self.criteria.append((self.field, "<", value))
        return self

    def __str__(self):
        return " AND ".join([f"{field} {op} {value}" for field, op, value in self.criteria])


# Example Usage
query = Query("age").greater_than(18).less_than(30).equals(25)
print(query) # Output: age > 18 AND age < 30 AND age = 25

query2 = Query("name").equals("Alice")
print(query2) # Output: name = Alice
</code></pre>

<p>Dans cet exemple, la classe <code class="language-python">Query</code> permet de construire des requêtes de manière fluide. Les méthodes <code class="language-python">equals</code>, <code class="language-python">greater_than</code> et <code class="language-python">less_than</code> ajoutent des critères à la requête. La surcharge de la méthode <code class="language-python">__str__</code> permet de représenter la requête sous forme de chaîne de caractères. L'utilisateur peut ainsi créer des requêtes complexes de manière intuitive. Un exemple supplémentaire est inclus pour montrer la flexibilité du DSL.</p>

<p>Ces exemples illustrent comment le polymorphisme en compiletime (ou son approximation en Python) peut être utilisé pour améliorer la flexibilité, la lisibilité et la maintenabilité du code. En tirant parti de la surcharge d'opérateurs et des décorateurs, on peut créer des interfaces plus expressives et adaptées à des domaines spécifiques, tout en rendant le code plus robuste et facile à comprendre.</p>
</p>
    <h3>7.1 Frameworks Web (Django, Flask)</h3>
    <p><p>Les frameworks web Python, tels que Django et Flask, tirent parti du polymorphisme pour offrir une flexibilité et une modularité accrues. Cette approche permet une gestion élégante des requêtes et réponses HTTP, ainsi qu'une interaction simplifiée avec diverses bases de données, tout en minimisant les modifications du code principal.</p>

<p>Dans le contexte du routage web, le polymorphisme se manifeste par la capacité d'accepter différentes "vues" pour traiter une requête. Une vue peut être une fonction simple ou une classe plus élaborée, à condition qu'elle respecte une interface commune, généralement définie par un ensemble d'arguments attendus et une valeur de retour spécifique (par exemple, un objet <code class="language-python">HttpResponse</code> dans Django). Cette souplesse permet aux développeurs de choisir l'approche la plus adaptée à chaque cas d'utilisation.</p>

<p>Voici un exemple simplifié avec Flask, illustrant comment différentes fonctions peuvent être associées à des routes spécifiques :</p>

<pre><code class="language-python">
from flask import Flask

app = Flask(__name__)

# Define a simple view function
def index():
    return "Hello, World!"

# Define another view function
def greet(name):
    return f"Hello, {name}!"

# Map the view functions to URL rules
app.add_url_rule('/', 'index', index)
app.add_url_rule('/greet/<name>', 'greet', greet)

# Run the Flask application (for demonstration purposes)
if __name__ == '__main__':
    app.run(debug=True)
</code></pre>

<p>Dans cet exemple, les fonctions <code class="language-python">index</code> et <code class="language-python">greet</code> sont des vues polymorphes. Elles respectent l'interface implicite définie par Flask (à savoir, retourner une chaîne de caractères qui sera traitée comme une réponse HTTP). Flask peut appeler l'une ou l'autre en fonction de l'URL demandée.</p>

<p>De plus, les ORM (Object-Relational Mappers) de Django utilisent le polymorphisme pour masquer les détails d'implémentation spécifiques aux différentes bases de données. Les développeurs peuvent interagir avec PostgreSQL, MySQL ou SQLite en utilisant la même syntaxe et les mêmes méthodes, sans avoir à écrire de code spécifique à chaque système de base de données. Cette abstraction simplifie considérablement le développement et la maintenance des applications.</p>

<p>Considérons un modèle Django simple :</p>

<pre><code class="language-python">
from django.db import models

# Define a simple model for events
class Event(models.Model):
    title = models.CharField(max_length=200)
    date = models.DateTimeField()
    location = models.CharField(max_length=200)

    def __str__(self):
        return self.title
</code></pre>

<p>Ce modèle peut être utilisé avec n'importe quelle base de données supportée par Django. Django prend en charge la traduction des opérations (création, lecture, mise à jour, suppression) en requêtes SQL spécifiques à la base de données sous-jacente, masquant ainsi les différences entre les systèmes. Par exemple, la création d'une instance de <code class="language-python">Event</code> et sa sauvegarde dans la base de données utilisera des requêtes SQL différentes selon que l'on utilise PostgreSQL ou MySQL, mais le code Python reste le même. Ainsi, le polymorphisme permet une abstraction efficace, simplifiant le développement, améliorant la portabilité des applications et facilitant les tests.</p>
</p>
    <h3>7.2 Bibliothèques de Data Science (NumPy, Pandas)</h3>
    <p><p>NumPy et Pandas, des bibliothèques fondamentales pour la science des données en Python, illustrent de manière éloquente le polymorphisme en compiletime. Elles peuvent manipuler une grande variété de types de données sans nécessiter de code spécifique pour chaque type. Cette capacité est cruciale pour travailler efficacement avec de vastes ensembles de données.</p>

<p>NumPy, au cœur du calcul numérique en Python, exploite le polymorphisme grâce à ses opérations vectorisées. Ces opérations, appliquées aux tableaux (<code class="language-python">ndarray</code>), fonctionnent harmonieusement quel que soit le type des données numériques qu'ils contiennent (entiers, flottants, etc.). L'avantage majeur réside dans l'amélioration significative des performances, car NumPy utilise des routines précompilées pour traiter les données.</p>

<p>Prenons l'exemple suivant :</p>

<pre><code class="language-python">
import numpy as np

# NumPy gère différents types numériques de manière polymorphe
int_array = np.array([1, 2, 3], dtype=np.int32)
float_array = np.array([1.0, 2.5, 3.7], dtype=np.float64)

# L'addition vectorisée fonctionne de manière transparente sur les deux tableaux
sum_int = int_array + 5
sum_float = float_array + 2.0

print("Sum of integer array:", sum_int)
print("Sum of float array:", sum_float)

# NumPy effectue automatiquement un upcasting vers le type le plus général
mixed_array = int_array + float_array
print("Sum of mixed array:", mixed_array)
print("Type of mixed_array elements:", mixed_array.dtype)
</code></pre>

<p>Dans cet exemple, l'opérateur d'addition (<code class="language-python">+</code>) s'adapte de façon transparente aux types <code class="language-python">int32</code> et <code class="language-python">float64</code>. De plus, l'addition d'un tableau d'entiers et d'un tableau de flottants produit un tableau de flottants. NumPy effectue une promotion de type implicite, assurant ainsi la préservation de la précision des données.</p>

<p>Pandas, bâti sur NumPy, étend ce polymorphisme à la manipulation des données tabulaires. Un DataFrame Pandas peut accueillir des colonnes de types très divers (entiers, flottants, chaînes de caractères, booléens, etc.), et les opérations appliquées à ces colonnes s'adaptent en conséquence.</p>

<p>Illustrons cela avec un exemple concret :</p>

<pre><code class="language-python">
import pandas as pd

# Création d'un DataFrame Pandas avec des types de données mixtes
data = {'ID': [1, 2, 3, 4],
        'Name': ['Alice', 'Bob', 'Charlie', 'David'],
        'Score': [85.5, 92.0, 78.5, 88.0],
        'Passed': [True, True, False, True]}

df = pd.DataFrame(data)

print(df)

# Calcul de la moyenne des scores
average_score = df['Score'].mean()
print("Average Score:", average_score)

# Filtrage des lignes où le score est supérieur à la moyenne
above_average = df[df['Score'] > average_score]
print("Students above average:\n", above_average)

# Concaténation des chaînes de caractères dans la colonne 'Name'
combined_names = ', '.join(df['Name'])
print("Combined names:", combined_names)
</code></pre>

<p>Dans cet exemple, le DataFrame contient des colonnes de type entier (<code class="language-python">ID</code>), chaîne de caractères (<code class="language-python">Name</code>), flottant (<code class="language-python">Score</code>) et booléen (<code class="language-python">Passed</code>). Les opérations telles que le calcul de la moyenne (<code class="language-python">mean()</code>), le filtrage (<code class="language-python">df[df['Score'] > average_score]</code>) et la concaténation de chaînes (<code class="language-python">', '.join(df['Name'])</code>) fonctionnent sans problème grâce au polymorphisme, sans nécessiter de conversions de type explicites ou de code particulier pour chaque type de colonne.</p>

<p>En conclusion, NumPy et Pandas exploitent le polymorphisme pour offrir une flexibilité et une efficacité remarquables dans la manipulation des données. Cette capacité à gérer différents types de données de manière transparente représente un atout majeur pour les tâches de science des données, permettant aux développeurs de se concentrer sur la logique métier plutôt que sur les détails de typage.</p>
</p>
    <h3>7.3 Bibliothèques d'interface graphique (Tkinter, PyQt)</h3>
    <p><p>Tkinter et PyQt sont des bibliothèques largement utilisées en Python pour la création d'interfaces graphiques (GUI). Elles exploitent le polymorphisme pour offrir une flexibilité considérable dans la gestion des widgets et des événements, permettant ainsi de développer des applications riches et interactives.</p>
<p>Chaque type de widget, qu'il s'agisse d'un bouton, d'une étiquette ou d'une zone de texte, est considéré comme une instance d'une classe spécifique. Ces classes héritent d'une classe de base commune, telle que <code class="language-python">Widget</code> dans Tkinter ou <code class="language-python">QWidget</code> dans PyQt. Cette classe de base définit une interface standardisée, comprenant des méthodes permettant de configurer la taille, la position, la couleur et d'autres propriétés visuelles. Grâce au polymorphisme, il est possible de manipuler ces widgets de manière uniforme, quel que soit leur type précis, ce qui simplifie grandement le code et favorise la réutilisation.</p>
<p>L'exemple ci-dessous illustre ce concept avec Tkinter :</p>
<pre><code class="language-python">
import tkinter as tk

# Create the main window
root = tk.Tk()
root.title("Polymorphism Example")

# Create different types of widgets
button = tk.Button(root, text="Click Me")
label = tk.Label(root, text="This is a Label")
entry = tk.Entry(root)

# Place the widgets on the window
button.pack()
label.pack()
entry.pack()

# Start the GUI event loop
root.mainloop()
</code></pre>
<p>Dans cet exemple, <code class="language-python">button</code>, <code class="language-python">label</code> et <code class="language-python">entry</code> sont tous des widgets, mais appartiennent à des classes différentes (<code class="language-python">Button</code>, <code class="language-python">Label</code> et <code class="language-python">Entry</code> respectivement). Néanmoins, ils peuvent tous être placés sur la fenêtre (<code class="language-python">root</code>) à l'aide de la méthode <code class="language-python">pack()</code>, qui fait partie de l'interface commune définie par la classe de base <code class="language-python">Widget</code>. C'est un exemple simple de polymorphisme à l'œuvre.</p>
<p>Le polymorphisme joue également un rôle essentiel dans la gestion des événements. Un bouton peut réagir à un clic, tandis qu'une zone de texte peut répondre à la saisie au clavier. Chaque widget peut posséder ses propres fonctions de gestion d'événements (callbacks), qui sont exécutées lorsqu'un événement spécifique se produit. Ces fonctions sont définies en fonction du type de widget et de l'événement auquel il doit répondre, ce qui permet une personnalisation poussée du comportement de l'interface utilisateur. L'exemple suivant illustre ce mécanisme :</p>
<pre><code class="language-python">
import tkinter as tk

# Define callback functions for events
def button_clicked():
    print("Button was clicked!")

def entry_changed(event):
    print("Entry changed:", entry.get())

# Create the main window
root = tk.Tk()
root.title("Event Handling Example")

# Create widgets and bind events to callbacks
button = tk.Button(root, text="Click Me", command=button_clicked)
entry = tk.Entry(root)
entry.bind("<KeyRelease>", entry_changed)  # Bind the entry_changed function to the KeyRelease event

# Place widgets on the window
button.pack()
entry.pack()

# Start the GUI event loop
root.mainloop()
</code></pre>
<p>Dans cet exemple, la fonction <code class="language-python">button_clicked</code> est associée à l'événement de clic du bouton (<code class="language-python">command=button_clicked</code>). De même, la fonction <code class="language-python">entry_changed</code> est liée à l'événement de relâchement d'une touche dans la zone de texte (<code class="language-python">entry.bind("<KeyRelease>", entry_changed)</code>). Ces fonctions ne sont appelées que lorsque l'événement correspondant se produit pour le widget approprié. Cela démontre comment le polymorphisme permet de gérer les événements de manière flexible et spécifique à chaque type de widget, en adaptant le comportement de l'application en fonction des interactions de l'utilisateur.</p>
<p>En résumé, Tkinter et PyQt exploitent le polymorphisme pour gérer de manière uniforme une variété de types de widgets et d'événements. Cela simplifie le développement d'interfaces graphiques complexes en permettant aux développeurs de manipuler les widgets de manière générique tout en conservant un comportement spécifique à chaque type, ce qui améliore la modularité, la maintenabilité et la réutilisabilité du code.</p>
</p>
  </section>
</div>


<div class="content_box">
  <section>
    <h2 class="heading">8. Exercices avec solutions</h2>
    <p><p>Pour consolider votre compréhension du polymorphisme en compiletime en Python, voici quelques exercices avec solutions. Ces exercices couvrent la surcharge de méthodes et d'opérateurs, en mettant l'accent sur le typage statique implicite rendu possible par des outils comme <code class="language-python">typing</code> et <code class="language-python">mypy</code>.</p>

<p><strong>Exercice 1 : Surcharge de méthode avec <code class="language-python">@overload</code></strong></p>
<p>Créez une classe <code class="language-python">MathUtils</code> avec une méthode <code class="language-python">add</code> surchargée qui peut prendre soit deux entiers, soit deux chaînes de caractères, et renvoie respectivement la somme ou la concaténation.</p>
<pre><code class="language-python">
from typing import overload

class MathUtils:
    @overload
    def add(self, x: int, y: int) -> int:
        ...

    @overload
    def add(self, x: str, y: str) -> str:
        ...

    def add(self, x, y):
        # Implementation of the add method
        if isinstance(x, int) and isinstance(y, int):
            return x + y
        elif isinstance(x, str) and isinstance(y, str):
            return x + y
        else:
            raise TypeError("Invalid argument types")

# Example usage
math_utils = MathUtils()
print(math_utils.add(5, 3))
print(math_utils.add("Hello, ", "World!"))

# The following line would raise a TypeError when type-checked by mypy
# print(math_utils.add(5, "World!"))
</code></pre>

<p><strong>Exercice 2 : Surcharge d'opérateur avec <code class="language-python">__add__</code></strong></p>
<p>Définissez une classe <code class="language-python">Point</code> représentant un point dans un espace 2D. Surchargez l'opérateur <code class="language-python">+</code> pour permettre l'addition de deux objets <code class="language-python">Point</code>, en additionnant leurs coordonnées x et y respectivement.</p>
<pre><code class="language-python">
class Point:
    def __init__(self, x: float, y: float):
        # Initialize the x and y coordinates
        self.x = x
        self.y = y

    def __add__(self, other: 'Point') -> 'Point':
        # Overload the + operator to add two Point objects
        return Point(self.x + other.x, self.y + other.y)

    def __str__(self):
        # String representation of the Point object
        return f"Point(x={self.x}, y={self.y})"

# Example Usage:
point1 = Point(1.0, 2.5)
point2 = Point(2.0, 3.5)
point3 = point1 + point2
print(point3)
</code></pre>

<p><strong>Exercice 3 : Contrôle de type avec <code class="language-python">isinstance</code> et <code class="language-python">typing.Union</code></strong></p>
<p>Écrivez une fonction <code class="language-python">process_value</code> qui accepte soit un entier, soit une chaîne de caractères. Si c'est un entier, retournez son carré. Si c'est une chaîne de caractères, retournez la chaîne en majuscules. Utilisez <code class="language-python">typing.Union</code> pour indiquer que la fonction peut accepter les deux types.</p>
<pre><code class="language-python">
from typing import Union

def process_value(value: Union[int, str]) -> Union[int, str]:
    # Process the value based on its type
    if isinstance(value, int):
        return value ** 2
    elif isinstance(value, str):
        return value.upper()
    else:
        raise TypeError("Invalid argument type")

# Example Usage:
print(process_value(5))
print(process_value("hello"))

# The following line would raise a TypeError
# print(process_value(5.5))
</code></pre>

<p><strong>Exercice 4 : Combinaison de surcharge de méthode et d'opérateur</strong></p>
<p>Créez une classe <code class="language-python">Vector</code> avec une méthode <code class="language-python">scale</code> surchargée qui peut multiplier le vecteur par un scalaire (int ou float). Surchargez l'opérateur <code class="language-python">*</code> pour effectuer la même opération.</p>
<pre><code class="language-python">
from typing import Union, overload

class Vector:
    def __init__(self, x: float, y: float):
        # Initialize the x and y components of the vector
        self.x = x
        self.y = y

    @overload
    def scale(self, scalar: int) -> 'Vector':
        ...

    @overload
    def scale(self, scalar: float) -> 'Vector':
        ...

    def scale(self, scalar: Union[int, float]) -> 'Vector':
        # Scale the vector by a scalar value
        return Vector(self.x * scalar, self.y * scalar)

    def __mul__(self, scalar: Union[int, float]) -> 'Vector':
        # Overload the * operator to scale the vector
        return self.scale(scalar)

    def __str__(self):
        # String representation of the Vector object
        return f"Vector(x={self.x}, y={self.y})"


# Example Usage:
v1 = Vector(1.0, 2.0)
v2 = v1.scale(2)
v3 = v1 * 0.5

print(v2)
print(v3)
</code></pre>

<p>Ces exercices illustrent différentes facettes du polymorphisme en compiletime en Python, en exploitant la surcharge de méthodes et d'opérateurs. N'oubliez pas d'utiliser <code class="language-python">mypy</code> pour vérifier statiquement vos types et détecter les erreurs potentielles avant l'exécution.</p>
</p>
    <h3>8.1 Exercise 1: Polymorphic Function for Area Calculation</h3>
    <p><p>Cet exercice illustre comment le polymorphisme en compiletime, souvent réalisé via le duck typing en Python, permet de créer une fonction unique pour manipuler différentes formes géométriques. L'exigence clé est que chaque forme possède une méthode <code class="language-python">area</code>.</p>
<pre><code class="language-python">
# Define classes for different shapes, each with an 'area' method
class Circle:
    def __init__(self, radius):
        self.radius = radius

    def area(self):
        return 3.14159 * self.radius * self.radius

class Square:
    def __init__(self, side):
        self.side = side

    def area(self):
        return self.side * self.side

class Parallelogram:
    def __init__(self, base, height):
        self.base = base
        self.height = height

    def area(self):
        return self.base * self.height

# Polymorphic function to calculate area based on duck typing
def calculate_area(shape):
    # The function checks if the object has an 'area' method and if it's callable.
    if hasattr(shape, 'area') and callable(shape.area):
        return shape.area()
    else:
        return "Shape does not have a calculable area."

# Create instances of the shapes
circle = Circle(5)
square = Square(4)
parallelogram = Parallelogram(6, 8)

# Calculate and print the areas using the polymorphic function
print("Area of the circle:", calculate_area(circle))
print("Area of the square:", calculate_area(square))
print("Area of the parallelogram:", calculate_area(parallelogram))

# Example with an object that doesn't have the 'area' method
class CustomObject:
    def __init__(self, name):
        self.name = name

custom_object = CustomObject("My Object")
print("Area of the custom object:", calculate_area(custom_object))
</code></pre>
<p>Dans cet exemple, la fonction <code class="language-python">calculate_area</code> accepte un objet en entrée et vérifie si cet objet possède une méthode nommée <code class="language-python">area</code> qui est également appelable. Si c'est le cas, elle appelle cette méthode et retourne le résultat. Sinon, elle retourne un message d'erreur. Ceci illustre le principe du duck typing : si un objet possède une méthode <code class="language-python">area</code>, il est traité comme une forme capable de calculer son aire, indépendamment de sa classe.</p>
<p>L'avantage principal de cette approche est sa flexibilité et son extensibilité.  De nouvelles formes géométriques peuvent être ajoutées sans modifier la fonction <code class="language-python">calculate_area</code>, à condition qu'elles implémentent la méthode <code class="language-python">area</code>. Il est crucial de noter que cette flexibilité a un coût : l'absence de vérification de type statique peut entraîner des erreurs d'exécution si un objet ne possédant pas la méthode <code class="language-python">area</code> est passé à la fonction.  Une vérification plus robuste pourrait être ajoutée pour s'assurer que l'objet est bien une instance d'une classe géométrique attendue, mais cela irait à l'encontre du principe du duck typing.</p>
</p>
    <h3>8.2 Exercise 2: Generic Data Processing Function</h3>
    <p><p>Le polymorphisme en compiletime permet de créer des fonctions génériques capables de traiter différents types de données de manière flexible et sécurisée. L'exercice suivant illustre cette capacité en Python, en utilisant des TypeVars pour définir une fonction qui peut appliquer une transformation à une liste d'éléments, quel que soit leur type.</p>

<pre><code class="language-python">
from typing import List, Callable, TypeVar

# Define type variables for generic typing
T = TypeVar('T')
R = TypeVar('R')

def process_data(data: List[T], transformation: Callable[[T], R]) -> List[R]:
    """
    Applies a given transformation function to each element in a list.

    Args:
        data (List[T]): The input list of elements of type T.
        transformation (Callable[[T], R]): The transformation function that takes an element of type T and returns an element of type R.

    Returns:
        List[R]: A new list containing the results of applying the transformation to each element in the input list.
    """
    return [transformation(item) for item in data]
</code></pre>

<p>Cette fonction <code class="language-python">process_data</code> prend une liste d'éléments de type <code class="language-python">T</code> et une fonction de transformation comme arguments. La fonction de transformation accepte un élément de type <code class="language-python">T</code> et retourne un élément de type <code class="language-python">R</code>. Le résultat est une nouvelle liste contenant les éléments transformés, de type <code class="language-python">R</code>.</p>

<p>Voici quelques exemples d'utilisation de cette fonction:</p>

<pre><code class="language-python">
# Example 1: Convert a list of integers to their string representations
numbers: List[int] = [1, 2, 3, 4, 5]
string_numbers: List[str] = process_data(numbers, str)
print(f"Original numbers: {numbers}")
print(f"String numbers: {string_numbers}")

# Example 2: Calculate the square of each number in a list of floats
float_numbers: List[float] = [1.5, 2.5, 3.5, 4.5, 5.5]
squared_numbers: List[float] = process_data(float_numbers, lambda x: x**2)
print(f"Original float numbers: {float_numbers}")
print(f"Squared numbers: {squared_numbers}")

# Example 3: Get the length of each string in a list of strings
strings: List[str] = ["apple", "banana", "cherry"]
string_lengths: List[int] = process_data(strings, len)
print(f"Original strings: {strings}")
print(f"String lengths: {string_lengths}")
</code></pre>

<p>Dans ces exemples, la fonction <code class="language-python">process_data</code> est utilisée avec différents types de données et différentes fonctions de transformation, démontrant sa capacité à s'adapter à divers scénarios. Le polymorphisme en compiletime, grâce à l'utilisation de <code class="language-python">TypeVar</code>, permet de garantir que les types sont vérifiés statiquement, offrant ainsi une meilleure sécurité et détectant les erreurs potentielles avant l'exécution.</p>
</p>
    <h3>8.3 Exercise 3: Polymorphic Sorting with Custom Comparison</h3>
    <p><p>Le polymorphisme compiletime, à travers une fonction de tri polymorphe utilisant une fonction de comparaison personnalisée, offre une adaptabilité remarquable. L'objectif est de concevoir une fonction de tri capable de traiter divers types d'objets, en utilisant une fonction de comparaison définie par l'utilisateur pour établir l'ordre de tri. Cela permet d'ajuster le comportement du tri en fonction des exigences spécifiques, sans nécessiter la création de multiples fonctions de tri distinctes.</p>

<p>Voici une implémentation possible en Python :</p>

<pre><code class="language-python">
def sort_list(data, compare_func):
    """
    Sorts a list of items using a custom comparison function.

    Args:
        data: The list of items to sort.
        compare_func: A function that takes two items and returns:
                      - A negative value if item1 should come before item2.
                      - A positive value if item1 should come after item2.
                      - Zero if item1 and item2 are equal.
    """
    n = len(data)
    for i in range(n):
        for j in range(0, n-i-1):
            if compare_func(data[j], data[j+1]) > 0:
                data[j], data[j+1] = data[j+1], data[j]

# Example usage
class Employee:
    def __init__(self, name, salary, seniority):
        self.name = name
        self.salary = salary
        self.seniority = seniority  # Years of service

    def __repr__(self):
        return f"Employee(name='{self.name}', salary={self.salary}, seniority={self.seniority})"


# Comparison functions
def compare_by_salary(emp1, emp2):
    """
    Compares two employees based on their salary.
    Returns a negative value if emp1's salary is less than emp2's,
    a positive value if emp1's salary is greater than emp2's,
    and zero if their salaries are equal.
    """
    return emp1.salary - emp2.salary


def compare_by_name(emp1, emp2):
    """
    Compares two employees based on their name.
    Returns -1 if emp1's name is lexicographically less than emp2's,
    1 if emp1's name is lexicographically greater than emp2's,
    and 0 if their names are equal.
    """
    if emp1.name < emp2.name:
        return -1
    elif emp1.name > emp2.name:
        return 1
    else:
        return 0


def compare_by_seniority(emp1, emp2):
    """
    Compares two employees based on their seniority (years of service).
    Returns a positive value if emp1's seniority is less than emp2's (higher seniority first),
    a negative value if emp1's seniority is greater than emp2's,
    and zero if their seniority is equal.
    """
    return emp2.seniority - emp1.seniority  # Higher seniority first


# Create a list of Employee objects
employees = [
    Employee("Bob", 60000, 3),
    Employee("Alice", 75000, 5),
    Employee("Charlie", 50000, 1),
    Employee("David", 75000, 7),
]

# Sort by salary
sort_list(employees, compare_by_salary)
print("Sorted by salary:", employees)

# Sort by name
sort_list(employees, compare_by_name)
print("Sorted by name:", employees)

# Sort by seniority
sort_list(employees, compare_by_seniority)
print("Sorted by seniority:", employees)
</code></pre>

<p>Dans cet exemple, la fonction <code class="language-python">sort_list</code> accepte une liste d'objets et une fonction de comparaison comme paramètres. La fonction <code class="language-python">compare_func</code> est utilisée pour établir l'ordre relatif de deux éléments. L'exemple utilise une classe <code class="language-python">Employee</code> et plusieurs fonctions de comparaison : <code class="language-python">compare_by_salary</code> compare les employés en fonction de leur salaire, <code class="language-python">compare_by_name</code> compare en fonction du nom, et <code class="language-python">compare_by_seniority</code> compare en fonction de l'ancienneté. La fonction <code class="language-python">sort_list</code> est ensuite appelée avec la liste d'employés et la fonction de comparaison appropriée pour trier la liste en fonction du critère désiré.</p>

<p>Cet exemple met en évidence le polymorphisme compiletime en Python. La fonction <code class="language-python">sort_list</code> demeure inchangée, mais son comportement varie considérablement en fonction de la fonction de comparaison qui lui est fournie. Cette approche permet d'écrire un code plus générique et réutilisable, ce qui constitue un avantage majeur du polymorphisme.</p>
</p>
  </section>
</div>


<div class="content_box">
  <section>
    <h2 class="heading">9. Résumé et Comparaisons</h2>
    <p><p>En résumé, le polymorphisme en compiletime en Python, bien que conceptuellement différent de son implémentation dans des langages comme le C++, offre un ensemble d'outils puissants pour structurer le code et améliorer sa maintenabilité. Nous avons exploré diverses techniques, notamment le <em>type hinting</em>, les <em>protocoles</em> et les <em>méthodes décorées avec <code class="language-python">@overload</code></em>, chacune contribuant à une forme de vérification statique. Ces techniques permettent une spécialisation basée sur le type des arguments, effectuée par des analyseurs statiques avant l'exécution du programme, offrant ainsi une meilleure robustesse du code.</p>

<p>Il est essentiel de comprendre que le polymorphisme en compiletime en Python ne se traduit pas directement par des gains de performance à l'exécution, contrairement au C++ où la résolution du polymorphisme se fait lors de la compilation. En Python, l'objectif principal de ces techniques est de fournir des informations aux outils d'analyse statique comme MyPy, afin de détecter les erreurs de type potentielles dès la phase de développement. Ceci minimise le risque de bugs imprévus et facilite la refactorisation du code au fil du temps.</p>

<p>Comparons maintenant ces approches avec le polymorphisme runtime traditionnel de Python :</p>

<ul>
    <li><strong>Polymorphisme Runtime :</strong> S'appuie sur la nature dynamique de Python, où les types sont vérifiés durant l'exécution. Cela offre une grande flexibilité mais peut également conduire à des erreurs si les types ne sont pas gérés avec soin.</li>
    <li><strong>Type Hinting et Analyse Statique :</strong> Introduisent une couche de vérification statique optionnelle. Bien qu'ils ne modifient pas le comportement de Python au runtime, ils permettent aux outils d'identifier les erreurs de type avant l'exécution, améliorant ainsi la qualité du code.</li>
    <li><strong>Protocoles :</strong> Définissent des interfaces implicites. Une classe est considérée conforme à un protocole si elle implémente les méthodes et attributs requis, même sans héritage explicite. Ceci favorise le duck typing tout en bénéficiant d'une validation statique.</li>
    <li><strong>Méthodes Décorées avec <code class="language-python">@overload</code> :</strong> Permettent de définir plusieurs signatures pour une même méthode, chacune correspondant à des types d'arguments spécifiques. MyPy utilise ces informations pour s'assurer que les appels de méthode respectent les types attendus.</li>
</ul>

<p>Voici un exemple illustrant l'utilisation du type hinting pour une fonction qui effectue des opérations différentes selon le type de son argument :</p>

<pre><code class="language-python">
from typing import Union

def process_data(data: Union[int, str]) -> str:
    """
    Processes data differently based on its type.

    Args:
        data: Either an integer or a string.

    Returns:
        A string representation of the processed data.
    """
    if isinstance(data, int):
        # If the data is an integer, square it and convert to string.
        result = data ** 2
        return f"Integer processed: {result}"
    elif isinstance(data, str):
        # If the data is a string, convert it to uppercase.
        result = data.upper()
        return f"String processed: {result}"
    else:
        return "Unsupported data type"

# Example usages
print(process_data(5))  # Output: Integer processed: 25
print(process_data("hello")) # Output: String processed: HELLO
</code></pre>

<p>Sans type hinting, il serait plus difficile pour un outil d'analyse statique de détecter les erreurs potentielles dans les appels à cette fonction. Le type hinting explicite permet à MyPy de vérifier si la fonction est appelée avec les types d'arguments attendus, améliorant ainsi la robustesse du code.</p>

<p>En conclusion, le polymorphisme en compiletime en Python ne vise pas à remplacer le polymorphisme runtime, mais plutôt à le compléter en fournissant des outils pour une vérification statique plus rigoureuse. En utilisant judicieusement ces techniques, il est possible d'améliorer significativement la qualité, la lisibilité et la maintenabilité des projets Python.</p>
</p>
    <h3>9.1 Résumé des Techniques de Polymorphisme en Compiletime en Python</h3>
    <p><p>Nous avons exploré différentes techniques de polymorphisme en compiletime disponibles en Python, allant des approches les plus souples aux méthodes offrant un contrôle plus strict.</p>

<p>Le <strong>duck typing</strong>, approche idiomatique en Python, repose sur le principe que si un objet se comporte comme un canard, il est traité comme tel.  Cette technique offre une flexibilité maximale et encourage la conception d'interfaces implicites.  Cependant, son principal inconvénient réside dans l'absence de vérification statique des types. Les erreurs ne sont détectées qu'à l'exécution, ce qui peut compliquer le débogage. Voici un exemple :</p>

<pre><code class="language-python">
class Animal:
    def make_sound(self):
        print("Generic animal sound")

class Dog:
    def make_sound(self):
        print("Woof!")

class Cat:
    def make_sound(self):
        print("Meow!")

def animal_sound(animal):
    animal.make_sound()

# Duck typing in action: No explicit type checking needed.
my_dog = Dog()
my_cat = Cat()

animal_sound(my_dog) # Prints "Woof!"
animal_sound(my_cat) # Prints "Meow!"
</code></pre>

<p>L'utilisation de <strong>generics</strong> via le module <code class="language-python">typing</code> permet d'introduire des annotations de type. Bien que Python conserve son typage dynamique, ces annotations permettent à des outils externes tels que MyPy de réaliser une vérification statique. Cela aide à identifier des erreurs potentielles avant l'exécution du code. Le coût est une complexité accrue du code et la dépendance à un outil de vérification externe.  Voici un exemple :</p>

<pre><code class="language-python">
from typing import List, TypeVar, Generic

T = TypeVar('T')

class Collection(Generic[T]):
    def __init__(self, items: List[T]):
        self.items = items

    def first(self) -> T:
        return self.items[0]

numbers: Collection[int] = Collection([1, 2, 3])
first_number: int = numbers.first()
print(first_number) # Prints 1

# The following line would raise a type error if checked with MyPy
# strings: Collection[str] = Collection([1, "2", 3])
</code></pre>

<p>Le <strong>dispatching basé sur le type</strong>, notamment avec <code class="language-python">functools.singledispatch</code>, offre une manière élégante de surcharger une fonction en fonction du type de son premier argument. Cela permet de gérer différents types d'entrée de façon spécifique et maintenable.  Cependant, cela peut rendre la structure du code plus complexe, et la surcharge est limitée au premier argument.  Par exemple :</p>

<pre><code class="language-python">
import functools

@functools.singledispatch
def describe(arg):
    return "Type inconnu"

@describe.register(int)
def _(arg):
    return "Valeur entière"

@describe.register(list)
def _(arg):
    return "Liste de valeurs"

print(describe(10))        # Prints "Valeur entière"
print(describe([1, 2, 3]))   # Prints "Liste de valeurs"
print(describe("Hello"))     # Prints "Type inconnu"
</code></pre>

<p>La <strong>métaprogrammation</strong>, en utilisant les métaclasses, est l'approche la plus puissante et flexible. Elle permet de contrôler le processus de création des classes elles-mêmes, offrant ainsi la possibilité d'ajouter des comportements spécifiques en fonction des attributs de la classe. Cela peut être utile pour appliquer des contraintes ou générer du code automatiquement. Le prix à payer est une complexité accrue du code et un risque d'introduction de bugs difficiles à diagnostiquer. Son utilisation est recommandée uniquement lorsque les autres techniques ne suffisent pas. Exemple :</p>

<pre><code class="language-python">
class EnforceAttributesMeta(type):
    def __new__(cls, name, bases, attrs):
        required_attributes = attrs.get("__required_attributes__", [])
        for attr_name in required_attributes:
            if attr_name not in attrs:
                raise TypeError(f"La classe {name} doit définir l'attribut {attr_name}")
        return super().__new__(cls, name, bases, attrs)


class MyClass(metaclass=EnforceAttributesMeta):
    __required_attributes__ = ["attribute_a", "attribute_b"]

    attribute_a = 10
    attribute_b = 20

# The following would raise a TypeError because attribute_b is missing
# class MyClass(metaclass=EnforceAttributesMeta):
#     __required_attributes__ = ["attribute_a", "attribute_b"]

#     attribute_a = 10
</code></pre>

<p>Chaque technique a ses avantages et ses inconvénients. Le choix de la technique la plus adaptée dépendra des besoins spécifiques du projet, de la complexité du problème à résoudre, et du niveau de rigueur souhaité en matière de vérification des types.</p>
</p>
    <h3>9.2 Comparaison avec le Polymorphisme en Runtime</h3>
    <p><p>Le polymorphisme en compiletime et le polymorphisme en runtime sont deux approches distinctes pour atteindre la flexibilité et la réutilisabilité du code. Le premier, que nous avons exploré à travers le duck typing et les generics (via des outils comme <code class="language-python">typing</code> en Python), se manifeste durant la phase de compilation (ou d'analyse statique dans le cas de Python). Le second, quant à lui, intervient lors de l'exécution du programme.</p>

<p>Le polymorphisme en runtime, plus classique, repose sur l'héritage et les interfaces (bien que Python n'ait pas d'interfaces explicites comme Java ou C#, le duck typing joue un rôle similaire). Il permet à des objets de différentes classes d'être traités de manière uniforme grâce à une classe de base commune ou à l'implémentation de méthodes portant le même nom. Par exemple :</p>

<pre><code class="language-python">
class Animal:
    def make_sound(self):
        print("Generic animal sound")

class Lion(Animal):
    def make_sound(self):
        print("Roar!")

class Bird(Animal):
    def make_sound(self):
        print("Chirp!")

def animal_sound(animal: Animal):
    animal.make_sound()

lion = Lion()
bird = Bird()

animal_sound(lion)  # Output: Roar!
animal_sound(bird)  # Output: Chirp!
</code></pre>

<p>Ici, la fonction <code class="language-python">animal_sound</code> accepte n'importe quel objet de type <code class="language-python">Animal</code> et appelle sa méthode <code class="language-python">make_sound</code>. Le comportement exact est déterminé au moment de l'exécution en fonction du type réel de l'objet. C'est un exemple typique de polymorphisme en runtime. La liaison (binding) de la méthode <code class="language-python">make_sound</code> à appeler est effectuée dynamiquement.</p>

<p>En comparaison, le polymorphisme en compiletime (ou statique) se concentre sur la vérification des types et la résolution des méthodes avant l'exécution. Avec le duck typing, si un objet a les bonnes méthodes et attributs, il est considéré comme étant du type approprié, sans nécessiter d'héritage explicite. Avec les generics, on peut contraindre plus fortement le type des arguments, permettant une meilleure vérification statique. Voici un exemple qui illustre bien le duck typing :</p>

<pre><code class="language-python">
class Duck:
    def quack(self):
        print("Quack!")

    def fly(self):
        print("Duck flying")

class Person:
    def quack(self):
        print("Person imitating a duck")

    def fly(self):
        print("Person pretending to fly")

def make_it_quack(thing):
    thing.quack()
    thing.fly()


duck = Duck()
person = Person()

make_it_quack(duck)   # Output: Quack! Duck flying
make_it_quack(person) # Output: Person imitating a duck Person pretending to fly
</code></pre>

<p>Dans cet exemple, <code class="language-python">Person</code> n'hérite pas de <code class="language-python">Duck</code>, mais il est traité comme tel par la fonction <code class="language-python">make_it_quack</code> car il possède les méthodes attendues (<code class="language-python">quack</code> et <code class="language-python">fly</code>). C'est le duck typing en action. La vérification de la présence des méthodes <code class="language-python">quack</code> et <code class="language-python">fly</code> est effectuée lors de l'exécution, mais l'intention est de s'assurer que l'objet passé à <code class="language-python">make_it_quack</code> se comporte comme un canard (d'où le nom "duck typing").</p>

<p>Quand choisir l'un ou l'autre ? Le polymorphisme en runtime est approprié lorsque vous avez besoin de flexibilité et d'extensibilité, permettant d'ajouter de nouveaux types d'objets sans modifier le code existant (principe ouvert/fermé). L'héritage facilite la création d'une hiérarchie de classes avec des comportements spécialisés. Cependant, une utilisation excessive de l'héritage peut conduire à des hiérarchies complexes et difficiles à maintenir. Il est particulièrement utile dans les situations où le type exact d'un objet ne peut être connu qu'au moment de l'exécution.</p>

<p>Le polymorphisme en compiletime, notamment via le duck typing, est plus adapté lorsque la flexibilité et la simplicité sont prioritaires. Il permet d'écrire du code plus concis et moins dépendant des hiérarchies de classes. Les generics, quant à eux, ajoutent une couche de vérification statique, ce qui peut aider à détecter les erreurs plus tôt dans le cycle de développement. Ils sont particulièrement bénéfiques pour garantir la cohérence des types et éviter les erreurs inattendues lors de l'exécution. Le choix dépendra donc des contraintes du projet, des priorités en matière de maintenance et de la granularité du contrôle souhaitée sur les types. En résumé, le polymorphisme en runtime offre une grande flexibilité au prix d'une complexité potentielle, tandis que le polymorphisme en compiletime privilégie la simplicité et la vérification statique, offrant ainsi une robustesse accrue.</p>
</p>
    <h3>9.3 Bonnes Pratiques et Recommandations</h3>
    <p><p>L'adoption du polymorphisme en compiletime en Python représente un atout majeur pour optimiser la performance et la maintenabilité du code, mais sa mise en œuvre exige une méthodologie rigoureuse. Voici des recommandations et bonnes pratiques pour exploiter pleinement cette technique.</p>

<p><strong>Prioriser l'annotation de type et la validation statique</strong> : L'utilisation systématique d'annotations de type, conjointement avec des outils de vérification statique tels que <code class="language-python">mypy</code>, est essentielle. Ces outils permettent d'identifier les erreurs de type potentielles avant l'exécution, garantissant ainsi un comportement polymorphe correct et conforme aux spécifications.</p>

<pre><code class="language-python">
from typing import Protocol, runtime_checkable

@runtime_checkable
class Speakable(Protocol):
    def speak(self) -> str:
        ...

def make_speak(animal: Speakable) -> str:
    # This function expects an object that implements the Speakable protocol
    return animal.speak()

class Duck:
    def speak(self) -> str:
        return "Quack!"

class Dog:
    def speak(self) -> str:
        return "Woof!"

# Instances of Duck and Dog can be used interchangeably 
# because they both implement the Speakable protocol
my_duck = Duck()
print(make_speak(my_duck))

my_dog = Dog()
print(make_speak(my_dog))
</code></pre>

<p><strong>Concevoir sur la base de protocoles clairs et précis</strong> : La définition de protocoles précis, qui spécifient les méthodes et attributs attendus, aide à structurer les interfaces polymorphes. Cela améliore la lisibilité du code et simplifie la création de classes compatibles, tout en permettant à <code class="language-python">mypy</code> d'effectuer des vérifications plus approfondies.</p>

<pre><code class="language-python">
from typing import Protocol

class Printable(Protocol):
    def to_string(self) -> str:
        ...

def print_item(item: Printable) -> None:
    # Accepts any object that conforms to the Printable protocol
    print(item.to_string())

class Number:
    def __init__(self, value: int):
        self.value = value

    def to_string(self) -> str:
        return str(self.value)

class Text:
    def __init__(self, content: str):
        self.content = content

    def to_string(self) -> str:
        return self.content

# Both Number and Text implement the Printable protocol
my_number = Number(10)
print_item(my_number)

my_text = Text("Hello")
print_item(my_text)
</code></pre>

<p><strong>Mettre en place des tests unitaires exhaustifs</strong> : Bien que la validation statique contribue à identifier de nombreuses erreurs, les tests unitaires restent indispensables. Il est crucial de concevoir des tests qui couvrent tous les scénarios d'utilisation du code polymorphe, en particulier les interactions entre différentes classes et protocoles. L'utilisation de frameworks comme <code class="language-python">unittest</code> permet de structurer ces tests de manière efficace.</p>

<pre><code class="language-python">
import unittest

class TestPrintable(unittest.TestCase):

    def test_number_to_string(self):
        num = Number(5)
        self.assertEqual(num.to_string(), "5")

    def test_text_to_string(self):
        text = Text("World")
        self.assertEqual(text.to_string(), "World")

    def test_number_is_printable(self):
        num = Number(42)
        # Verifies that Number instances can be used with print_item
        print_item(num)

    def test_text_is_printable(self):
        text = Text("Test")
        # Verifies that Text instances can be used with print_item
        print_item(text)
</code></pre>

<p><strong>Limiter les vérifications de type dynamiques inutiles</strong> : Dans une optique de polymorphisme en compiletime, il est préférable d'éviter l'usage excessif de fonctions telles que <code class="language-python">isinstance</code> ou <code class="language-python">issubclass</code> lors de l'exécution. Ces vérifications peuvent atténuer les gains de performance et complexifier la maintenance du code. Privilégiez une conception rigoureuse des protocoles et une validation statique via <code class="language-python">mypy</code>.</p>

<p>En conclusion, l'écriture de code polymorphe propre, maintenable et performant en Python repose sur une approche qui combine annotations de type, protocoles précis, validation statique et tests unitaires rigoureux. En minimisant les vérifications de type dynamiques superflues, on maximise les avantages du polymorphisme en compiletime et on garantit un code robuste et facile à appréhender.</p>
</p>
  </section>
</div>


<div class="content_box">
  <section>
    <h2 class="heading">Conclusion</h2>
    <p><p>En conclusion, le polymorphisme en compiletime en Python, bien que moins explicite que dans certains autres langages, est une réalité que l'on peut exploiter. Le "duck typing", principe fondamental du langage, confère une flexibilité remarquable en permettant aux objets d'être interchangés à condition qu'ils implémentent les méthodes et attributs requis.  Cette souplesse doit s'accompagner d'une rigueur accrue de la part des développeurs pour éviter les erreurs potentielles.</p>

<p>Pour renforcer la robustesse du code et compenser les limites du typage dynamique, Python offre des outils puissants tels que les generics via le module <code class="language-python">typing</code> et les analyseurs statiques comme MyPy. Ces outils permettent d'ajouter des annotations de type, de spécifier les types attendus pour les variables et les arguments de fonctions, et de détecter les incompatibilités potentielles avant l'exécution du programme. Cette approche permet d'anticiper et de corriger les erreurs dès la phase de développement.</p>

<p>Voici un exemple d'utilisation des generics pour spécifier le type des éléments d'une liste et bénéficier d'une vérification statique:</p>

<pre><code class="language-python">
from typing import List

def process_numbers(numbers: List[int]) -> int:
    """
    Processes a list of integers and returns their sum.

    Args:
        numbers: A list of integers.

    Returns:
        The sum of the numbers in the list.
    """
    total = 0
    for number in numbers:
        total += number
    return total

# Example Usage
number_list: List[int] = [1, 2, 3, 4, 5]
sum_of_numbers = process_numbers(number_list)
print(f"The sum of the numbers is: {sum_of_numbers}")

# This would cause a type checking error with MyPy:
# invalid_list: List[int] = [1, 2, "3", 4, 5]
</code></pre>

<p>L'exemple ci-dessus montre comment l'annotation <code class="language-python">List[int]</code> assure que la fonction <code class="language-python">process_numbers</code> reçoit bien une liste d'entiers. MyPy signalera une erreur si une liste contenant des types non-entiers est passée à cette fonction.</p>

<p>En combinant l'adaptabilité du duck typing avec la précision des annotations de type et la puissance des outils d'analyse statique, les développeurs Python peuvent exploiter les avantages du polymorphisme en compiletime pour créer des applications plus fiables, plus faciles à maintenir et moins susceptibles de contenir des erreurs. L'adoption de ces techniques est essentielle pour améliorer la qualité globale des projets Python, en particulier dans les contextes où la robustesse et la prévisibilité sont primordiales.</p>
</p>
  </section>
</div>


<!-- End of Course Marker -->
<div class="course-end-marker" style="margin: 4rem auto; text-align: center; max-width: 600px">
  <div style="height: 2px; background: linear-gradient(90deg, transparent, #fb5168 50%, transparent); margin: 2rem auto;"></div>
  <p style="color: #fb5168; font-size: 1.2rem; font-weight: 500; letter-spacing: 1px; opacity: 0.9;">
    That's all folks
  </p>
</div></div>
    </main>

    <!-- (Non-critical JS after DOM parsing) -->
    <script src="/src/js/back-to-top.js" type="module" defer></script>
    <script src="/src/js/include-footer.js" type="module" defer></script>
    <script src="/src/js/include-navbar.js" type="module" defer></script>
    <script src="/src/js/include-course-navbar.js" type="module" defer></script>
    <script src="/src/js/include-mobile-course-navbar.js" type="module" defer></script>
    <script src="/src/js/slider.js" type="module" defer></script>
    <script src="/src/js/copy-code-button.js" type="module" defer></script>
    <!-- (Non-critical JS after DOM parsing) -->

 </body>
</html>