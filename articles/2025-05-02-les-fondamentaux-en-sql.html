<!DOCTYPE html>
<html class="style-orange-3 custom_fonts comps live_website" lang="fr">
  <head>
    <!------------------- Essential Meta Tags ------------------>    
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta property="og:type" content="website" />
    <!------------------- Essential Meta Tags ------------------>    

    <!-------------------- Core SEO Elements -------------------->    
    <!-- Essential Title and SEO Meta Tags PLACEHOLDER -->
    <title>Les fondamentaux en SQL | Formateur</title>
    <meta name="description" content="Découvrez tout sur Les fondamentaux en SQL dans cet article détaillé." />
    <meta property="og:title" content="Les fondamentaux en SQL | Formateur" />
    <meta property="og:description" content="Découvrez tout sur Les fondamentaux en SQL dans cet article détaillé." />
    <meta name="twitter:title" content="Les fondamentaux en SQL | Formateur" />
    <meta name="twitter:description" content="Découvrez tout sur Les fondamentaux en SQL dans cet article détaillé." />
    <!-- Essential Title and SEO Meta Tags PLACEHOLDER -->
    <!-------------------- Core SEO Elements -------------------->    

    <!-- Structured Data PLACEHOLDER -->
    <!-- Structured Data -->

    <!-- End Structured Data -->
    <!-- Structured Data PLACEHOLDER -->

    <!-------------- Canonical and Alternate Links PLACEHOLDER ------------->
    <!-------------- Canonical and Alternate Links ------------->

    <!-------------- Canonical and Alternate Links ------------->
    <!-------------- Canonical and Alternate Links PLACEHOLDER ------------->

    <!----------------- Favicon and Assets ------------------->
    <!-- Favicon and Social Media Images -->
    <link
      rel="icon"
      type="image/png"
      href="https://www.clearcode.fr/assets/icons/favicon.ico"
      sizes="48x48"
    />
    <meta
      property="og:image"
      content="https://www.clearcode.fr/assets/images/og-image.png"
    />
    <meta property="og:image:width" content="1200" />
    <meta property="og:image:height" content="630" />
    <meta
      property="og:image:alt"
      content="ClearCode - Formations en mathématiques et programmation IT"
    />
    <meta property="og:image:type" content="image/png" />
    <!-- Fallback image format -->
    <meta
      property="og:image"
      content="https://www.clearcode.fr/assets/images/og-image.webp"
    />
    <meta
      name="twitter:image"
      content="https://www.clearcode.fr/assets/images/og-image.png"
    />
    <!----------------- Favicon and Assets ------------------->

    <script src="/src/js/code-preprocessor.js"></script>

    <!-- Stylesheets -->
    <link rel="stylesheet" href="/src/css/main.css" />
    <link rel="stylesheet" href="/src/css/dropdown.css" />
    <link rel="stylesheet" href="/src/css/mobile-course-navbar.css" />

    <!-- Prism.js core script -->
    <script
      src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"
      defer
    ></script>
    <!-- Prism.js language support for Python -->
    <script
      src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-python.min.js"
      defer
    ></script>
    <script 
      src="/src/js/reduce-prism-dom.js" 
      defer>
    </script>


    <!-- Python Code CSS -->
    <link rel="stylesheet" href="/src/css/python-code.css" />

    <!-- Scripts -->
  </head>

  <body class="comps">
    <main class="container">
      <!-- 0. TITRE -->
      <div class="content_box">
        <h1 class="heading heading--accent">Les fondamentaux en SQL</h1>
      </div>

<div class="content_box">
  <section>
    <h2 class="heading">Introduction</h2>
    <p><p>SQL (Structured Query Language) est le langage standard pour interagir avec les systèmes de gestion de bases de données relationnelles (SGBDR). Il permet de définir, manipuler, interroger et contrôler les données stockées dans ces bases de données. Considérez SQL comme un pont universel vous permettant de communiquer avec vos données.</p>

<p>L'opération fondamentale en SQL est la requête. Les requêtes permettent d'extraire, d'insérer, de mettre à jour ou de supprimer des informations. L'instruction la plus courante est <code  class="language-sql">SELECT</code>, utilisée pour récupérer des données depuis une ou plusieurs tables. Voici un exemple pour sélectionner toutes les colonnes de la table "Customers" :</p>

<pre><code  class="language-sql">
-- Select all columns from the Customers table
SELECT * FROM Customers;
</code></pre>

<p>L'ajout d'une clause <code  class="language-sql">WHERE</code> permet de filtrer les résultats en fonction de critères spécifiques. En combinant <code  class="language-sql">SELECT</code> et <code  class="language-sql">WHERE</code>, on peut cibler précisément les informations souhaitées. Imaginons que l'on souhaite récupérer tous les clients résidant en France :</p>

<pre><code  class="language-sql">
-- Select all customers from France
SELECT * FROM Customers
WHERE Country = 'France';
</code></pre>

<p>SQL ne se limite pas à la récupération de données. Il permet également de modifier le contenu de la base de données. Les instructions <code  class="language-sql">INSERT</code>, <code  class="language-sql">UPDATE</code> et <code  class="language-sql">DELETE</code> servent respectivement à ajouter de nouvelles entrées, modifier des entrées existantes et supprimer des entrées. Voici un exemple d'insertion d'un nouveau client :</p>

<pre><code  class="language-sql">
-- Insert a new customer into the Customers table
INSERT INTO Customers (CustomerName, City, Country)
VALUES ('Nouveau Client', 'Paris', 'France');
</code></pre>

<p>La maîtrise de SQL est une compétence clé pour tout professionnel travaillant avec des données, qu'il s'agisse de développeurs, d'analystes ou d'administrateurs de bases de données. Comprendre SQL permet d'interagir efficacement avec les données et d'en extraire des informations pertinentes. Les exemples présentés ici constituent un point de départ. Une exploration plus approfondie de SQL vous ouvrira les portes à des requêtes plus complexes, à l'optimisation des performances et à une gestion des données plus efficace.</p>
</p>
  </section>
</div>


<div class="content_box">
  <section>
    <h2 class="heading">1. Introduction aux bases de données relationnelles et SQL</h2>
    <p><p>Les bases de données relationnelles constituent un fondement essentiel de la gestion des données modernes. Elles organisent les informations au sein de tables, lesquelles sont composées de lignes (enregistrements) et de colonnes (attributs). La force de ce modèle réside dans les relations qui peuvent être définies entre ces tables, permettant une gestion efficace des données complexes et interconnectées.</p>

<p>SQL, ou Structured Query Language, est le langage standard utilisé pour interagir avec les bases de données relationnelles. Il permet la création, la lecture, la mise à jour et la suppression de données (CRUD - Create, Read, Update, Delete). SQL ne se limite pas à la manipulation des données ; il permet également de définir la structure de la base de données elle-même.</p>

<p>Prenons un exemple simple : une base de données conçue pour gérer les informations relatives aux livres et à leurs auteurs. Nous utiliserions deux tables : <code  class="language-sql">Livres</code> et <code  class="language-sql">Auteurs</code>.</p>

<p>La table <code  class="language-sql">Auteurs</code> pourrait comprendre les colonnes suivantes :</p>
<ul>
    <li><code  class="language-sql">auteur_id</code> : Identifiant unique de l'auteur (clé primaire)</li>
    <li><code  class="language-sql">nom</code> : Nom de l'auteur</li>
    <li><code  class="language-sql">pays</code> : Pays d'origine de l'auteur</li>
</ul>

<p>La table <code  class="language-sql">Livres</code> pourrait comprendre les colonnes suivantes :</p>
<ul>
    <li><code  class="language-sql">livre_id</code> : Identifiant unique du livre (clé primaire)</li>
    <li><code  class="language-sql">titre</code> : Titre du livre</li>
    <li><code  class="language-sql">auteur_id</code> : Identifiant de l'auteur (clé étrangère référençant la table Auteurs)</li>
    <li><code  class="language-sql">annee_publication</code> : Année de publication</li>
</ul>

<p>Voici un exemple de création de ces tables en SQL :</p>

<pre><code  class="language-sql">
-- Create the Auteurs table
CREATE TABLE Auteurs (
    auteur_id INT PRIMARY KEY,
    nom VARCHAR(255),
    pays VARCHAR(255)
);

-- Create the Livres table
CREATE TABLE Livres (
    livre_id INT PRIMARY KEY,
    titre VARCHAR(255),
    auteur_id INT,
    annee_publication INT,
    FOREIGN KEY (auteur_id) REFERENCES Auteurs(auteur_id)
);
</code></pre>

<p>Dans cet exemple, <code  class="language-sql">PRIMARY KEY</code> définit la clé primaire de chaque table, garantissant l'unicité de chaque enregistrement. <code  class="language-sql">FOREIGN KEY</code> établit une relation entre les tables <code  class="language-sql">Livres</code> et <code  class="language-sql">Auteurs</code>, permettant de lier un livre à son auteur. La clé étrangère assure l'intégrité référentielle, empêchant l'ajout de livres avec un <code  class="language-sql">auteur_id</code> inexistant dans la table <code  class="language-sql">Auteurs</code>.</p>

<p>Pour insérer des données dans ces tables, on utilise la commande <code  class="language-sql">INSERT</code> :</p>

<pre><code  class="language-sql">
-- Insert data into the Auteurs table
INSERT INTO Auteurs (auteur_id, nom, pays) VALUES
(1, 'J.K. Rowling', 'Angleterre'),
(2, 'George Orwell', 'Inde');

-- Insert data into the Livres table
INSERT INTO Livres (livre_id, titre, auteur_id, annee_publication) VALUES
(101, 'Harry Potter et la Pierre Philosophale', 1, 1997),
(102, '1984', 2, 1949);
</code></pre>

<p>Pour récupérer des informations, on utilise la commande <code  class="language-sql">SELECT</code>. On peut récupérer toutes les colonnes ou seulement certaines. On peut également filtrer les résultats à l'aide de la clause <code  class="language-sql">WHERE</code> :</p>

<pre><code  class="language-sql">
-- Select all books published after 1950
SELECT titre, annee_publication FROM Livres WHERE annee_publication > 1950;
</code></pre>

<p>On peut également combiner les informations de plusieurs tables grâce à la jointure (<code  class="language-sql">JOIN</code>) :</p>

<pre><code  class="language-sql">
-- Select the title of the book and the name of the author
SELECT Livres.titre, Auteurs.nom
FROM Livres
INNER JOIN Auteurs ON Livres.auteur_id = Auteurs.auteur_id;
</code></pre>

<p>Les bases de données relationnelles et SQL fournissent une méthode structurée et puissante de gérer et d'interroger des données. La maîtrise de ces concepts est indispensable pour tout développeur ou analyste de données. Elles permettent de garantir l'intégrité, la cohérence et la fiabilité des données.</p>
</p>
    <h3>1.1 Qu'est-ce qu'une base de données relationnelle ?</h3>
    <p><p>Une base de données relationnelle est un système de gestion de bases de données (SGBD) qui organise les données en tables. Pensez à un ensemble de feuilles de calcul liées entre elles, mais avec une structure rigoureuse et des fonctionnalités avancées. Chaque table est composée de lignes et de colonnes, offrant une manière organisée de stocker des informations.</p>

<p>Chaque ligne dans une table représente un enregistrement unique, aussi appelé tuple.  Par exemple, dans une table "Produits", chaque ligne contiendrait les détails d'un produit spécifique, comme son nom, sa description et son prix.</p>

<p>Les colonnes définissent les attributs ou les champs de chaque enregistrement. Pour la table "Produits", les colonnes pourraient inclure 'id_produit', 'nom_produit', 'description', 'prix', et 'stock'.</p>

<p>Voici un exemple de création d'une table "Produits" en SQL :</p>

<pre><code  class="language-sql">
-- Create the "Products" table
CREATE TABLE Products (
    id_produit INT PRIMARY KEY,
    nom_produit VARCHAR(255),
    description TEXT,
    prix DECIMAL(10, 2),
    stock INT
);

-- Insert a new product
INSERT INTO Products (id_produit, nom_produit, description, prix, stock)
VALUES (1, 'Ordinateur Portable', 'Un ordinateur portable puissant avec 16Go de RAM', 1200.00, 10);
</code></pre>

<p>La puissance des bases de données relationnelles réside dans leur capacité à définir et à gérer des relations entre les tables.  Ces relations sont établies grâce à l'utilisation de clés primaires et de clés étrangères, permettant de connecter les informations de manière logique.</p>

<ul>
    <li>Une <strong>clé primaire</strong> est un identifiant unique pour chaque enregistrement dans une table. Dans notre exemple, <code >id_produit</code> est la clé primaire de la table <code >Products</code>, garantissant que chaque produit a un identifiant distinct.</li>
    <li>Une <strong>clé étrangère</strong> est une colonne dans une table qui fait référence à la clé primaire d'une autre table. Elle permet de créer un lien entre les deux tables.  Par exemple, si nous avions une table "Commandes", elle pourrait contenir une clé étrangère <code >id_produit</code> faisant référence à la table "Produits", nous permettant ainsi de savoir quel produit a été commandé.</li>
</ul>

<p>Voici un exemple de la création d'une table "Commandes" avec une clé étrangère pointant vers la table "Produits" :</p>

<pre><code  class="language-sql">
-- Create the "Commandes" table
CREATE TABLE Commandes (
    id_commande INT PRIMARY KEY,
    id_client INT,
    id_produit INT,
    date_commande DATE,
    quantite INT,
    FOREIGN KEY (id_produit) REFERENCES Products(id_produit)
);

-- Insert a new command related to a product
INSERT INTO Commandes (id_commande, id_client, id_produit, date_commande, quantite)
VALUES (101, 5, 1, '2024-01-15', 2);
</code></pre>

<p>L'utilisation de clés primaires et étrangères assure l'intégrité référentielle des données. Cela signifie que les relations entre les tables sont maintenues et que les données restent cohérentes. Par exemple, il serait impossible d'ajouter une commande pour un <code >id_produit</code> qui n'existe pas dans la table <code >Products</code>.  Cela évite les erreurs et garantit la fiabilité des informations.</p>

<p>En résumé, une base de données relationnelle est un moyen structuré et puissant de stocker, d'organiser et de gérer des données, permettant la création de relations complexes entre différentes entités, tout en assurant l'intégrité et la cohérence des données.</p>
</p>
    <h3>1.2 Présentation de SQL et de ses dialectes</h3>
    <p><p>SQL, ou Structured Query Language, est le langage standard pour interagir avec les bases de données relationnelles. Il permet de créer, modifier et interroger des bases de données. Bien que normalisé par l'ANSI (American National Standards Institute), différents systèmes de gestion de bases de données (SGBD) implémentent le standard SQL avec leurs propres extensions et variations, donnant naissance à des "dialectes" SQL.</p>

<p>Le SQL standard (ANSI SQL) définit un ensemble de commandes et de fonctions communes à tous les SGBD. Cela inclut les commandes de base pour la manipulation des données, telles que <code  class="language-sql">SELECT</code> (pour la sélection de données), <code  class="language-sql">INSERT</code> (pour l'ajout de données), <code  class="language-sql">UPDATE</code> (pour la modification de données) et <code  class="language-sql">DELETE</code> (pour la suppression de données). Il comprend également des commandes pour la définition de schémas de bases de données, comme <code  class="language-sql">CREATE TABLE</code>, <code  class="language-sql">ALTER TABLE</code> et <code  class="language-sql">DROP TABLE</code>.</p>

<p>Les dialectes SQL, quant à eux, ajoutent des fonctionnalités spécifiques à un SGBD particulier. Par exemple, MySQL, PostgreSQL, SQL Server et Oracle ont tous leurs propres extensions en termes de types de données, de fonctions, de procédures stockées et de syntaxes. Si vous migrez d'un SGBD à un autre, vous rencontrerez probablement des incompatibilités. Ces incompatibilités peuvent concerner la syntaxe, les fonctions disponibles, ou même le comportement de certaines opérations.</p>

<p>Considérons la fonction de concaténation de chaînes de caractères. En SQL standard, on peut utiliser l'opérateur <code  class="language-sql">||</code> (double barre verticale). Cependant, certains SGBD utilisent une fonction spécifique:</p>

<ul>
    <li>En PostgreSQL: <code  class="language-sql">SELECT 'Hello' || ' ' || 'World';</code></li>
    <li>En MySQL: <code  class="language-sql">SELECT CONCAT('Hello', ' ', 'World');</code></li>
    <li>En SQL Server: <code  class="language-sql">SELECT 'Hello' + ' ' + 'World';</code></li>
</ul>

<p>Cet exemple illustre bien la nécessité de connaître le dialecte SQL spécifique au SGBD que vous utilisez. Un code SQL valide dans un système peut générer une erreur dans un autre. De même, certaines fonctionnalités avancées peuvent être disponibles uniquement dans un dialecte spécifique.</p>

<p>Tout au long de cet article, nous nous concentrerons sur le SQL standard (ANSI SQL) afin de fournir une base solide et portable pour votre apprentissage. Il est cependant important de se rappeler que lors de l'utilisation d'un SGBD spécifique, il sera souvent nécessaire de consulter sa documentation pour connaître les particularités de son dialecte SQL. La documentation officielle est la référence la plus fiable pour comprendre les spécificités de chaque SGBD.</p>

<p>Voici un exemple de création d'une table simple en utilisant SQL standard:</p>

<pre><code  class="language-sql">
-- Create a table named 'employees'
CREATE TABLE employees (
    employee_id INT PRIMARY KEY,  -- Unique identifier for each employee
    first_name VARCHAR(50),       -- First name of the employee (up to 50 characters)
    last_name VARCHAR(50),        -- Last name of the employee (up to 50 characters)
    salary DECIMAL(10, 2)          -- Salary of the employee (up to 10 digits, 2 after the decimal)
);

-- Insert a new employee into the 'employees' table
INSERT INTO employees (employee_id, first_name, last_name, salary)
VALUES (1, 'John', 'Doe', 60000.00);

-- Select all employees from the 'employees' table
SELECT * FROM employees;
</code></pre>

<p>Ce code, conforme au SQL standard, devrait fonctionner sur la plupart des SGBD sans modification. Cependant, certaines optimisations ou syntaxes alternatives peuvent être possibles selon le dialecte utilisé. Par exemple, certains SGBD peuvent offrir des types de données plus spécifiques pour les salaires ou des méthodes d'indexation plus performantes.</p>
</p>
    <h3>1.3 Configuration d'un environnement de développement SQL</h3>
    <p><p>Pour interagir avec les bases de données relationnelles, vous aurez besoin d'un Système de Gestion de Base de Données (SGBD) installé et configuré sur votre machine. Cette section vous guide à travers l'installation d'un SGBD populaire, ainsi que la configuration d'outils pour faciliter l'interaction avec votre base de données.</p>

<p><strong>Installation et Configuration d'un SGBD (MySQL ou PostgreSQL)</strong></p>

<p>Deux SGBD open source largement utilisés sont MySQL et PostgreSQL. Le choix entre les deux dépend de vos besoins spécifiques, mais les deux sont excellents pour commencer à apprendre SQL. Nous allons brièvement aborder l'installation de chacun.</p>

<p><em>Installation de MySQL</em></p>

<p>Vous pouvez télécharger et installer MySQL à partir du site web officiel de MySQL. MySQL propose différentes éditions, dont une version communautaire gratuite, suffisante pour la plupart des besoins d'apprentissage. Suivez les instructions d'installation spécifiques à votre système d'exploitation.</p>

<p>Après l'installation, vous devrez peut-être configurer MySQL. Sur la plupart des systèmes, un script de configuration s'exécutera automatiquement. Assurez-vous de définir un mot de passe root sécurisé.</p>

<p><em>Installation de PostgreSQL</em></p>

<p>Vous pouvez télécharger et installer PostgreSQL à partir du site web officiel de PostgreSQL.  Comme MySQL, PostgreSQL est open source et gratuit. Suivez les instructions d'installation adaptées à votre système d'exploitation.</p>

<p>Après l'installation, PostgreSQL vous demandera également de configurer un mot de passe pour l'utilisateur <code  class="language-sql">postgres</code>. Notez également le port par défaut (généralement 5432) car vous en aurez besoin plus tard.</p>

<p><strong>Installation d'un client SQL</strong></p>

<p>Une fois que vous avez installé votre SGBD, vous aurez besoin d'un client SQL pour interagir avec lui. Un client SQL est une application qui vous permet d'exécuter des requêtes SQL, d'explorer les données et de gérer votre base de données. Voici quelques options populaires:</p>

<ul>
    <li>DBeaver: Un client SQL multiplateforme gratuit et open source qui prend en charge de nombreux SGBD.</li>
    <li>pgAdmin: Un outil d'administration de base de données open source pour PostgreSQL.</li>
    <li>MySQL Workbench: Un outil officiel de MySQL pour la conception, le développement et l'administration de bases de données MySQL.</li>
    <li>SQL Developer: Un IDE gratuit d'Oracle.</li>
</ul>

<p><strong>Configuration de DBeaver pour MySQL (exemple)</strong></p>

<p>Nous utiliserons DBeaver à titre d'exemple, car il est polyvalent et prend en charge à la fois MySQL et PostgreSQL. Voici les étapes générales pour configurer une connexion:</p>

<ol>
    <li>Téléchargez et installez DBeaver à partir de son site officiel.</li>
    <li>Ouvrez DBeaver.</li>
    <li>Cliquez sur l'icône "Nouvelle connexion à la base de données".</li>
    <li>Choisissez "MySQL" dans la liste des bases de données.</li>
    <li>Entrez les informations de connexion:
        <ul>
            <li><strong>Host:</strong> <code  class="language-sql">localhost</code> (si MySQL est installé sur votre machine locale)</li>
            <li><strong>Port:</strong> <code  class="language-sql">3306</code> (port par défaut de MySQL)</li>
            <li><strong>Username:</strong> <code  class="language-sql">root</code> (ou un autre utilisateur que vous avez configuré)</li>
            <li><strong>Password:</strong> Le mot de passe root que vous avez défini lors de l'installation de MySQL.</li>
        </ul>
    </li>
    <li>Cliquez sur "Test Connection" pour vérifier que la connexion fonctionne.</li>
    <li>Cliquez sur "Finish" pour enregistrer la connexion.</li>
</ol>

<p><strong>Exemple de script de test avec MySQL</strong></p>

<p>Après avoir configuré la connexion, vous pouvez exécuter une requête SQL de base pour vérifier que tout fonctionne correctement:</p>

<pre><code  class="language-sql">
-- Connect to your MySQL server using the credentials you set during installation.
-- Replace 'your_password' with the actual password.

-- Create a database for testing
CREATE DATABASE IF NOT EXISTS test_database;

-- Switch to the newly created database
USE test_database;

-- Create a simple table
CREATE TABLE IF NOT EXISTS users (
    id INT AUTO_INCREMENT PRIMARY KEY,
    username VARCHAR(50) NOT NULL,
    email VARCHAR(100)
);

-- Insert some sample data
INSERT INTO users (username, email) VALUES
('john_doe', 'john.doe@example.com'),
('jane_smith', 'jane.smith@example.com');

-- Query the table to verify the data
SELECT * FROM users;
</code></pre>

<p>Si vous voyez les données insérées dans la table <code  class="language-sql">users</code>, votre environnement SQL est correctement configuré. Vous pouvez maintenant commencer à explorer SQL!</p>

<p><strong>Tester votre installation avec Python</strong></p>

<p>Pour vérifier que votre base de données est accessible depuis Python, vous pouvez utiliser le connecteur MySQL pour Python.  Assurez-vous d'avoir installé le package <code >mysql-connector-python</code> avant d'exécuter le code suivant:</p>

<pre><code >
import mysql.connector

# Replace with your actual credentials
db_config = {
    "host": "localhost",
    "user": "root",
    "password": "your_password",  # Replace with your actual password
    "database": "test_database"
}

try:
    # Establish a connection to the MySQL database
    connection = mysql.connector.connect(**db_config)

    # Create a cursor object to execute SQL queries
    cursor = connection.cursor()

    # Execute a simple query to fetch data from the 'users' table
    cursor.execute("SELECT * FROM users")

    # Fetch all the rows returned by the query
    rows = cursor.fetchall()

    # Print the fetched data
    for row in rows:
        print(row)

except mysql.connector.Error as err:
    print(f"Error: {err}")

finally:
    # Ensure the connection is closed, whether an error occurred or not
    if connection.is_connected():
        cursor.close()
        connection.close()
        print("MySQL connection is closed")
</code></pre>

<p>Ce script Python se connecte à la base de données MySQL, exécute une requête pour sélectionner toutes les lignes de la table <code  class="language-sql">users</code>, puis affiche les résultats.  Si vous voyez les données que vous avez insérées précédemment, cela confirme que votre environnement est correctement configuré pour interagir avec MySQL depuis Python.</p>

<p><strong>Conclusion</strong></p>

<p>La mise en place d'un environnement de développement SQL est une étape essentielle pour apprendre et travailler avec les bases de données relationnelles. En installant un SGBD comme MySQL ou PostgreSQL et en utilisant un client SQL comme DBeaver, vous disposez des outils nécessaires pour explorer, manipuler et gérer vos données efficacement. N'hésitez pas à explorer les fonctionnalités offertes par ces outils pour optimiser votre flux de travail et à utiliser Python pour automatiser des tâches d'administration ou d'analyse de données.</p>
</p>
  </section>
</div>


<div class="content_box">
  <section>
    <h2 class="heading">2. Les opérations de base : SELECT, INSERT, UPDATE, DELETE</h2>
    <p><p>SQL, bien que déclaratif, s'appuie sur des opérations fondamentales pour interagir avec les données. Ces opérations, souvent désignées par l'acronyme CRUD (Create, Read, Update, Delete), permettent de manipuler les données stockées dans une base de données relationnelle. En SQL, elles se traduisent respectivement par les commandes <code  class="language-sql">INSERT</code>, <code  class="language-sql">SELECT</code>, <code  class="language-sql">UPDATE</code> et <code  class="language-sql">DELETE</code>.</p>

<p>L'opération <code  class="language-sql">SELECT</code> est utilisée pour extraire des données d'une ou plusieurs tables. Elle offre la possibilité de filtrer, trier et agréger les données en fonction de critères spécifiques. Une requête <code  class="language-sql">SELECT</code> de base doit spécifier les colonnes à récupérer et la table source.</p>

<pre><code  class="language-sql">
-- Select the name and email columns from the customers table
SELECT name, email
FROM customers;
</code></pre>

<p>Pour affiner la sélection, on peut ajouter une clause <code  class="language-sql">WHERE</code> afin de filtrer les résultats en fonction d'une condition.</p>

<pre><code  class="language-sql">
-- Select customers whose city is 'Paris'
SELECT name, email
FROM customers
WHERE city = 'Paris';
</code></pre>

<p>L'opération <code  class="language-sql">INSERT</code> permet d'ajouter de nouvelles entrées dans une table. Lors de l'insertion, il est nécessaire de spécifier le nom de la table cible, les colonnes concernées par l'insertion, et les valeurs à insérer dans ces colonnes.</p>

<pre><code  class="language-sql">
-- Insert a new customer into the customers table
INSERT INTO customers (name, email, city)
VALUES ('Jean Dupont', 'jean.dupont@example.com', 'Lyon');
</code></pre>

<p>L'opération <code  class="language-sql">UPDATE</code> permet de modifier des données existantes dans une table. L'utilisation d'une clause <code  class="language-sql">WHERE</code> est primordiale pour cibler avec précision les enregistrements à modifier et éviter ainsi toute mise à jour non désirée de données.</p>

<pre><code  class="language-sql">
-- Update the city of customer with id 1 to 'Marseille'
UPDATE customers
SET city = 'Marseille'
WHERE id = 1;
</code></pre>

<p>Enfin, l'opération <code  class="language-sql">DELETE</code> permet de supprimer des données d'une table. Tout comme pour l'opération <code  class="language-sql">UPDATE</code>, l'utilisation d'une clause <code  class="language-sql">WHERE</code> est cruciale pour éviter de supprimer accidentellement l'intégralité des données d'une table.</p>

<pre><code  class="language-sql">
-- Delete the customer with id 2
DELETE FROM customers
WHERE id = 2;
</code></pre>

<p>La maîtrise de ces quatre opérations fondamentales constitue la première étape essentielle pour interagir efficacement avec une base de données SQL. Elles forment la base de toutes les manipulations de données, des requêtes les plus simples aux procédures les plus complexes. Une compréhension approfondie et une utilisation prudente de ces commandes sont essentielles pour garantir l'intégrité et la cohérence des données.</p>
</p>
    <h3>2.1 SELECT : Récupérer des données</h3>
    <p><p>La clause <code  class="language-sql">SELECT</code> est une des instructions SQL les plus fondamentales. Elle permet de récupérer des données depuis une ou plusieurs tables d'une base de données. C'est l'élément central de toute requête SQL visant à extraire des informations spécifiques.</p>

<p>La forme la plus simple d'une requête <code  class="language-sql">SELECT</code> consiste à sélectionner toutes les colonnes d'une table. Voici un exemple :</p>

<pre><code  class="language-sql">
-- Select all columns from the 'employees' table
SELECT * FROM employees;
</code></pre>

<p>L'astérisque (<code  class="language-sql">*</code>) est un raccourci pour indiquer que toutes les colonnes doivent être sélectionnées. Cependant, il est souvent préférable de spécifier explicitement les colonnes souhaitées, surtout dans les bases de données comportant un grand nombre de colonnes, afin d'améliorer la lisibilité et les performances.  Par exemple :</p>

<pre><code  class="language-sql">
-- Select specific columns from the 'employees' table
SELECT employee_id, first_name, last_name, salary FROM employees;
</code></pre>

<p>Pour filtrer les résultats et ne récupérer que les lignes qui répondent à une condition particulière, on utilise la clause <code  class="language-sql">WHERE</code>.  Par exemple, pour sélectionner uniquement les employés dont le salaire est supérieur à 50000 :</p>

<pre><code  class="language-sql">
-- Select employees with a salary greater than 50000
SELECT employee_id, first_name, last_name, salary
FROM employees
WHERE salary > 50000;
</code></pre>

<p>Plusieurs conditions peuvent être combinées à l'aide des opérateurs logiques <code  class="language-sql">AND</code>, <code  class="language-sql">OR</code> et <code  class="language-sql">NOT</code>. Pour sélectionner les employés dont le salaire est supérieur à 50000 et qui travaillent dans le département 'Sales' :</p>

<pre><code  class="language-sql">
-- Select employees with a salary greater than 50000 and in the 'Sales' department
SELECT employee_id, first_name, last_name, salary, department
FROM employees
WHERE salary > 50000 AND department = 'Sales';
</code></pre>

<p>L'ordre dans lequel les résultats sont présentés peut être important. La clause <code  class="language-sql">ORDER BY</code> permet de trier les résultats selon une ou plusieurs colonnes. Par défaut, le tri est effectué dans l'ordre ascendant (<code  class="language-sql">ASC</code>). Pour un tri descendant, le mot-clé <code  class="language-sql">DESC</code> est utilisé. Par exemple, pour trier les employés par salaire, du plus élevé au moins élevé :</p>

<pre><code  class="language-sql">
-- Select employees and order them by salary in descending order
SELECT employee_id, first_name, last_name, salary
FROM employees
ORDER BY salary DESC;
</code></pre>

<p>Il est possible de combiner <code  class="language-sql">WHERE</code> et <code  class="language-sql">ORDER BY</code> pour obtenir des résultats à la fois filtrés et triés. Par exemple, pour sélectionner les employés du département 'Marketing' et les trier par nom de famille :</p>

<pre><code  class="language-sql">
-- Select employees from the 'Marketing' department and order them by last name
SELECT employee_id, first_name, last_name, salary
FROM employees
WHERE department = 'Marketing'
ORDER BY last_name;
</code></pre>

<p>En résumé, la clause <code  class="language-sql">SELECT</code>, lorsqu'elle est combinée avec <code  class="language-sql">WHERE</code> pour le filtrage et <code  class="language-sql">ORDER BY</code> pour le tri, offre une flexibilité considérable pour extraire et organiser les données souhaitées d'une base de données, permettant ainsi de répondre à des besoins d'analyse et de reporting complexes.</p>
</p>
    <h3>2.2 INSERT : Ajouter de nouvelles données</h3>
    <p><p>La clause <code  class="language-sql">INSERT</code> en SQL est utilisée pour ajouter de nouvelles lignes (ou enregistrements) dans une table. Elle offre deux manières principales d'insérer des données : insérer une seule ligne de données ou insérer plusieurs lignes simultanément.</p>

<p><strong>Insertion d'une seule ligne</strong></p>

<p>La syntaxe de base pour insérer une seule ligne est la suivante :</p>

<pre><code  class="language-sql">
INSERT INTO table_name (column1, column2, column3, ...)
VALUES (value1, value2, value3, ...);

-- Example: Inserting a new employee into the 'employees' table
INSERT INTO employees (employee_id, first_name, last_name, department, salary)
VALUES (1001, 'John', 'Doe', 'Sales', 50000);
</code></pre>

<p>Dans cet exemple :</p>
<ul>
    <li><code  class="language-sql">table_name</code> est le nom de la table dans laquelle vous souhaitez insérer les données.</li>
    <li><code  class="language-sql">(column1, column2, column3, ...)</code> est la liste des colonnes dans lesquelles vous insérez des valeurs. L'ordre est important et doit correspondre à l'ordre des valeurs.</li>
    <li><code  class="language-sql">(value1, value2, value3, ...)</code> est la liste des valeurs correspondantes à chaque colonne. Les valeurs doivent correspondre au type de données défini pour chaque colonne.</li>
</ul>

<p>Si vous souhaitez insérer des valeurs dans toutes les colonnes de la table, vous pouvez omettre la liste des colonnes. Dans ce cas, assurez-vous que l'ordre des valeurs correspond à l'ordre des colonnes dans la table :</p>

<pre><code  class="language-sql">
INSERT INTO table_name
VALUES (value1, value2, value3, ...);

-- Example: Inserting data into all columns of the 'products' table
INSERT INTO products
VALUES (1, 'Laptop', 1200.00, 50);
</code></pre>

<p>Il est crucial que l'ordre et le nombre de valeurs correspondent à l'ordre et au nombre de colonnes de la table. Dans le cas contraire, une erreur sera générée. De plus, le type de donnée de chaque valeur doit correspondre au type de donnée de la colonne correspondante.</p>

<p><strong>Insertion de plusieurs lignes</strong></p>

<p>Pour insérer plusieurs lignes en une seule requête, utilisez la syntaxe suivante.  Cette approche est particulièrement utile pour initialiser une table ou importer des données en masse :</p>

<pre><code  class="language-sql">
INSERT INTO table_name (column1, column2, column3, ...)
VALUES
    (value1_1, value1_2, value1_3, ...),
    (value2_1, value2_2, value2_3, ...),
    (value3_1, value3_2, value3_3, ...),
    ...;

-- Example: Inserting multiple customers into the 'customers' table
INSERT INTO customers (customer_id, first_name, last_name, city)
VALUES
    (1, 'Alice', 'Smith', 'New York'),
    (2, 'Bob', 'Johnson', 'Los Angeles'),
    (3, 'Charlie', 'Brown', 'Chicago');
</code></pre>

<p>Cette méthode est plus efficace que d'exécuter plusieurs instructions <code  class="language-sql">INSERT</code> individuelles, car elle réduit la surcharge liée à la communication avec la base de données. Chaque ensemble de valeurs entre parenthèses représente une nouvelle ligne à insérer. Veillez à ce que chaque ensemble de valeurs respecte l'ordre et les types de données des colonnes spécifiées.</p>

<p>En résumé, la clause <code  class="language-sql">INSERT</code> est essentielle pour peupler vos tables de données. Que ce soit pour ajouter un enregistrement unique, initialiser une table ou importer des données en masse, maîtriser ces syntaxes est fondamental pour interagir efficacement avec votre base de données SQL. N'oubliez pas de vérifier les types de données et l'ordre des colonnes pour éviter les erreurs.</p>
</p>
    <h3>2.3 UPDATE : Modifier des données existantes</h3>
    <p><p>La clause <code  class="language-sql">UPDATE</code> permet de modifier les données existantes dans une table. C'est une opération essentielle pour maintenir l'intégrité et la pertinence des données. La syntaxe de base est la suivante :</p>
<pre><code  class="language-sql">
UPDATE table_name
SET column1 = value1, column2 = value2, ...
WHERE condition;
</code></pre>
<p>Il est <strong>crucial</strong> d'utiliser la clause <code  class="language-sql">WHERE</code> avec <code  class="language-sql">UPDATE</code>. Sans elle, <em>toutes</em> les lignes de la table seraient mises à jour, ce qui est rarement l'effet désiré et peut entraîner des pertes de données importantes.</p>
<p>Voici un exemple concret. Imaginons une table nommée "Employees" avec les colonnes "id_employee", "name", "salary" et "position". Nous souhaitons augmenter le salaire de tous les employés occupant le poste de "Developer" de 10%.</p>
<pre><code  class="language-sql">
-- Update the salary of all 'Developer' employees by 10%
UPDATE Employees
SET salary = salary * 1.10
WHERE position = 'Developer';

-- Verify the update
SELECT * FROM Employees WHERE position = 'Developer';
</code></pre>
<p>Dans cet exemple, la clause <code  class="language-sql">WHERE position = 'Developer'</code> garantit que seules les lignes correspondant aux développeurs sont affectées. L'expression <code  class="language-sql">salary = salary * 1.10</code> recalcule le salaire en augmentant sa valeur de 10%.</p>
<p>On peut également mettre à jour plusieurs colonnes simultanément :</p>
<pre><code  class="language-sql">
-- Promote an employee with id 5 to 'Senior Developer' and give him a 15% raise
UPDATE Employees
SET position = 'Senior Developer', salary = salary * 1.15
WHERE id_employee = 5;

-- Verify the update
SELECT * FROM Employees WHERE id_employee = 5;
</code></pre>
<p>Ici, le poste et le salaire d'un employé spécifique (identifié par son <code  class="language-sql">id_employee</code>) sont modifiés en une seule requête.  L'ordre des affectations dans la clause <code  class="language-sql">SET</code> n'a pas d'importance.</p>
<p>Enfin, la valeur utilisée pour la mise à jour peut provenir d'une autre table via une sous-requête :</p>
<pre><code  class="language-sql">
-- Example: Give all employees in the 'Marketing' department the average salary of the 'Sales' department
UPDATE Employees
SET salary = (SELECT AVG(salary) FROM Employees WHERE position = 'Sales')
WHERE position = 'Marketing';

-- Verify the update
SELECT position, salary FROM Employees WHERE position = 'Marketing';
</code></pre>
<p>Dans cet exemple avancé, le salaire de chaque employé du département 'Marketing' est mis à jour avec le salaire moyen des employés du département 'Sales'. Il est important de s'assurer que la sous-requête renvoie une valeur unique, sinon l'opération <code  class="language-sql">UPDATE</code> échouera. De plus, si la sous-requête ne retourne aucune ligne, la valeur <code  class="language-sql">NULL</code> sera affectée, ce qui pourrait ne pas être le comportement souhaité. Pensez à gérer ces cas limites.</p>
<p>En conclusion, la clause <code  class="language-sql">UPDATE</code> est un outil puissant pour modifier les données existantes. Son utilisation prudente, notamment avec la clause <code  class="language-sql">WHERE</code>, est essentielle pour garantir l'intégrité de la base de données. N'oubliez pas de toujours tester vos requêtes <code  class="language-sql">UPDATE</code> sur un environnement de développement avant de les appliquer en production.</p>
</p>
    <h3>2.4 DELETE : Supprimer des données</h3>
    <p><p>La clause <code  class="language-sql">DELETE</code> est utilisée pour supprimer des lignes existantes dans une table. Sa syntaxe de base est la suivante:</p>
<pre><code  class="language-sql">
DELETE FROM table_name
WHERE condition;
</code></pre>
<p>Ici, <code  class="language-sql">table_name</code> est le nom de la table à partir de laquelle vous souhaitez supprimer des lignes, et <code  class="language-sql">condition</code> est une expression conditionnelle qui spécifie quelles lignes doivent être supprimées. Il est <strong>crucial</strong> d'inclure une clause <code  class="language-sql">WHERE</code>. Sans elle, <strong>toutes</strong> les lignes de la table seront supprimées, ce qui équivaut à vider la table.</p>
<p>Par exemple, imaginons une table nommée <code  class="language-sql">customers</code> avec des colonnes comme <code  class="language-sql">customer_id</code>, <code  class="language-sql">name</code> et <code  class="language-sql">city</code>. Pour supprimer le client avec un <code  class="language-sql">customer_id</code> égal à 3, vous utiliseriez la requête suivante:</p>
<pre><code  class="language-sql">
DELETE FROM customers
WHERE customer_id = 3;

-- This query will delete the row where customer_id is equal to 3
</code></pre>
<p>Il est également possible de supprimer des lignes en se basant sur des critères plus complexes, en utilisant d'autres opérateurs comme <code  class="language-sql">AND</code>, <code  class="language-sql">OR</code>, <code  class="language-sql">IN</code>, etc. Par exemple, pour supprimer tous les clients résidant à 'Lyon' et dont le nom commence par 'A', vous pouvez utiliser :</p>
<pre><code  class="language-sql">
DELETE FROM customers
WHERE city = 'Lyon' AND name LIKE 'A%';

-- This query will delete all rows where the city is 'Lyon' and the name starts with 'A'
</code></pre>
<p>Il est possible de supprimer plusieurs lignes en utilisant la clause <code  class="language-sql">IN</code> :</p>
<pre><code  class="language-sql">
DELETE FROM customers
WHERE customer_id IN (1, 2, 3);

-- This query will delete all rows where customer_id is 1, 2, or 3
</code></pre>
<p>Attention, l'utilisation de <code  class="language-sql">DELETE</code> est une opération définitive. Une fois les données supprimées, il est généralement difficile, voire impossible, de les récupérer. Il est donc fortement recommandé de faire une sauvegarde de votre table avant d'effectuer une opération de suppression importante, ou d'utiliser des transactions pour pouvoir revenir en arrière en cas de problème. Voici un exemple d'utilisation d'une transaction :</p>
<pre><code  class="language-sql">
START TRANSACTION;

DELETE FROM customers
WHERE city = 'Lyon';

-- Check if the deletion was correct

ROLLBACK; -- If not correct, rollback the transaction

-- Or, if correct, commit the transaction
-- COMMIT;
</code></pre>
<p>En résumé, la clause <code  class="language-sql">DELETE</code> est un outil puissant pour la gestion des données, mais elle doit être utilisée avec précaution. Toujours vérifier la clause <code  class="language-sql">WHERE</code> avant d'exécuter la requête pour éviter des suppressions accidentelles. Envisager l'utilisation de transactions pour plus de sécurité.</p>
</p>
  </section>
</div>


<div class="content_box">
  <section>
    <h2 class="heading">3. Filtrage et tri des données : WHERE, ORDER BY, LIMIT</h2>
    <p><p>Le filtrage et le tri des données sont des opérations essentielles en SQL. Ils permettent de sélectionner les données pertinentes et de les présenter dans un ordre logique. Les clauses <code  class="language-sql">WHERE</code>, <code  class="language-sql">ORDER BY</code> et <code  class="language-sql">LIMIT</code> sont les outils de base pour réaliser ces opérations.</p>

<p>La clause <code  class="language-sql">WHERE</code> permet de filtrer les lignes d'une table en fonction d'une ou plusieurs conditions. Seules les lignes qui satisfont ces conditions seront incluses dans le résultat. On peut combiner plusieurs conditions avec les opérateurs logiques <code  class="language-sql">AND</code>, <code  class="language-sql">OR</code> et <code  class="language-sql">NOT</code>. Il est également possible d'utiliser des opérateurs de comparaison comme <code  class="language-sql">=</code>, <code  class="language-sql">!=</code>, <code  class="language-sql">></code>, <code  class="language-sql"><</code>, <code  class="language-sql">>=</code>, <code  class="language-sql"><=</code>, <code  class="language-sql">LIKE</code>, <code  class="language-sql">IN</code> et <code  class="language-sql">BETWEEN</code>.</p>

<pre><code  class="language-sql">
-- Select employees with a salary greater than 50000
SELECT employee_id, first_name, last_name, salary
FROM employees
WHERE salary > 50000;

-- Select employees who are 'Developer' or 'Analyst'
SELECT employee_id, first_name, last_name, job_title
FROM employees
WHERE job_title IN ('Developer', 'Analyst');

-- Select products with a name containing 'Keyboard'
SELECT product_id, product_name
FROM products
WHERE product_name LIKE '%Keyboard%';
</code></pre>

<p>La clause <code  class="language-sql">ORDER BY</code> permet de trier les résultats d'une requête. On peut trier selon une ou plusieurs colonnes, et dans l'ordre croissant (<code  class="language-sql">ASC</code>) ou décroissant (<code  class="language-sql">DESC</code>). Par défaut, le tri est croissant.</p>

<pre><code  class="language-sql">
-- Select and order customers by city, then by last name
SELECT customer_id, first_name, last_name, city
FROM customers
ORDER BY city ASC, last_name ASC;

-- Select products and order them by price in descending order
SELECT product_id, product_name, price
FROM products
ORDER BY price DESC;
</code></pre>

<p>La clause <code  class="language-sql">LIMIT</code> permet de limiter le nombre de lignes retournées par une requête. Elle est souvent utilisée pour afficher les "top N" résultats ou pour implémenter une pagination. Elle peut être combinée avec <code  class="language-sql">ORDER BY</code> pour obtenir les N premiers éléments triés.  La clause <code  class="language-sql">OFFSET</code>, utilisée conjointement avec <code  class="language-sql">LIMIT</code>, permet de spécifier à partir de quelle ligne commencer la sélection.</p>

<pre><code  class="language-sql">
-- Select the top 5 most expensive products
SELECT product_id, product_name, price
FROM products
ORDER BY price DESC
LIMIT 5;

-- Select 10 customers starting from the 21st customer (for pagination)
SELECT customer_id, first_name, last_name
FROM customers
LIMIT 10 OFFSET 20;
</code></pre>

<p>Ces trois clauses peuvent être combinées pour effectuer des opérations de filtrage et de tri complexes. L'ordre d'exécution des clauses est généralement <code  class="language-sql">WHERE</code>, puis <code  class="language-sql">ORDER BY</code> et enfin <code  class="language-sql">LIMIT</code>.</p>

<pre><code  class="language-sql">
-- Select the 3 most recent orders for customers in 'Paris'
SELECT order_id, customer_id, order_date
FROM orders
WHERE customer_id IN (SELECT customer_id FROM customers WHERE city = 'Paris')
ORDER BY order_date DESC
LIMIT 3;
</code></pre>

<p>Maîtriser ces clauses est fondamental pour extraire efficacement l'information pertinente de vos bases de données. L'utilisation conjointe de <code  class="language-sql">WHERE</code>, <code  class="language-sql">ORDER BY</code> et <code  class="language-sql">LIMIT</code> permet d'affiner vos requêtes et d'obtenir des résultats précis et pertinents.</p>
</p>
    <h3>3.1 WHERE : Filtrer les résultats</h3>
    <p><p>La clause <code  class="language-sql">WHERE</code> est un outil puissant en SQL pour filtrer les résultats d'une requête <code  class="language-sql">SELECT</code>. Elle permet de spécifier une ou plusieurs conditions qu'une ligne doit satisfaire pour être incluse dans le jeu de résultats.  Elle agit comme un filtre, ne laissant passer que les données qui correspondent à vos critères, ce qui optimise vos requêtes et améliore la performance.</p>

<p>La syntaxe de base est la suivante:</p>
<pre><code  class="language-sql">
SELECT column1, column2
FROM table_name
WHERE condition;
</code></pre>
<p>La <code  class="language-sql">condition</code> peut être une expression booléenne utilisant des opérateurs de comparaison, des opérateurs logiques et d'autres fonctions SQL pour définir des critères de filtrage complexes.</p>

<p>Les opérateurs de comparaison les plus courants sont:</p>
<ul>
    <li><code  class="language-sql">=</code> (égal à)</li>
    <li><code  class="language-sql">!=</code> ou <code  class="language-sql"><></code> (différent de)</li>
    <li><code  class="language-sql">></code> (supérieur à)</li>
    <li><code  class="language-sql"><</code> (inférieur à)</li>
    <li><code  class="language-sql">>=</code> (supérieur ou égal à)</li>
    <li><code  class="language-sql"><=</code> (inférieur ou égal à)</li>
</ul>

<p>Les opérateurs logiques permettent de combiner plusieurs conditions:</p>
<ul>
    <li><code  class="language-sql">AND</code> (et) : les deux conditions doivent être vraies pour qu'une ligne soit incluse.</li>
    <li><code  class="language-sql">OR</code> (ou) : au moins une des conditions doit être vraie.</li>
    <li><code  class="language-sql">NOT</code> (non) : inverse la condition, sélectionnant les lignes qui ne correspondent pas à la condition spécifiée.</li>
</ul>

<p>Voici quelques exemples concrets. Supposons une table nommée <code  class="language-sql">customers</code> avec les colonnes <code  class="language-sql">id</code>, <code  class="language-sql">name</code>, <code  class="language-sql">age</code>, <code  class="language-sql">city</code> et <code  class="language-sql">country</code>.</p>

<p>Pour sélectionner tous les clients de la ville de Paris:</p>
<pre><code  class="language-sql">
SELECT id, name, age
FROM customers
WHERE city = 'Paris';
</code></pre>

<p>Pour sélectionner les clients qui ont plus de 30 ans:</p>
<pre><code  class="language-sql">
SELECT id, name, age
FROM customers
WHERE age > 30;
</code></pre>

<p>Pour sélectionner les clients qui ont entre 25 et 35 ans (inclus):</p>
<pre><code  class="language-sql">
SELECT id, name, age
FROM customers
WHERE age >= 25 AND age <= 35;
</code></pre>

<p>Pour sélectionner les clients qui ne sont pas de Lyon:</p>
<pre><code  class="language-sql">
SELECT id, name, age
FROM customers
WHERE city != 'Lyon';
</code></pre>

<p>Il est possible d'utiliser <code  class="language-sql">NOT</code> pour obtenir le même résultat:</p>
<pre><code  class="language-sql">
SELECT id, name, age
FROM customers
WHERE NOT city = 'Lyon';
</code></pre>

<p>Pour sélectionner les clients de Paris ou de Marseille:</p>
<pre><code  class="language-sql">
SELECT id, name, age
FROM customers
WHERE city = 'Paris' OR city = 'Marseille';
</code></pre>

<p>Pour sélectionner les clients français qui ont plus de 25 ans:</p>
<pre><code  class="language-sql">
SELECT id, name, age, country
FROM customers
WHERE country = 'France' AND age > 25;
</code></pre>

<p>La clause <code  class="language-sql">WHERE</code> est un outil indispensable pour extraire précisément les informations nécessaires de votre base de données. En combinant les opérateurs de comparaison et logiques, vous pouvez créer des filtres puissants et adaptés à vos besoins spécifiques. Elle contribue à rendre vos requêtes SQL plus efficaces et à améliorer la performance globale de vos applications.</p>
</p>
    <h3>3.2 ORDER BY : Trier les résultats</h3>
    <p><p>La clause <code  class="language-sql">ORDER BY</code> permet de trier les résultats d'une requête SQL. Par défaut, le tri s'effectue par ordre croissant (ASC), mais il est possible de spécifier un tri par ordre décroissant (DESC).</p>

<p>Pour trier les résultats selon une seule colonne, il suffit d'indiquer le nom de cette colonne après le mot-clé <code  class="language-sql">ORDER BY</code>. Par exemple, pour obtenir la liste des clients triés par ordre alphabétique de nom de famille, on peut utiliser la requête suivante :</p>

<pre><code  class="language-sql">
SELECT nom, prenom
FROM clients
ORDER BY nom;
-- This query selects the 'nom' (last name) and 'prenom' (first name) columns from the 'clients' table
-- and orders the result set alphabetically by the 'nom' column in ascending order (default).
</code></pre>

<p>Il est également possible de trier les résultats par ordre décroissant en ajoutant le mot-clé <code  class="language-sql">DESC</code> après le nom de la colonne. Par exemple, pour obtenir la liste des produits triés du plus cher au moins cher, on peut utiliser la requête suivante :</p>

<pre><code  class="language-sql">
SELECT nom_produit, prix
FROM produits
ORDER BY prix DESC;
-- This query selects the 'nom_produit' (product name) and 'prix' (price) columns from the 'produits' table
-- and orders the result set by the 'prix' column in descending order, showing the most expensive products first.
</code></pre>

<p>La clause <code  class="language-sql">ORDER BY</code> peut également être utilisée pour trier les résultats selon plusieurs colonnes. Dans ce cas, l'ordre de priorité des colonnes est déterminé par l'ordre dans lequel elles sont spécifiées après le mot-clé <code  class="language-sql">ORDER BY</code>. Par exemple, pour trier une table d'employés d'abord par département, puis par salaire (du plus élevé au plus bas) au sein de chaque département, on écrirait :</p>

<pre><code  class="language-sql">
SELECT nom, prenom, departement, salaire
FROM employes
ORDER BY departement ASC, salaire DESC;
-- This query selects employee information (name, first name, department, salary) from the 'employes' table.
-- It first sorts the results alphabetically by department (ascending order),
-- and then, within each department, it sorts the employees by salary in descending order (highest salary first).
</code></pre>

<p>L'ordre de tri est important. Dans l'exemple ci-dessus, tous les employés sont d'abord regroupés par département, puis triés par salaire à l'intérieur de chaque département.</p>

<p>Il est également possible de trier sur une colonne qui n'est pas sélectionnée dans la clause <code  class="language-sql">SELECT</code>. Cela peut être utile pour organiser les résultats sans nécessairement afficher la colonne de tri.</p>

<pre><code  class="language-sql">
SELECT nom, prenom
FROM employes
ORDER BY salaire DESC;
-- This query selects the 'nom' (last name) and 'prenom' (first name) columns from the 'employes' table
-- but orders the result set by the 'salaire' (salary) column in descending order, even though 'salaire' is not displayed.
</code></pre>

<p>En résumé, <code  class="language-sql">ORDER BY</code> est un outil puissant pour organiser les résultats de vos requêtes. Maîtriser son utilisation, avec <code  class="language-sql">ASC</code> et <code  class="language-sql">DESC</code>, est essentiel pour présenter des données claires et pertinentes.</p>
</p>
    <h3>3.3 LIMIT : Limiter le nombre de résultats</h3>
    <p><p>La clause <code  class="language-sql">LIMIT</code> en SQL permet de restreindre le nombre de lignes retournées par une requête <code  class="language-sql">SELECT</code>. C'est un outil puissant pour gérer de grands ensembles de données et optimiser les performances des requêtes, surtout lorsqu'on ne souhaite examiner qu'un sous-ensemble des résultats.</p>

<p>La syntaxe de base est simple : ajoutez <code  class="language-sql">LIMIT nombre</code> à la fin de votre requête <code  class="language-sql">SELECT</code>, où <code  class="language-sql">nombre</code> représente le nombre maximal de lignes que vous souhaitez récupérer. Par exemple, pour sélectionner les 5 premiers enregistrements de la table <code  class="language-sql">customers</code>, vous utiliserez :</p>

<pre><code  class="language-sql">
-- Retrieve the first 5 customers from the 'customers' table
SELECT * FROM customers LIMIT 5;
</code></pre>

<p>La clause <code  class="language-sql">LIMIT</code> est souvent combinée avec <code  class="language-sql">ORDER BY</code> pour extraire les "N premiers" enregistrements selon un critère de tri spécifique. Imaginez que vous vouliez identifier les 3 produits les plus chers de votre catalogue :</p>

<pre><code  class="language-sql">
-- Retrieve the 3 most expensive products from the 'products' table
SELECT * FROM products ORDER BY price DESC LIMIT 3;
</code></pre>

<p>Dans cet exemple, <code  class="language-sql">ORDER BY price DESC</code> trie la table <code  class="language-sql">products</code> par la colonne <code  class="language-sql">price</code> en ordre décroissant (du plus cher au moins cher), et <code  class="language-sql">LIMIT 3</code> sélectionne uniquement les trois premières lignes de ce résultat trié.</p>

<p>SQL offre également la possibilité de spécifier un offset, qui indique le point de départ de la sélection des lignes. Pour cela, on utilise la syntaxe <code  class="language-sql">LIMIT offset, nombre</code>. L'argument <code  class="language-sql">offset</code> définit le nombre de lignes à ignorer avant de commencer à retourner les résultats, tandis que <code  class="language-sql">nombre</code> détermine le nombre de lignes à retourner à partir de l'offset spécifié. Il est important de noter que l'index du premier enregistrement est 0.</p>

<p>Par exemple, pour extraire les produits de la 6ème à la 10ème position (incluses) d'une table triée par nom, vous écririez :</p>

<pre><code  class="language-sql">
-- Retrieve products 6 to 10 (inclusive) from the 'products' table, ordered by name
SELECT * FROM products ORDER BY name LIMIT 5, 5;
</code></pre>

<p>Ici, <code  class="language-sql">LIMIT 5, 5</code> indique à SQL d'ignorer les 5 premières lignes (offset de 5) et de retourner les 5 lignes suivantes.</p>

<p>En conclusion, <code  class="language-sql">LIMIT</code> est un outil indispensable pour contrôler la taille des ensembles de résultats, améliorer les performances des requêtes et simplifier la gestion des données en SQL.</p>
</p>
  </section>
</div>


<div class="content_box">
  <section>
    <h2 class="heading">4. Fonctions d'agrégation et GROUP BY</h2>
    <p><p>Les fonctions d'agrégation en SQL permettent de calculer des valeurs synthétiques à partir de plusieurs lignes. Elles sont fréquemment utilisées avec la clause <code  class="language-sql">GROUP BY</code> pour regrouper les lignes en fonction de certaines colonnes, puis appliquer ces fonctions à chaque groupe ainsi formé.</p>

<p>Voici les fonctions d'agrégation les plus courantes :</p>
<ul>
    <li><code  class="language-sql">COUNT()</code>: Compte le nombre de lignes (ou le nombre de valeurs non nulles dans une colonne).</li>
    <li><code  class="language-sql">SUM()</code>: Calcule la somme des valeurs.</li>
    <li><code  class="language-sql">AVG()</code>: Calcule la moyenne des valeurs.</li>
    <li><code  class="language-sql">MIN()</code>: Trouve la valeur minimale.</li>
    <li><code  class="language-sql">MAX()</code>: Trouve la valeur maximale.</li>
</ul>

<p>Illustrons cela avec une table nommée <code  class="language-sql">ventes</code> qui contient les colonnes <code  class="language-sql">id_produit</code>, <code  class="language-sql">date_vente</code> et <code  class="language-sql">montant</code>.</p>

<pre><code  class="language-sql">
-- Sample data for the 'ventes' table
CREATE TABLE ventes (
    id_produit INT,
    date_vente DATE,
    montant DECIMAL(10, 2)
);

INSERT INTO ventes (id_produit, date_vente, montant) VALUES
(1, '2023-01-01', 100.00),
(2, '2023-01-01', 150.00),
(1, '2023-01-02', 200.00),
(2, '2023-01-02', 120.00),
(3, '2023-01-02', 80.00),
(1, '2023-01-03', 250.00);
</code></pre>

<p>Pour calculer le nombre total de ventes, on utilise la fonction <code  class="language-sql">COUNT(*)</code> :</p>

<pre><code  class="language-sql">
SELECT COUNT(*) AS nombre_total_ventes
FROM ventes;
</code></pre>

<p>Cette requête renverra le nombre total de lignes dans la table <code  class="language-sql">ventes</code>, représentant ainsi le nombre total de ventes.</p>

<p>Pour calculer le montant total des ventes, on utilise la fonction <code  class="language-sql">SUM()</code> :</p>

<pre><code  class="language-sql">
SELECT SUM(montant) AS montant_total_ventes
FROM ventes;
</code></pre>

<p>Cette requête additionne toutes les valeurs de la colonne <code  class="language-sql">montant</code> et renvoie le montant total des ventes.</p>

<p>La clause <code  class="language-sql">GROUP BY</code> permet de regrouper les lignes en fonction d'une ou plusieurs colonnes. Par exemple, pour calculer le montant total des ventes par produit, on utilise la requête suivante :</p>

<pre><code  class="language-sql">
SELECT id_produit, SUM(montant) AS montant_total_ventes
FROM ventes
GROUP BY id_produit;
</code></pre>

<p>Ici, les lignes sont regroupées par <code  class="language-sql">id_produit</code>, et la fonction <code  class="language-sql">SUM(montant)</code> est appliquée à chaque groupe. Le résultat affichera chaque <code  class="language-sql">id_produit</code> et le montant total des ventes correspondant à ce produit.</p>

<p>Il est possible d'utiliser plusieurs colonnes dans la clause <code  class="language-sql">GROUP BY</code>. Par exemple, pour calculer le montant total des ventes par produit et par date, on utilise la requête suivante :</p>

<pre><code  class="language-sql">
SELECT id_produit, date_vente, SUM(montant) AS montant_total_ventes
FROM ventes
GROUP BY id_produit, date_vente;
</code></pre>

<p>Cette requête regroupe les ventes à la fois par <code  class="language-sql">id_produit</code> et <code  class="language-sql">date_vente</code>, permettant d'obtenir le montant total des ventes pour chaque produit à chaque date.</p>

<p>Pour filtrer les groupes après l'agrégation, on utilise la clause <code  class="language-sql">HAVING</code>. Par exemple, pour afficher uniquement les produits dont le montant total des ventes est supérieur à 300, on utilise la requête suivante :</p>

<pre><code  class="language-sql">
SELECT id_produit, SUM(montant) AS montant_total_ventes
FROM ventes
GROUP BY id_produit
HAVING SUM(montant) > 300;
</code></pre>

<p>La clause <code  class="language-sql">HAVING</code> filtre les résultats de l'agrégation, ne conservant que les groupes dont la somme des montants est supérieure à 300.</p>

<p>En résumé, les fonctions d'agrégation et la clause <code  class="language-sql">GROUP BY</code> sont des outils essentiels pour analyser et synthétiser les données en SQL. Elles permettent de poser des questions complexes sur les données, d'agréger des informations pertinentes et d'obtenir des aperçus précieux pour la prise de décision.</p>
</p>
    <h3>4.1 Fonctions d'agrégation : COUNT, SUM, AVG, MIN, MAX</h3>
    <p><p>Les fonctions d'agrégation en SQL permettent d'effectuer des calculs récapitulatifs sur des ensembles de données, renvoyant une seule valeur à partir de plusieurs lignes. Elles sont fréquemment utilisées avec la clause <code  class="language-sql">GROUP BY</code> pour générer des statistiques par groupe. Découvrons ensemble les fonctions d'agrégation les plus courantes : <code  class="language-sql">COUNT</code>, <code  class="language-sql">SUM</code>, <code  class="language-sql">AVG</code>, <code  class="language-sql">MIN</code> et <code  class="language-sql">MAX</code>.</p>

<p>La fonction <code  class="language-sql">COUNT</code> est utilisée pour compter le nombre de lignes dans une table ou le nombre de valeurs non nulles dans une colonne.  Par exemple, pour déterminer le nombre total de clients, on peut utiliser la requête suivante :</p>

<pre><code  class="language-sql">
-- Counts the total number of customers in the 'Customers' table.
SELECT COUNT(*) AS TotalCustomers
FROM Customers;
</code></pre>

<p>La fonction <code  class="language-sql">SUM</code> calcule la somme de toutes les valeurs d'une colonne numérique.  Imaginons que l'on souhaite obtenir le montant total de toutes les commandes passées :</p>

<pre><code  class="language-sql">
-- Calculates the sum of all order amounts in the 'Orders' table.
SELECT SUM(OrderAmount) AS TotalOrderAmount
FROM Orders;
</code></pre>

<p>La fonction <code  class="language-sql">AVG</code> permet de calculer la moyenne arithmétique des valeurs d'une colonne numérique.  Illustrons cela en calculant le prix moyen des produits disponibles :</p>

<pre><code  class="language-sql">
-- Calculates the average price of products in the 'Products' table.
SELECT AVG(Price) AS AveragePrice
FROM Products;
</code></pre>

<p>Les fonctions <code  class="language-sql">MIN</code> et <code  class="language-sql">MAX</code> sont utilisées respectivement pour identifier la valeur minimale et la valeur maximale dans une colonne donnée.  Prenons l'exemple de la recherche de la date de la première et de la dernière commande :</p>

<pre><code  class="language-sql">
-- Finds the earliest and latest order dates in the 'Orders' table.
SELECT MIN(OrderDate) AS EarliestOrderDate,
       MAX(OrderDate) AS LatestOrderDate
FROM Orders;
</code></pre>

<p>Ces fonctions d'agrégation démontrent toute leur puissance lorsqu'elles sont combinées avec la clause <code  class="language-sql">GROUP BY</code>.  Cette combinaison permet d'obtenir des statistiques affinées pour différents groupes de données, une technique que nous explorerons plus en détail dans la section suivante. Par exemple, il est possible de connaître le montant total des ventes par pays, le nombre de clients par ville, ou encore le produit le plus vendu par catégorie.</p>
</p>
    <h3>4.2 GROUP BY : Grouper les résultats</h3>
    <p><p>La clause <code  class="language-sql">GROUP BY</code> est un outil puissant en SQL qui permet de regrouper les lignes d'une table partageant les mêmes valeurs dans une ou plusieurs colonnes. Son principal intérêt réside dans sa capacité à combiner ce regroupement avec des fonctions d'agrégation, offrant ainsi la possibilité d'analyser et de synthétiser des données par catégories.</p>

<p>Imaginez une table nommée "Commandes" contenant des informations sur les commandes de produits, notamment l'identifiant du client (<code  class="language-sql">client_id</code>), le produit commandé (<code  class="language-sql">produit</code>) et la quantité commandée (<code  class="language-sql">quantite</code>). Pour déterminer la quantité totale de chaque produit commandée par chaque client, il faut regrouper les lignes par client et par produit.</p>

<p>La syntaxe générale de <code  class="language-sql">GROUP BY</code> est la suivante :</p>
<pre><code  class="language-sql">
SELECT column1, column2, aggregate_function(column3)
FROM table_name
WHERE condition
GROUP BY column1, column2
ORDER BY column1, column2;
</code></pre>
<p>Dans cet exemple, les lignes sont regroupées en fonction des valeurs des <code  class="language-sql">column1</code> et <code  class="language-sql">column2</code>. La <code  class="language-sql">aggregate_function()</code> est ensuite appliquée à chaque groupe.</p>

<p>Voici un exemple concret pour calculer la quantité totale commandée par client et par produit :</p>
<pre><code  class="language-sql">
-- Calculate the total quantity of each product ordered by each client
SELECT client_id, produit, SUM(quantite) AS total_quantite
FROM Commandes
GROUP BY client_id, produit
ORDER BY client_id, total_quantite DESC;
</code></pre>
<p>Dans cette requête, on utilise <code  class="language-sql">SUM(quantite)</code> pour calculer la somme des quantités pour chaque groupe défini par la combinaison unique de <code  class="language-sql">client_id</code> et <code  class="language-sql">produit</code>. Le résultat est trié par <code  class="language-sql">client_id</code> et ensuite par <code  class="language-sql">total_quantite</code> de manière décroissante. L'alias <code  class="language-sql">total_quantite</code> est utilisé pour donner un nom plus clair à la colonne résultant de l'agrégation.</p>

<p>Il est important de noter que toutes les colonnes listées dans la clause <code  class="language-sql">SELECT</code> qui ne sont pas utilisées dans une fonction d'agrégation doivent impérativement figurer dans la clause <code  class="language-sql">GROUP BY</code>. Si une colonne est omise dans <code  class="language-sql">GROUP BY</code>, une erreur sera généralement levée, car le SGBD ne saura pas quelle valeur afficher pour cette colonne au sein de chaque groupe. Cela permet de garantir que chaque valeur non agrégée affichée correspond bien à un groupe unique.</p>

<p>La clause <code  class="language-sql">WHERE</code> peut être utilisée pour filtrer les lignes *avant* le regroupement. Si vous souhaitez filtrer les groupes *après* le regroupement, en fonction du résultat de la fonction d'agrégation, vous devez utiliser la clause <code  class="language-sql">HAVING</code>.</p>
<pre><code  class="language-sql">
-- Example of using HAVING to filter groups after aggregation
SELECT client_id, SUM(quantite) AS total_quantite
FROM Commandes
WHERE produit = 'A' -- Filter before grouping
GROUP BY client_id
HAVING SUM(quantite) > 10; -- Filter groups where the total quantity is greater than 10
</code></pre>
<p>Dans l'exemple ci-dessus, la clause <code  class="language-sql">WHERE</code> filtre les commandes pour ne considérer que celles du produit 'A'. Ensuite, <code  class="language-sql">GROUP BY</code> regroupe les résultats par <code  class="language-sql">client_id</code>, et <code  class="language-sql">HAVING</code> filtre ces groupes pour ne conserver que ceux dont la somme des quantités est supérieure à 10.</p>

<p>En résumé, <code  class="language-sql">GROUP BY</code> offre une manière puissante de segmenter et d'analyser des données, permettant ainsi d'extraire des informations pertinentes et de répondre à des questions spécifiques concernant les ensembles de données. Combinée avec les fonctions d'agrégation et la clause <code  class="language-sql">HAVING</code>, elle permet d'effectuer des analyses complexes et d'obtenir des insights précis sur vos données.</p>
</p>
    <h3>4.3 HAVING : Filtrer les groupes</h3>
    <p><p>La clause <code  class="language-sql">HAVING</code> en SQL permet de filtrer les groupes créés par la clause <code  class="language-sql">GROUP BY</code>. Contrairement à <code  class="language-sql">WHERE</code>, qui filtre les lignes *avant* le regroupement, <code  class="language-sql">HAVING</code> filtre les groupes *après* l'application des fonctions d'agrégation.  En d'autres termes, <code  class="language-sql">HAVING</code> applique des conditions sur les résultats des fonctions d'agrégation, ce qui permet d'affiner les résultats en se basant sur des calculs.</p>

<p>La syntaxe générale est la suivante :</p>

<pre><code  class="language-sql">
SELECT column1, column2, ... , aggregate_function(column)
FROM table_name
WHERE condition
GROUP BY column1, column2, ...
HAVING aggregate_function(column) condition;
</code></pre>

<p>L'ordre d'exécution des clauses SQL est crucial pour comprendre comment <code  class="language-sql">HAVING</code> fonctionne. L'ordre est le suivant : <code  class="language-sql">FROM</code>, <code  class="language-sql">WHERE</code>, <code  class="language-sql">GROUP BY</code>, et enfin <code  class="language-sql">HAVING</code>. Cela signifie que les filtres <code  class="language-sql">WHERE</code> sont appliqués en premier, puis les données sont regroupées, et enfin, la clause <code  class="language-sql">HAVING</code> filtre ces groupes en fonction des résultats des fonctions d'agrégation.</p>

<p>Considérons une table nommée <code  class="language-sql">ventes</code> avec les colonnes <code  class="language-sql">produit</code> et <code  class="language-sql">montant</code>.</p>

<pre><code  class="language-sql">
-- Example table 'ventes'
CREATE TABLE ventes (
    produit VARCHAR(50),
    montant DECIMAL(10, 2)
);

INSERT INTO ventes (produit, montant) VALUES
('A', 100.00),
('B', 150.00),
('A', 200.00),
('C', 50.00),
('B', 100.00),
('A', 150.00),
('C', 200.00);
</code></pre>

<p>Pour trouver les produits dont la somme des ventes est supérieure à 300, on utilise la requête suivante :</p>

<pre><code  class="language-sql">
SELECT produit, SUM(montant) AS total_ventes
FROM ventes
GROUP BY produit
HAVING SUM(montant) > 300;
</code></pre>

<p>Dans cet exemple, <code  class="language-sql">GROUP BY produit</code> regroupe les ventes par produit. <code  class="language-sql">SUM(montant)</code> calcule la somme des ventes pour chaque produit. Enfin, <code  class="language-sql">HAVING SUM(montant) > 300</code> filtre ces groupes, ne conservant que ceux pour lesquels la somme des ventes est strictement supérieure à 300. Le résultat affichera uniquement les produits 'A' dont le total des ventes est de 450.</p>

<p>Un autre exemple, imaginons une table <code  class="language-sql">employes</code> avec les colonnes <code  class="language-sql">departement</code> et <code  class="language-sql">salaire</code>.</p>

<pre><code  class="language-sql">
-- Example table 'employes'
CREATE TABLE employes (
    departement VARCHAR(50),
    salaire DECIMAL(10, 2)
);

INSERT INTO employes (departement, salaire) VALUES
('Ventes', 60000.00),
('Marketing', 75000.00),
('Ventes', 80000.00),
('RH', 55000.00),
('Marketing', 90000.00),
('RH', 65000.00);
</code></pre>

<p>Pour trouver les départements dont le salaire moyen est supérieur à 70000, on utilise :</p>

<pre><code  class="language-sql">
SELECT departement, AVG(salaire) AS salaire_moyen
FROM employes
GROUP BY departement
HAVING AVG(salaire) > 70000;
</code></pre>

<p>Cette requête regroupe les employés par département, calcule le salaire moyen pour chaque département grâce à la fonction <code  class="language-sql">AVG(salaire)</code>, et filtre ensuite ces groupes. Seuls les départements ayant un salaire moyen strictement supérieur à 70000 seront inclus dans le résultat.</p>

<p>Il est possible d'utiliser plusieurs conditions dans la clause <code  class="language-sql">HAVING</code> en combinant les opérateurs logiques <code  class="language-sql">AND</code> et <code  class="language-sql">OR</code> pour créer des filtres plus complexes.</p>

<pre><code  class="language-sql">
-- Example with multiple conditions in HAVING clause
SELECT departement, COUNT(*) AS nombre_employes, AVG(salaire) AS salaire_moyen
FROM employes
GROUP BY departement
HAVING COUNT(*) > 1 AND AVG(salaire) > 60000;
</code></pre>

<p>Cet exemple affiche les départements ayant plus d'un employé ( <code  class="language-sql">COUNT(*) > 1</code> ) et dont le salaire moyen est supérieur à 60000 (<code  class="language-sql">AVG(salaire) > 60000</code> ). Les deux conditions doivent être vraies pour qu'un département soit inclus dans le résultat.  Cela permet d'affiner considérablement la sélection des groupes.</p>

<p>En résumé, la clause <code  class="language-sql">HAVING</code> est un outil puissant et indispensable pour filtrer les résultats agrégés obtenus avec <code  class="language-sql">GROUP BY</code>. Elle permet d'appliquer des conditions basées sur les résultats des fonctions d'agrégation, offrant ainsi une grande flexibilité dans l'extraction d'informations pertinentes à partir de données groupées. Comprendre son fonctionnement et son interaction avec les autres clauses SQL est essentiel pour effectuer des analyses de données efficaces.</p>
</p>
  </section>
</div>


<div class="content_box">
  <section>
    <h2 class="heading">5. Jointures : Combiner les données de plusieurs tables</h2>
    <p><p>Les jointures sont un outil puissant en SQL, permettant de combiner des données issues de deux tables ou plus. Elles sont indispensables pour exploiter pleinement les bases de données relationnelles, où les informations sont réparties dans plusieurs tables pour des raisons de normalisation et d'efficacité. Sans jointures, il serait difficile d'extraire des informations pertinentes en reliant les données entre elles.</p>

<p>La jointure la plus simple est la jointure interne (<code >INNER JOIN</code>). Elle ne renvoie que les lignes pour lesquelles une correspondance existe entre les tables, basée sur une condition spécifiée. Seules les lignes ayant une clé correspondante dans les deux tables seront incluses dans le résultat.</p>

<pre><code  class="language-sql">
-- Example of an INNER JOIN
-- Retrieve customer name and corresponding order ID from the Customers and Orders tables
SELECT Customers.CustomerName, Orders.OrderID
FROM Customers
INNER JOIN Orders ON Customers.CustomerID = Orders.CustomerID;

-- The ON clause specifies the join condition, in this case, matching CustomerID
</code></pre>

<p>Il existe également d'autres types de jointures, notamment les jointures externes (<code >LEFT JOIN</code>, <code >RIGHT JOIN</code>, <code >FULL OUTER JOIN</code>). Ces jointures sont utilisées lorsque vous souhaitez conserver toutes les lignes d'une ou des deux tables, même en l'absence de correspondance dans l'autre table. Dans ces cas, les colonnes de la table sans correspondance affichent la valeur <code >NULL</code>.</p>

<ul>
    <li><strong><code >LEFT JOIN</code> (ou <code >LEFT OUTER JOIN</code>):</strong> Retourne toutes les lignes de la table de gauche, ainsi que les lignes correspondantes de la table de droite. S'il n'y a aucune correspondance, les colonnes de la table de droite contiendront la valeur <code >NULL</code>.</li>
    <li><strong><code >RIGHT JOIN</code> (ou <code >RIGHT OUTER JOIN</code>):</strong> Retourne toutes les lignes de la table de droite, ainsi que les lignes correspondantes de la table de gauche. S'il n'y a aucune correspondance, les colonnes de la table de gauche contiendront la valeur <code >NULL</code>.</li>
    <li><strong><code >FULL OUTER JOIN</code>:</strong> Retourne toutes les lignes des tables de gauche et de droite. En l'absence de correspondance, les colonnes concernées contiendront la valeur <code >NULL</code>. Il est important de noter que ce type de jointure n'est pas pris en charge par tous les systèmes de gestion de bases de données (SGBD).</li>
</ul>

<pre><code  class="language-sql">
-- Example of a LEFT JOIN
-- Retrieve all customers and their corresponding order IDs (if any)
SELECT Customers.CustomerName, Orders.OrderID
FROM Customers
LEFT JOIN Orders ON Customers.CustomerID = Orders.CustomerID;

-- This will include all customers, even those who haven't placed any orders (OrderID will be NULL for them)
</code></pre>

<p>La clause <code >ON</code> est cruciale. Elle spécifie la condition de jointure, c'est-à-dire la ou les colonnes qui doivent correspondre entre les tables. L'utilisation d'alias de table (par exemple, <code >c</code> pour <code >Customers</code>) améliore considérablement la lisibilité des requêtes, en particulier lorsque plusieurs jointures sont impliquées.</p>

<pre><code  class="language-sql">
-- Example using table aliases
SELECT c.CustomerName, o.OrderID
FROM Customers AS c
LEFT JOIN Orders AS o ON c.CustomerID = o.CustomerID;
</code></pre>

<p>Il est possible de joindre plus de deux tables dans une seule requête. Pour cela, il suffit d'ajouter d'autres clauses <code >JOIN</code>, chacune avec sa condition respective. Cela permet de créer des requêtes complexes qui combinent des données provenant de plusieurs sources.</p>

<pre><code  class="language-sql">
-- Example joining three tables: Customers, Orders, and OrderDetails
SELECT c.CustomerName, o.OrderID, od.Quantity
FROM Customers AS c
INNER JOIN Orders AS o ON c.CustomerID = o.CustomerID
INNER JOIN OrderDetails AS od ON o.OrderID = od.OrderID;
</code></pre>

<p>Enfin, un type de jointure moins courant est la jointure croisée (<code >CROSS JOIN</code>). Elle produit le produit cartésien des tables, c'est-à-dire toutes les combinaisons possibles de lignes entre les tables. Son utilisation doit être faite avec précaution car le résultat peut être très volumineux et potentiellement inutile si elle n'est pas correctement filtrée.</p>

<pre><code  class="language-sql">
-- Example of a CROSS JOIN (use with caution!)
-- Retrieve all possible combinations of customers and products
SELECT Customers.CustomerName, Products.ProductName
FROM Customers
CROSS JOIN Products;
</code></pre>

<p>La maîtrise des jointures est essentielle pour interroger efficacement des bases de données relationnelles et extraire des informations significatives en combinant les données provenant de différentes sources. Une bonne compréhension des différents types de jointures permet d'optimiser les requêtes et d'obtenir les résultats souhaités.</p>
</p>
    <h3>5.1 INNER JOIN : Récupérer les correspondances</h3>
    <p><p>L'opération <code >INNER JOIN</code> est un type de jointure SQL qui permet de combiner des lignes de deux tables en se basant sur une condition spécifiée. Elle renvoie uniquement les lignes pour lesquelles il existe une correspondance entre les deux tables, en utilisant une ou plusieurs colonnes communes. En d'autres termes, seules les lignes qui satisfont la condition de jointure sont incluses dans le résultat. C'est une jointure qui garantit l'intégrité référentielle des données.</p>

<p>La syntaxe de base d'une <code >INNER JOIN</code> est la suivante :</p>

<pre><code  class="language-sql">
SELECT column1, column2, ...
FROM table1
INNER JOIN table2
ON table1.column_name = table2.column_name;
</code></pre>

<ul>
    <li><code >SELECT column1, column2, ...</code>: Spécifie les colonnes à sélectionner dans les tables jointes.</li>
    <li><code >FROM table1</code>: Indique la première table à partir de laquelle les données sont extraites.</li>
    <li><code >INNER JOIN table2</code>: Joint la <code >table1</code> avec la <code >table2</code>.</li>
    <li><code >ON table1.column_name = table2.column_name</code>: Définit la condition de jointure, où <code >column_name</code> est la colonne commune aux deux tables.</li>
</ul>

<p>Prenons un exemple concret avec deux tables : <code >clients</code> et <code >commandes</code>. La table <code >clients</code> contient des informations sur les clients, et la table <code >commandes</code> contient des informations sur les commandes passées par ces clients. Nous souhaitons récupérer une liste de tous les clients ayant passé des commandes, avec les détails de leurs commandes.</p>

<p>La table <code >clients</code> pourrait être définie comme ceci :</p>

<pre><code  class="language-sql">
CREATE TABLE clients (
    client_id INT PRIMARY KEY,
    nom VARCHAR(255),
    email VARCHAR(255)
);

INSERT INTO clients (client_id, nom, email) VALUES
(1, 'Jean Dupont', 'jean.dupont@example.com'),
(2, 'Alice Martin', 'alice.martin@example.com'),
(3, 'Pierre Lefevre', 'pierre.lefevre@example.com'),
(4, 'Sophie Girard', 'sophie.girard@example.com');
</code></pre>

<p>Et la table <code >commandes</code> comme cela :</p>

<pre><code  class="language-sql">
CREATE TABLE commandes (
    commande_id INT PRIMARY KEY,
    client_id INT,
    produit VARCHAR(255),
    quantite INT,
    FOREIGN KEY (client_id) REFERENCES clients(client_id)
);

INSERT INTO commandes (commande_id, client_id, produit, quantite) VALUES
(101, 1, 'Ordinateur portable', 1),
(102, 2, 'Smartphone', 2),
(103, 1, 'Tablette', 1),
(104, 3, 'Écran', 1);
</code></pre>

<p>Pour récupérer les informations combinées des clients et de leurs commandes, nous pouvons utiliser une requête <code >INNER JOIN</code> :</p>

<pre><code  class="language-sql">
SELECT
    clients.nom,
    clients.email,
    commandes.produit,
    commandes.quantite
FROM
    clients
INNER JOIN
    commandes ON clients.client_id = commandes.client_id;
</code></pre>

<p>Cette requête va retourner les lignes où le <code >client_id</code> dans la table <code >clients</code> correspond au <code >client_id</code> dans la table <code >commandes</code>. Seuls les clients qui ont passé au moins une commande seront inclus dans le résultat. Le résultat de cette requête sera :</p>

<pre><code  class="language-sql">
-- Result:
-- nom         | email                      | produit            | quantite
-- ----------- | -------------------------- | ------------------ | --------
-- Jean Dupont | jean.dupont@example.com  | Ordinateur portable | 1
-- Alice Martin | alice.martin@example.com | Smartphone         | 2
-- Jean Dupont | jean.dupont@example.com  | Tablette           | 1
-- Pierre Lefevre| pierre.lefevre@example.com | Écran             | 1
</code></pre>

<p>L'<code >INNER JOIN</code> est donc un outil puissant pour combiner des données provenant de plusieurs tables et obtenir des informations cohérentes et pertinentes en se basant sur des relations logiques entre ces tables.  Elle est particulièrement utile lorsque vous souhaitez afficher des informations liées entre plusieurs tables, assurant que seules les données ayant une correspondance sont affichées.  Il est important de noter que si un client n'a pas de commande associée, il ne sera pas affiché dans le résultat de la requête <code >INNER JOIN</code>.  Pour inclure tous les clients, même ceux sans commandes, d'autres types de jointures comme <code >LEFT JOIN</code> peuvent être utilisés.</p>
</p>
    <h3>5.2 LEFT JOIN : Récupérer toutes les lignes de la table de gauche</h3>
    <p><p>Le <code  class="language-sql">LEFT JOIN</code> (ou <code  class="language-sql">LEFT OUTER JOIN</code>) est une opération SQL qui combine des lignes de deux tables. Il renvoie toutes les lignes de la table de gauche (celle mentionnée avant le mot-clé <code  class="language-sql">LEFT JOIN</code>) et les lignes correspondantes de la table de droite.  Si aucune correspondance n'est trouvée dans la table de droite pour une ligne de la table de gauche, les colonnes de la table de droite dans le résultat seront remplies avec des valeurs <code  class="language-sql">NULL</code>.</p>

<p>Prenons l'exemple de deux tables : <code  class="language-sql">clients</code> et <code  class="language-sql">commandes</code>. La table <code  class="language-sql">clients</code> contient des informations sur les clients, tandis que la table <code  class="language-sql">commandes</code> enregistre les commandes passées par ces clients. Un client peut très bien ne pas avoir encore passé de commande. Supposons que nous voulions récupérer la liste de tous les clients et, le cas échéant, les commandes associées à chacun.</p>

<p>Voici une requête <code  class="language-sql">LEFT JOIN</code> qui illustre ce cas :</p>

<pre><code  class="language-sql">
-- Select the client's name and the order ID for each client
SELECT
    clients.nom_client,
    commandes.id_commande
FROM
    clients
LEFT JOIN
    commandes ON clients.id_client = commandes.id_client;
-- The LEFT JOIN ensures that all clients are included in the result,
-- even if they haven't placed any orders.
-- If a client has no orders, the order ID will be NULL.
</code></pre>

<p>Dans cette requête, tous les clients de la table <code  class="language-sql">clients</code> seront inclus dans le résultat, même ceux qui n'ont pas de commandes associées dans la table <code  class="language-sql">commandes</code>. Pour les clients sans commandes, la valeur de la colonne <code  class="language-sql">id_commande</code> sera <code  class="language-sql">NULL</code>.</p>

<p>Illustrons cela avec un autre exemple concret : imaginons une base de données pour la gestion d'un portfolio de projets. Nous aurions une table <code  class="language-sql">projets</code> et une table <code  class="language-sql">taches</code>. Chaque tâche est assignée à un projet spécifique, mais un projet peut ne pas avoir de tâches associées, par exemple s'il vient d'être créé. Nous souhaitons obtenir une liste de tous les projets et de leurs tâches associées (si elles existent).</p>

<pre><code  class="language-sql">
-- Select the project name and the task description for each project
SELECT
    projets.nom_projet,
    taches.description_tache
FROM
    projets
LEFT JOIN
    taches ON projets.id_projet = taches.id_projet;
-- This query retrieves all projects, even if they don't have any tasks assigned.
-- The task description will be NULL for projects without tasks.
</code></pre>

<p>En résumé, le <code  class="language-sql">LEFT JOIN</code> est un outil puissant pour extraire des données de plusieurs tables tout en garantissant que toutes les lignes de la table de gauche sont incluses dans le résultat, même en l'absence de correspondance dans la table de droite. Cela est particulièrement utile pour identifier les éléments de la table de gauche qui n'ont pas de relation correspondante dans la table de droite, comme les clients sans commandes ou les projets sans tâches, ce qui permet de réaliser des analyses complètes et d'identifier les points à améliorer ou les actions à entreprendre.</p>
</p>
    <h3>5.3 RIGHT JOIN : Récupérer toutes les lignes de la table de droite</h3>
    <p><p>Le <code >RIGHT JOIN</code>, ou jointure droite, est une opération SQL qui combine les lignes de deux tables en se basant sur une condition spécifiée. À l'inverse du <code >LEFT JOIN</code>, le <code >RIGHT JOIN</code> retourne toutes les lignes de la table de droite (celle mentionnée après le mot-clé <code >RIGHT JOIN</code>) ainsi que les lignes correspondantes de la table de gauche. Si une ligne de la table de droite n'a pas de correspondance dans la table de gauche, les colonnes issues de la table de gauche sont remplies avec des valeurs <code >NULL</code>.</p>

<p>Considérons deux tables : <code >clients</code> et <code >commandes</code>. La table <code >clients</code> stocke des informations sur les clients, tandis que la table <code >commandes</code> enregistre les commandes passées par ces clients.</p>

<pre><code  class="language-sql">
-- Table: clients
-- id_client (INT, Primary Key)
-- nom (VARCHAR)
-- email (VARCHAR)

-- Table: commandes
-- id_commande (INT, Primary Key)
-- id_client (INT, Foreign Key referencing clients.id_client)
-- date_commande (DATE)
-- montant (DECIMAL)
</code></pre>

<p>Supposons que l'on souhaite récupérer toutes les commandes et les informations des clients correspondants. Même si certains clients n'ont pas encore passé de commande, nous désirons les inclure dans le résultat, avec des valeurs <code >NULL</code> pour les détails de la commande. Dans ce cas, un <code >RIGHT JOIN</code> serait approprié.</p>

<pre><code  class="language-sql">
SELECT
    c.id_client,
    c.nom,
    o.id_commande,
    o.date_commande,
    o.montant
FROM
    clients c
RIGHT JOIN
    commandes o ON c.id_client = o.id_client;
</code></pre>

<p>Dans cet exemple, la requête renverra toutes les lignes de la table <code >commandes</code>. Si un <code >id_client</code> dans <code >commandes</code> n'est pas présent dans la table <code >clients</code>, les colonnes <code >id_client</code> et <code >nom</code> provenant de la table <code >clients</code> afficheront <code >NULL</code> pour cette commande.</p>

<p>Le <code >RIGHT JOIN</code> est particulièrement utile pour identifier les enregistrements d'une table (ici, <code >commandes</code>) qui n'ont pas de correspondance dans une autre table (ici, <code >clients</code>). Il est important de noter que le <code >RIGHT JOIN</code> peut souvent être reformulé en utilisant un <code >LEFT JOIN</code>, simplement en inversant l'ordre des tables dans la requête. Le choix entre <code >RIGHT JOIN</code> et <code >LEFT JOIN</code> dépend souvent de la lisibilité et de la clarté de la logique métier.</p>

<p>Voici un exemple de requête permettant d'identifier les commandes qui n'ont pas de client associé :</p>

<pre><code  class="language-sql">
SELECT
    o.id_commande,
    o.date_commande,
    o.montant
FROM
    clients c
RIGHT JOIN
    commandes o ON c.id_client = o.id_client
WHERE
    c.id_client IS NULL;
</code></pre>

<p>Cette requête filtre les résultats du <code >RIGHT JOIN</code> en ne conservant que les lignes où <code >c.id_client</code> est <code >NULL</code>, indiquant ainsi l'absence de correspondance entre la commande et un client dans la table <code >clients</code>.</p>

<p>Il est également possible d'obtenir le même résultat en utilisant un <code >LEFT JOIN</code>, ce qui peut améliorer la lisibilité dans certains cas :</p>

<pre><code  class="language-sql">
SELECT
    o.id_commande,
    o.date_commande,
    o.montant
FROM
    commandes o
LEFT JOIN
    clients c ON c.id_client = o.id_client
WHERE
    c.id_client IS NULL;
</code></pre>

<p>Dans cette version avec <code >LEFT JOIN</code>, nous partons de la table <code >commandes</code> et recherchons les clients correspondants. La clause <code >WHERE c.id_client IS NULL</code> filtre ensuite les commandes qui n'ont pas de client associé.</p>
</p>
  </section>
</div>


<div class="content_box">
  <section>
    <h2 class="heading">6. Sous-requêtes</h2>
    <p><p>Les sous-requêtes sont des requêtes SQL imbriquées à l'intérieur d'une autre requête SQL. Elles permettent de résoudre des problèmes complexes en décomposant une requête en étapes logiques. Une sous-requête peut apparaître dans la clause <code  class="language-sql">SELECT</code>, <code  class="language-sql">FROM</code>, <code  class="language-sql">WHERE</code> ou <code  class="language-sql">HAVING</code> d'une requête SQL.</p>

<p>L'utilisation la plus courante est dans la clause <code  class="language-sql">WHERE</code>, pour filtrer les résultats en fonction d'une condition qui dépend du résultat d'une autre requête. Par exemple, pour sélectionner tous les clients dont le pays est celui qui compte le plus de fournisseurs :</p>

<pre><code  class="language-sql">
SELECT customer_name
FROM customers
WHERE country = (SELECT country
                 FROM suppliers
                 GROUP BY country
                 ORDER BY COUNT(*) DESC
                 LIMIT 1);
-- This query selects the customer names from the 'customers' table
-- where the customer's country matches the country with the highest
-- number of suppliers in the 'suppliers' table.
-- The subquery finds this country.
</code></pre>

<p>Dans cet exemple, la sous-requête <code  class="language-sql">SELECT country FROM suppliers GROUP BY country ORDER BY COUNT(*) DESC LIMIT 1</code> renvoie le pays ayant le plus grand nombre de fournisseurs. La requête principale utilise ce résultat pour filtrer les clients.</p>

<p>Une sous-requête peut également être utilisée dans la clause <code  class="language-sql">SELECT</code>, pour calculer une valeur dérivée qui sera affichée avec les résultats de la requête principale. Par exemple, pour afficher le nom de chaque produit avec le prix moyen de tous les produits :</p>

<pre><code  class="language-sql">
SELECT product_name,
       (SELECT AVG(price) FROM products) AS average_price
FROM products;
-- This query selects the product name from the 'products' table
-- and displays it along with the average price of all products,
-- calculated by the subquery.  The average price is displayed
-- alongside each product name.
</code></pre>

<p>Il est aussi possible d'utiliser une sous-requête dans la clause <code  class="language-sql">FROM</code>, traitant le résultat de la sous-requête comme une table temporaire. On parle alors de "table dérivée" ou de "vue matérialisée". C'est particulièrement utile pour simplifier des requêtes complexes ou pour effectuer des opérations d'agrégation en plusieurs étapes. Par exemple, pour trouver les départements dont le salaire moyen des employés est supérieur à la moyenne de tous les salaires moyens des départements :</p>

<pre><code  class="language-sql">
SELECT department_name
FROM (SELECT department_name, AVG(salary) AS avg_salary
      FROM employees
      GROUP BY department_name) AS department_salaries
WHERE avg_salary > (SELECT AVG(avg_salary)
                    FROM (SELECT department_name, AVG(salary) AS avg_salary
                          FROM employees
                          GROUP BY department_name) AS all_department_salaries);
-- This query finds the departments whose average salary is higher than the average
-- of all department average salaries. It uses subqueries to calculate these averages.
-- The inner subquery calculates the average salary for each department, and the
-- outer subquery calculates the average of those average salaries.
</code></pre>

<p>Les sous-requêtes peuvent être corrélées ou non corrélées. Une sous-requête non corrélée est indépendante de la requête principale et peut être exécutée une seule fois, avant la requête principale. Le résultat est ensuite utilisé par la requête principale. Une sous-requête corrélée, en revanche, fait référence à une colonne de la requête principale. Elle doit être exécutée une fois pour chaque ligne sélectionnée (ou considérée) par la requête principale. Les sous-requêtes corrélées sont généralement plus lentes, mais elles offrent une plus grande flexibilité pour exprimer des logiques complexes.</p>

<p>Par exemple, voici une sous-requête corrélée pour trouver tous les employés dont le salaire est supérieur à la moyenne du salaire de leur département :</p>

<pre><code  class="language-sql">
SELECT employee_name
FROM employees e1
WHERE salary > (SELECT AVG(salary)
                FROM employees e2
                WHERE e2.department_id = e1.department_id);
-- This query selects employee names where their salary is higher than
-- the average salary of employees in their department. The subquery
-- is correlated, as it depends on the department_id of the outer query (e1).
-- For each employee in the outer query (e1), the subquery calculates the
-- average salary of employees in the same department (e2).
</code></pre>

<p>En conclusion, les sous-requêtes sont un outil puissant en SQL qui permettent d'effectuer des requêtes complexes et de manipuler des données de manière flexible. La maîtrise de leur fonctionnement et des différents types de sous-requêtes est essentielle pour écrire des requêtes SQL efficaces et optimisées. L'utilisation judicieuse des sous-requêtes, qu'elles soient corrélées ou non, permet de résoudre des problèmes de manipulation de données qui seraient difficilement réalisables autrement.</p>
</p>
    <h3>6.1 Sous-requêtes dans la clause WHERE</h3>
    <p><p>La clause <code  class="language-sql">WHERE</code> offre une puissante capacité à filtrer les résultats d'une requête SQL en utilisant une sous-requête. Cela permet de créer des conditions de filtrage dynamiques basées sur les résultats d'une autre requête, offrant une grande flexibilité dans la manipulation des données.</p>

<p>La forme la plus élémentaire d'une sous-requête dans une clause <code  class="language-sql">WHERE</code> est celle qui renvoie une seule valeur. Cette valeur scalaire peut ensuite être utilisée pour des comparaisons directes.</p>

<pre><code  class="language-sql">
-- Retrieve employees whose salary is above the average salary of all employees
SELECT employee_name, salary
FROM employees
WHERE salary > (SELECT AVG(salary) FROM employees);
</code></pre>

<p>Dans cet exemple, la sous-requête <code  class="language-sql">SELECT AVG(salary) FROM employees</code> calcule le salaire moyen de tous les employés. La requête principale utilise ensuite cette moyenne pour filtrer et ne sélectionner que les employés dont le salaire est supérieur à cette valeur.</p>

<p>L'opérateur <code  class="language-sql">IN</code> est particulièrement utile lorsqu'une sous-requête renvoie un ensemble de valeurs.  Cela permet de vérifier si une valeur se trouve dans cet ensemble.</p>

<pre><code  class="language-sql">
-- Retrieve orders placed by customers located in a specific country
SELECT order_id, customer_id
FROM orders
WHERE customer_id IN (SELECT customer_id FROM customers WHERE country = 'France');
</code></pre>

<p>Ici, la sous-requête <code  class="language-sql">SELECT customer_id FROM customers WHERE country = 'France'</code> renvoie une liste de tous les identifiants des clients résidant en France.  La requête principale sélectionne ensuite toutes les commandes associées à ces clients spécifiques.</p>

<p>L'opérateur <code  class="language-sql">EXISTS</code> est une autre option puissante. Il vérifie simplement l'existence d'au moins une ligne retournée par la sous-requête.  Il est souvent utilisé pour vérifier des relations entre tables.</p>

<pre><code  class="language-sql">
-- Retrieve products that have been ordered at least once
SELECT product_name
FROM products
WHERE EXISTS (SELECT 1 FROM order_items WHERE order_items.product_id = products.product_id);
</code></pre>

<p>Dans cet exemple, la sous-requête <code  class="language-sql">SELECT 1 FROM order_items WHERE order_items.product_id = products.product_id</code> est évaluée pour chaque produit dans la table <code  class="language-sql">products</code>. Si une ligne est trouvée dans la table <code  class="language-sql">order_items</code> correspondant à ce produit (ce qui signifie que le produit a été commandé), l'opérateur <code  class="language-sql">EXISTS</code> retourne vrai, et le produit est inclus dans le résultat.</p>

<p>En résumé, l'utilisation de sous-requêtes dans la clause <code  class="language-sql">WHERE</code> permet de créer des filtres sophistiqués basés sur des données dynamiques. Le choix entre une sous-requête retournant une valeur unique, l'opérateur <code  class="language-sql">IN</code> ou l'opérateur <code  class="language-sql">EXISTS</code> dépend du problème spécifique à résoudre et de la structure des données.</p>
</p>
    <h3>6.2 Sous-requêtes dans la clause SELECT</h3>
    <p><p>Une sous-requête dans la clause <code  class="language-sql">SELECT</code> permet d'enrichir le résultat d'une requête en ajoutant une colonne calculée. Cette technique est particulièrement utile pour effectuer des agrégations ou des calculs basés sur des données provenant d'autres tables, sans recourir à des jointures complexes. Elle offre une manière concise d'intégrer des informations supplémentaires directement dans votre ensemble de résultats.</p>

<p>Considérons les tables <code  class="language-sql">Orders</code> et <code  class="language-sql">Customers</code>. La table <code  class="language-sql">Orders</code> contient les colonnes <code  class="language-sql">order_id</code> et <code  class="language-sql">customer_id</code>, tandis que la table <code  class="language-sql">Customers</code> inclut <code  class="language-sql">customer_id</code> et <code  class="language-sql">customer_name</code>. Supposons que vous souhaitiez afficher une liste de toutes les commandes, en incluant le nom du client qui a passé chaque commande. Voici comment vous pouvez utiliser une sous-requête dans la clause <code  class="language-sql">SELECT</code> pour atteindre cet objectif :</p>

<pre><code  class="language-sql">
SELECT
    order_id,
    customer_id,
    (SELECT customer_name FROM Customers WHERE Customers.customer_id = Orders.customer_id) AS customer_name
FROM
    Orders;
-- This SQL query retrieves the order_id and customer_id from the Orders table.
-- It also includes a subquery to fetch the customer_name from the Customers table
-- based on the matching customer_id. The result is aliased as customer_name.
</code></pre>

<p>Dans cet exemple, la sous-requête <code  class="language-sql">(SELECT customer_name FROM Customers WHERE Customers.customer_id = Orders.customer_id)</code> est exécutée pour chaque ligne de la table <code  class="language-sql">Orders</code>. Pour chaque commande, elle récupère le <code  class="language-sql">customer_name</code> correspondant au <code  class="language-sql">customer_id</code> de cette commande. Le résultat de cette sous-requête est ajouté comme une nouvelle colonne, nommée <code  class="language-sql">customer_name</code>, dans l'ensemble de résultats final.</p>

<p>Un autre cas d'utilisation fréquent est le calcul d'agrégats. Par exemple, supposons que vous souhaitiez afficher le nom et le prix de chaque produit de la table <code  class="language-sql">Products</code>, ainsi que le prix moyen de tous les produits. Une sous-requête peut être utilisée pour calculer le prix moyen et l'inclure dans chaque ligne du résultat.</p>

<pre><code  class="language-sql">
SELECT
    product_name,
    price,
    (SELECT AVG(price) FROM Products) AS average_price
FROM
    Products;
-- This SQL query selects the product_name and price from the Products table.
-- It also uses a subquery to calculate the average price of all products.
-- The result of the subquery is added as a new column named average_price in the output.
</code></pre>

<p>Dans cet exemple, la sous-requête <code  class="language-sql">(SELECT AVG(price) FROM Products)</code> calcule le prix moyen de tous les produits une seule fois. Ce résultat est ensuite répété pour chaque ligne de la table <code  class="language-sql">Products</code>, permettant ainsi de comparer le prix de chaque produit au prix moyen global. Cela est particulièrement utile pour identifier les produits qui sont au-dessus ou en dessous de la moyenne.</p>

<p>En conclusion, les sous-requêtes dans la clause <code  class="language-sql">SELECT</code> offrent une méthode puissante pour ajouter des informations calculées ou dérivées à vos requêtes, ce qui vous permet d'obtenir des résultats plus riches et informatifs. Cependant, il est crucial de considérer l'impact sur les performances, car les sous-requêtes peuvent parfois être moins efficaces que les jointures, surtout pour les ensembles de données volumineux. Il est donc recommandé d'évaluer attentivement les performances et de choisir l'approche la plus appropriée en fonction des besoins spécifiques de votre application.</p>
</p>
    <h3>6.3 Sous-requêtes dans la clause FROM</h3>
    <p><p>En SQL, la clause <code  class="language-sql">FROM</code> spécifie la ou les tables à partir desquelles les données sont extraites. Une sous-requête dans la clause <code  class="language-sql">FROM</code>, également appelée table dérivée ou vue matérialisée temporaire, permet de définir une table basée sur le résultat d'une autre requête. Cette table temporaire peut ensuite être utilisée comme n'importe quelle autre table dans la requête principale.</p>

<p>L'utilisation d'une sous-requête dans la clause <code  class="language-sql">FROM</code> est particulièrement utile lorsque vous avez besoin d'effectuer des opérations complexes, telles que des agrégations multiples, des calculs conditionnels ou des filtrages basés sur des résultats intermédiaires, avant de joindre les données à d'autres tables ou d'effectuer d'autres traitements.</p>

<p>Voici un exemple concret. Supposons que vous ayez une table nommée <code  class="language-sql">commandes</code> contenant des informations sur les commandes, y compris l'identifiant du client (<code  class="language-sql">id_client</code>) et le montant total de la commande (<code  class="language-sql">montant_commande</code>). Vous souhaitez trouver les clients dont le montant total des commandes est supérieur à la moyenne de tous les montants de commandes. Pour cela, nous pouvons utiliser une sous-requête dans la clause <code  class="language-sql">FROM</code> pour calculer la somme des commandes par client.</p>

<pre><code  class="language-sql">
-- Calculate the total order amount for each customer using a subquery in the FROM clause.
SELECT
    c.id_client,
    SUM(c.montant_commande) AS montant_total_commandes
FROM
    commandes c
GROUP BY
    c.id_client;
</code></pre>

<p>Cette requête retourne une table temporaire contenant l'identifiant de chaque client et le montant total de ses commandes. Nous pouvons ensuite utiliser cette table temporaire dans une requête principale pour filtrer les clients dont le montant total des commandes est supérieur à la moyenne.</p>

<pre><code  class="language-sql">
-- Find customers whose total order amount is greater than the average order amount using a subquery in the FROM clause.
SELECT
    st.id_client,
    st.montant_total_commandes
FROM
    (SELECT
        c.id_client,
        SUM(c.montant_commande) AS montant_total_commandes
    FROM
        commandes c
    GROUP BY
        c.id_client) AS st  -- Alias for the subquery, required in most SQL implementations
WHERE
    st.montant_total_commandes > (SELECT AVG(montant_commande) FROM commandes);
</code></pre>

<p>Dans cet exemple, <code  class="language-sql">st</code> est un alias attribué à la sous-requête. L'alias est <strong>obligatoire</strong> car chaque table dérivée dans la clause <code  class="language-sql">FROM</code> doit avoir un nom. La requête principale sélectionne ensuite les <code  class="language-sql">id_client</code> et <code  class="language-sql">montant_total_commandes</code> de cette table temporaire, en filtrant les résultats pour n'inclure que les clients dont le montant total des commandes est supérieur à la moyenne de tous les montants de commandes.</p>

<p>Un autre exemple pourrait être de trouver les trois produits les plus vendus. On pourrait imaginer une table <code  class="language-sql">ventes</code> contenant <code  class="language-sql">id_produit</code> et <code  class="language-sql">quantite_vendue</code>. On peut utiliser une sous-requête pour calculer le total des ventes par produit, puis une autre requête pour limiter le résultat aux trois premiers.  Il est important de noter que l'ordre (<code  class="language-sql">ORDER BY</code>) dans une sous-requête de la clause <code  class="language-sql">FROM</code> est ignoré par défaut, sauf si une clause <code  class="language-sql">LIMIT</code> est également spécifiée, car l'optimiseur de requête peut réorganiser les opérations.</p>

<pre><code  class="language-sql">
-- Find the top 3 best-selling products using a subquery in the FROM clause.
SELECT
    top_ventes.id_produit,
    top_ventes.total_quantite_vendue
FROM
    (SELECT
        id_produit,
        SUM(quantite_vendue) AS total_quantite_vendue
    FROM
        ventes
    GROUP BY
        id_produit
    ORDER BY
        total_quantite_vendue DESC
    LIMIT 3) AS top_ventes;
</code></pre>

<p>L'intérêt des sous-requêtes dans la clause <code  class="language-sql">FROM</code> réside dans leur capacité à simplifier des requêtes complexes en les décomposant en étapes logiques. Elles permettent d'améliorer la lisibilité et la maintenabilité du code SQL, tout en offrant une grande flexibilité pour manipuler et transformer les données. Cependant, il est crucial de les utiliser avec discernement, car des sous-requêtes excessivement complexes peuvent impacter négativement les performances de la base de données. Pensez à optimiser vos requêtes et à utiliser des index appropriés pour garantir une exécution efficace.</p>
</p>
  </section>
</div>


<div class="content_box">
  <section>
    <h2 class="heading">7. Cas d'utilisation pratiques</h2>
    <p><p>SQL, au-delà de la simple interrogation de bases de données, offre un large éventail de cas d'utilisation pratiques dans divers domaines. Explorons quelques exemples concrets.</p>

<p><strong>Analyse de données et reporting :</strong> SQL est un outil puissant pour extraire, transformer et agréger des données à des fins d'analyse et de reporting. Prenons l'exemple d'une entreprise de vente au détail souhaitant analyser les performances de ses produits par région.</p>

<pre><code  class="language-sql">
-- Calculate total sales per region, including product category
SELECT
    region,
    product_category,
    SUM(sales_amount) AS total_sales
FROM
    sales_data
GROUP BY
    region,
    product_category
ORDER BY
    total_sales DESC;
</code></pre>

<p>Cette requête calcule le chiffre d'affaires total par région et par catégorie de produit, offrant ainsi une vue plus granulaire des performances. Les résultats peuvent être utilisés pour identifier les régions et les catégories de produits les plus performantes, celles qui nécessitent une attention particulière, et pour ajuster les stratégies de vente et de marketing en conséquence. Une analyse plus approfondie pourrait impliquer l'utilisation de fonctions de fenêtrage pour comparer les performances régionales par rapport à la moyenne nationale.</p>

<p><strong>Gestion de la relation client (CRM) :</strong> Les systèmes CRM reposent fortement sur SQL pour gérer les informations client, suivre les interactions et personnaliser les communications. Imaginez un scénario où une entreprise souhaite identifier les clients qui n'ont pas effectué d'achat depuis plus de six mois, mais qui ont manifesté un intérêt récent pour un produit spécifique, et leur envoyer une offre promotionnelle ciblée.</p>

<pre><code  class="language-sql">
-- Identify inactive customers interested in a specific product and their email addresses
SELECT
    c.customer_id,
    c.email_address
FROM
    customers c
JOIN
    customer_interests i ON c.customer_id = i.customer_id
WHERE
    c.last_purchase_date < DATE('now', '-6 months')
    AND i.product_id = 'specific_product_id';
</code></pre>

<p>Cette requête extrait les identifiants et adresses e-mail des clients inactifs, mais ayant manifesté un intérêt pour un produit spécifique, permettant ainsi de cibler une campagne marketing ultra-personnalisée. Elle illustre comment SQL peut être utilisé pour segmenter la clientèle de manière très précise et améliorer l'efficacité des efforts marketing. L'ajout de données comportementales, telles que les visites de pages web, améliorerait encore le ciblage.</p>

<p><strong>Intégration de données :</strong> SQL facilite l'intégration de données provenant de différentes sources. Supposons qu'une entreprise fusionne deux bases de données clients, l'une contenant des informations démographiques et l'autre des données d'achat, mais que les identifiants clients soient différents dans chaque base de données.  Une table de correspondance est nécessaire.</p>

<pre><code  class="language-sql">
-- Combine customer demographic and purchase data using a mapping table
CREATE TABLE combined_customers AS
SELECT
    d.first_name,
    d.last_name,
    d.email_address,
    p.total_purchases,
    p.average_order_value
FROM
    demographics d
JOIN
    customer_mapping m ON d.customer_id = m.demographic_id
JOIN
    purchases p ON m.purchase_id = p.customer_id;
</code></pre>

<p>Cette requête crée une nouvelle table combinant les données des deux bases, en utilisant une table de correspondance (<code >customer_mapping</code>) pour relier les différents identifiants clients. Cela permet d'obtenir une vue unifiée des clients malgré les différences de structure des données sources.  La gestion des doublons et des valeurs nulles est cruciale dans ce type d'intégration.</p>

<p><strong>Automatisation des tâches :</strong> SQL peut être utilisé pour automatiser des tâches répétitives, telles que la sauvegarde de données ou la génération de rapports périodiques. Par exemple, un script SQL peut être programmé pour sauvegarder quotidiennement une table importante et envoyer une notification en cas d'échec.</p>

<pre><code  class="language-sql">
-- Create a backup of the 'users' table
CREATE TABLE users_backup AS
SELECT * FROM users;

-- Add a timestamp column to the backup table
ALTER TABLE users_backup ADD COLUMN backup_date TIMESTAMP DEFAULT CURRENT_TIMESTAMP;

-- Example of scheduling this script (implementation depends on the database system)
-- This is a conceptual example and might require specific syntax for the database being used
-- For example, using cron jobs on Linux or SQL Server Agent on SQL Server
</code></pre>

<p>Cet exemple montre comment créer une sauvegarde d'une table et y ajouter un horodatage. L'automatisation de telles tâches nécessite souvent l'intégration de SQL avec des outils de planification de tâches externes, comme <code >cron</code> sur les systèmes Unix ou l'Agent SQL Server sur SQL Server.  La gestion des erreurs et la journalisation sont des aspects importants de l'automatisation.</p>

<p>En conclusion, SQL est un outil polyvalent qui dépasse largement le simple requêtage de données. Son utilisation dans l'analyse de données, la gestion de la relation client, l'intégration de données et l'automatisation des tâches en fait une compétence essentielle pour les professionnels travaillant avec des données. La maîtrise de SQL permet non seulement d'accéder aux données, mais aussi de les transformer et de les exploiter pour prendre des décisions éclairées.</p>
</p>
    <h3>7.1 Analyse des ventes : Identification des produits les plus vendus</h3>
    <p><p>L'analyse des ventes est un cas d'utilisation fondamental de SQL. Identifier les produits les plus vendus permet d'optimiser la gestion des stocks, d'orienter les campagnes marketing et de mieux comprendre les préférences des clients. Pour y parvenir, nous exploitons les fonctions d'agrégation et de regroupement de données offertes par SQL.</p>

<p>La fonction <code  class="language-sql">COUNT()</code> est un outil essentiel dans ce contexte. Elle permet de déterminer le nombre d'occurrences d'une valeur spécifique dans une colonne donnée. Combinée à la clause <code  class="language-sql">GROUP BY</code>, elle nous permet de calculer le nombre total de ventes pour chaque produit distinct.</p>

<p>Imaginons une table nommée <code  class="language-sql">ventes</code>, structurée avec les colonnes suivantes : <code  class="language-sql">id_vente</code> (l'identifiant unique de chaque transaction), <code  class="language-sql">id_produit</code> (l'identifiant du produit vendu) et <code  class="language-sql">date_vente</code> (la date de la transaction). La requête SQL ci-dessous illustre comment calculer le nombre de ventes par produit :</p>

<pre><code  class="language-sql">
-- This SQL query counts the number of sales for each product
SELECT id_produit, COUNT(*) AS nombre_de_ventes
FROM ventes
GROUP BY id_produit;
</code></pre>

<p>Cette requête segmente les lignes de la table <code  class="language-sql">ventes</code> en fonction de la valeur de la colonne <code  class="language-sql">id_produit</code>. Ensuite, elle utilise <code  class="language-sql">COUNT(*)</code> pour comptabiliser le nombre de ventes associées à chaque groupe de produits. Le résultat est une table synthétisant, pour chaque produit, son identifiant (<code  class="language-sql">id_produit</code>) et le nombre total de ventes correspondant (<code  class="language-sql">nombre_de_ventes</code>).</p>

<p>Pour identifier les produits qui se vendent le *mieux*, il est nécessaire de trier les résultats par ordre décroissant du nombre de ventes, puis de limiter le nombre de résultats affichés. Pour ce faire, on utilise les clauses <code  class="language-sql">ORDER BY</code> pour le tri et <code  class="language-sql">LIMIT</code> pour restreindre le nombre de lignes retournées.</p>

<pre><code  class="language-sql">
-- This SQL query identifies the top 5 best-selling products
SELECT id_produit, COUNT(*) AS nombre_de_ventes
FROM ventes
GROUP BY id_produit
ORDER BY nombre_de_ventes DESC
LIMIT 5;
</code></pre>

<p>Cette requête renvoie les 5 produits ayant enregistré le plus grand nombre de ventes. La clause <code  class="language-sql">ORDER BY nombre_de_ventes DESC</code> assure que les résultats sont classés du nombre de ventes le plus élevé au plus faible, et <code  class="language-sql">LIMIT 5</code> garantit que seules les 5 premières lignes, représentant les 5 meilleurs produits, sont incluses dans le résultat.</p>

<p>Enfin, pour affiner davantage l'analyse, des conditions supplémentaires peuvent être ajoutées. Par exemple, il peut être pertinent d'identifier les produits les plus performants sur une période spécifique. Dans ce cas, la clause <code  class="language-sql">WHERE</code> entre en jeu pour filtrer les données selon un intervalle de dates précis.</p>

<pre><code  class="language-sql">
-- This SQL query identifies the top 5 best-selling products within a specific date range
SELECT id_produit, COUNT(*) AS nombre_de_ventes
FROM ventes
WHERE date_vente BETWEEN '2023-01-01' AND '2023-12-31'
GROUP BY id_produit
ORDER BY nombre_de_ventes DESC
LIMIT 5;
</code></pre>

<p>En conclusion, SQL offre une panoplie d'outils puissants pour l'analyse des ventes et l'identification des produits les plus populaires. Grâce à des fonctions d'agrégation comme <code  class="language-sql">COUNT()</code>, des clauses de regroupement comme <code  class="language-sql">GROUP BY</code>, de tri comme <code  class="language-sql">ORDER BY</code>, de filtrage comme <code  class="language-sql">WHERE</code> et de limitation comme <code  class="language-sql">LIMIT</code>, il est possible d'extraire des informations précieuses pour la prise de décision. Ces techniques sont indispensables pour optimiser la gestion des stocks et élaborer des stratégies marketing ciblées et efficaces.</p>
</p>
    <h3>7.2 Gestion des stocks : Suivi des niveaux de stock et identification des produits à faible stock</h3>
    <p><p>La gestion des stocks est un cas d'utilisation crucial pour SQL. Elle permet de suivre en temps réel les niveaux de stock, d'identifier rapidement les produits en rupture ou à faible stock, et d'automatiser des alertes pour le réapprovisionnement. Nous allons explorer comment réaliser ces tâches avec SQL.</p>

<p>Pour commencer, imaginons une table <code >products</code> contenant les informations sur nos produits :</p>

<pre><code  class="language-sql">
-- Table to store product information
CREATE TABLE products (
    product_id INT PRIMARY KEY,
    product_name VARCHAR(255) NOT NULL,
    stock_level INT NOT NULL,
    reorder_point INT NOT NULL,  -- Minimum stock level before reordering
    unit_price DECIMAL(10, 2) -- Price of each product
);

-- Sample data
INSERT INTO products (product_id, product_name, stock_level, reorder_point, unit_price) VALUES
(1, 'Laptop', 15, 5, 1200.00),
(2, 'Mouse', 50, 20, 25.00),
(3, 'Keyboard', 10, 8, 75.00),
(4, 'Monitor', 3, 5, 300.00);
</code></pre>

<p>Pour identifier les produits dont le niveau de stock est inférieur au point de réapprovisionnement (<code >reorder_point</code>), on utilise une simple requête avec la clause <code >WHERE</code> :</p>

<pre><code  class="language-sql">
-- Retrieve products with stock level below the reorder point
SELECT product_id, product_name, stock_level
FROM products
WHERE stock_level < reorder_point;
</code></pre>

<p>Cette requête retourne les produits nécessitant un réapprovisionnement immédiat. Pour générer un rapport plus complet, incluant le déficit de stock, on peut modifier la requête ainsi :</p>

<pre><code  class="language-sql">
-- Report showing product, stock level, reorder point, and the deficit
SELECT
    product_id,
    product_name,
    stock_level,
    reorder_point,
    (reorder_point - stock_level) AS stock_deficit
FROM
    products
WHERE
    stock_level < reorder_point;
</code></pre>

<p>On utilise ici un alias (<code >AS stock_deficit</code>) pour nommer la colonne calculée. Les fonctions d'agrégation peuvent aussi être utiles. Par exemple, pour connaître le nombre total de produits en dessous du seuil de réapprovisionnement :</p>

<pre><code  class="language-sql">
-- Count the number of products below the reorder point
SELECT COUNT(*) AS low_stock_count
FROM products
WHERE stock_level < reorder_point;
</code></pre>

<p>On peut aussi calculer la valeur totale du stock à faible niveau :</p>

<pre><code  class="language-sql">
-- Calculate the total value of low stock products
SELECT SUM(stock_level * unit_price) AS total_low_stock_value
FROM products
WHERE stock_level < reorder_point;
</code></pre>

<p>Dans cet exemple, on calcule directement la valeur totale du stock faible en utilisant la colonne <code >unit_price</code> de la table <code >products</code>. Plus besoin de jointure complexe ! Ces requêtes illustrent la puissance de SQL pour la gestion des stocks. En combinant les clauses <code >WHERE</code>, les fonctions d'agrégation, et les jointures (si nécessaire), il est possible de créer des rapports complexes et personnalisés pour optimiser le suivi et la gestion des stocks.</p>

<p>Pour une gestion des stocks encore plus avancée, on pourrait envisager d'ajouter des fonctionnalités telles que :</p>

<ul>
    <li>L'enregistrement des mouvements de stock (entrées et sorties) dans une table dédiée.</li>
    <li>Le calcul automatique des dates de péremption pour les produits concernés.</li>
    <li>L'intégration avec un système d'alerte par email pour notifier les responsables en cas de stock faible.</li>
</ul>

<p>SQL offre une base solide pour construire un système de gestion des stocks performant et adapté aux besoins spécifiques de chaque entreprise.</p>
</p>
    <h3>7.3 Analyse des données clients : Segmentation des clients en fonction de leur comportement d'achat</h3>
    <p><p>SQL est un outil puissant pour l'analyse des données clients, et la segmentation des clients en fonction de leur comportement d'achat est un cas d'utilisation courant. En utilisant des fonctions d'agrégation, la clause <code  class="language-sql">GROUP BY</code> et des sous-requêtes, nous pouvons diviser nos clients en groupes significatifs pour mieux cibler nos efforts marketing.</p>

<p>Commençons par un exemple simple. Supposons que nous ayons une table nommée <code  class="language-sql">Orders</code> qui enregistre les commandes des clients. Nous pouvons utiliser <code  class="language-sql">GROUP BY</code> et <code  class="language-sql">COUNT</code> pour déterminer le nombre de commandes passées par chaque client:</p>

<pre><code  class="language-sql">
-- Calculate the number of orders per customer
SELECT
    customer_id,
    COUNT(*) AS total_orders
FROM
    Orders
GROUP BY
    customer_id
ORDER BY
    total_orders DESC;
</code></pre>

<p>Cette requête renvoie une liste de tous les clients, classée par le nombre total de commandes qu'ils ont passées. Cela nous donne un aperçu initial de nos clients les plus fidèles.</p>

<p>Maintenant, compliquons un peu les choses. Supposons que nous voulions segmenter nos clients en fonction de la valeur totale de leurs achats. Pour ce faire, nous pouvons utiliser la fonction <code  class="language-sql">SUM</code> pour calculer la valeur totale des commandes de chaque client, puis utiliser une CTE (Common Table Expression) pour diviser les clients en segments basés sur cette valeur.</p>

<pre><code  class="language-sql">
-- Calculate total spending per customer
WITH CustomerSpending AS (
    SELECT
        customer_id,
        SUM(order_total) AS total_spending
    FROM
        Orders
    GROUP BY
        customer_id
)

-- Segment customers based on their total spending
SELECT
    customer_id,
    total_spending,
    CASE
        WHEN total_spending > 1000 THEN 'High Value'
        WHEN total_spending > 500 THEN 'Medium Value'
        ELSE 'Low Value'
    END AS customer_segment
FROM
    CustomerSpending
ORDER BY
    total_spending DESC;
</code></pre>

<p>Dans cet exemple, nous avons d'abord créé une Common Table Expression (CTE) appelée <code  class="language-sql">CustomerSpending</code> pour calculer la dépense totale de chaque client. Ensuite, nous avons utilisé une instruction <code  class="language-sql">CASE</code> pour attribuer à chaque client un segment en fonction de sa dépense totale. Les clients dépensant plus de 1000 sont classés comme "High Value", ceux dépensant entre 500 et 1000 sont "Medium Value", et les autres sont "Low Value".</p>

<p>On peut aller encore plus loin en analysant les types de produits achetés par les clients. Disons que notre table <code  class="language-sql">OrderItems</code> contient des informations sur les produits inclus dans chaque commande. Nous pouvons utiliser des fonctions d'agrégation conditionnelles pour déterminer les catégories de produits les plus populaires auprès de chaque client:</p>

<pre><code  class="language-sql">
-- Determine the most popular product category per customer
SELECT
    customer_id,
    SUM(CASE WHEN product_category = 'Electronics' THEN 1 ELSE 0 END) AS electronics_purchases,
    SUM(CASE WHEN product_category = 'Clothing' THEN 1 ELSE 0 END) AS clothing_purchases,
    SUM(CASE WHEN product_category = 'Home Goods' THEN 1 ELSE 0 END) AS home_goods_purchases
FROM
    Orders o
JOIN
    OrderItems oi ON o.order_id = oi.order_id
GROUP BY
    customer_id
ORDER BY
    customer_id;
</code></pre>

<p>Cette requête calcule le nombre d'achats dans chaque catégorie (Electronics, Clothing, Home Goods) pour chaque client. En analysant ces résultats, nous pouvons identifier les clients qui sont principalement intéressés par l'électronique, les vêtements ou les articles ménagers, ce qui nous permet de personnaliser nos campagnes marketing en conséquence. Par exemple, nous pourrions envoyer des promotions ciblées sur les nouveaux produits électroniques aux clients qui achètent fréquemment de l'électronique.</p>

<p>Pour une analyse plus avancée, on pourrait considérer la récence des achats, la fréquence des commandes, et la valeur monétaire (RFM). Ceci peut être combiné avec les catégories de produits pour créer des segments encore plus précis.</p>

<pre><code  class="language-sql">
-- Calculate RFM metrics and segment customers
WITH RFM AS (
    SELECT
        customer_id,
        MAX(order_date) AS last_order_date,
        COUNT(DISTINCT order_id) AS frequency,
        SUM(order_total) AS monetary_value
    FROM
        Orders
    GROUP BY
        customer_id
),
RFMSegments AS (
    SELECT
        customer_id,
        NTILE(5) OVER (ORDER BY last_order_date) AS recency,
        NTILE(5) OVER (ORDER BY frequency) AS frequency_segment,
        NTILE(5) OVER (ORDER BY monetary_value) AS monetary_segment
    FROM
        RFM
)
SELECT
    customer_id,
    recency,
    frequency_segment,
    monetary_segment,
    CASE
        WHEN recency = 5 AND frequency_segment = 5 AND monetary_segment = 5 THEN 'Champions'
        WHEN recency >= 4 AND frequency_segment >= 4 THEN 'Loyal Customers'
        ELSE 'Needs Attention'
    END AS customer_segment
FROM
    RFMSegments;
</code></pre>

<p>Dans cet exemple, on utilise <code  class="language-sql">NTILE</code> pour diviser les clients en quintiles basés sur la récence, la fréquence et la valeur monétaire. Ensuite, on utilise une instruction <code  class="language-sql">CASE</code> pour créer des segments basés sur ces quintiles.  Cette approche permet d'identifier facilement les clients les plus précieux.</p>

<p>En combinant ces techniques, on peut créer des segments de clientèle sophistiqués basés sur divers facteurs de comportement d'achat. Ces segments peuvent ensuite être utilisés pour améliorer le ciblage marketing, personnaliser l'expérience client et optimiser les stratégies de vente. La capacité à exploiter les données clients via SQL est essentielle pour une entreprise axée sur les données.</p>
</p>
  </section>
</div>


<div class="content_box">
  <section>
    <h2 class="heading">8. Exercices avec code et corrigés</h2>
    <p><p>Pour solidifier votre compréhension des fondamentaux SQL, nous vous proposons une série d'exercices pratiques. Chaque exercice est accompagné de son code SQL et d'une explication détaillée de la solution. Ces exercices couvrent les concepts clés que nous avons abordés, de la sélection de données au filtrage avancé, et vous aideront à développer une base solide pour travailler avec des bases de données relationnelles.</p>

<p><strong>Exercice 1: Sélectionner des données spécifiques d'une table.</strong></p>

<p>Considérons une table nommée "Clients" avec les colonnes suivantes: "ClientID", "Nom", "Ville", "Pays". L'objectif est de récupérer uniquement les noms et les villes de tous les clients. C'est une opération courante pour obtenir une vue d'ensemble rapide des données.</p>

<pre><code  class="language-sql">
-- Select the 'Nom' and 'Ville' columns from the 'Clients' table
SELECT Nom, Ville
FROM Clients;

-- This query retrieves only the specified columns, providing a focused view of the data.
-- It's more efficient than selecting all columns if you only need a subset.
</code></pre>

<p><strong>Exercice 2: Filtrer les résultats avec la clause WHERE.</strong></p>

<p>En utilisant la même table "Clients", trouvez tous les clients qui vivent à Paris. La clause <code  class="language-sql">WHERE</code> est essentielle pour extraire des informations pertinentes en fonction de critères spécifiques.</p>

<pre><code  class="language-sql">
-- Select all columns from the 'Clients' table
-- where the 'Ville' is 'Paris'
SELECT *
FROM Clients
WHERE Ville = 'Paris';

-- This query filters the rows based on a specific condition, allowing you to focus on relevant data.
-- It's a fundamental technique for data analysis and reporting.
</code></pre>

<p><strong>Exercice 3: Trier les résultats avec la clause ORDER BY.</strong></p>

<p>Récupérez tous les clients de la table "Clients", mais triez-les par ordre alphabétique de nom. L'ordre dans lequel les données sont présentées peut grandement améliorer la lisibilité et l'interprétation des résultats.</p>

<pre><code  class="language-sql">
-- Select all columns from the 'Clients' table
-- and order the results by the 'Nom' column in ascending order (A to Z)
SELECT *
FROM Clients
ORDER BY Nom ASC;

-- The 'ASC' keyword specifies ascending order. You can use 'DESC' for descending order (Z to A).
-- Ordering data is crucial for reports, user interfaces, and data analysis.
</code></pre>

<p><strong>Exercice 4: Utiliser des fonctions d'agrégation.</strong></p>

<p>Supposons que vous ayez une table "Commandes" avec les colonnes "CommandeID", "ClientID", et "Montant". Calculez le montant total de toutes les commandes. Les fonctions d'agrégation sont indispensables pour obtenir des statistiques résumées sur les données.</p>

<pre><code  class="language-sql">
-- Calculate the sum of the 'Montant' column from the 'Commandes' table
SELECT SUM(Montant) AS MontantTotal
FROM Commandes;

-- The 'SUM()' function adds up all the values in the specified column.
-- 'AS MontantTotal' gives a name to the resulting column.  This alias improves readability.
-- Other aggregation functions include AVG(), MIN(), MAX(), and COUNT().
</code></pre>

<p><strong>Exercice 5: Combiner plusieurs conditions avec AND et OR.</strong></p>

<p>En utilisant la table "Clients", trouvez tous les clients qui vivent à Paris ET dont le pays est la France, OU qui vivent à Londres. La capacité à combiner des conditions est essentielle pour des requêtes plus complexes et précises.</p>

<pre><code  class="language-sql">
-- Select all columns from the 'Clients' table
-- where the 'Ville' is 'Paris' AND 'Pays' is 'France'
-- OR where the 'Ville' is 'London'
SELECT *
FROM Clients
WHERE (Ville = 'Paris' AND Pays = 'France') OR Ville = 'London';

-- This query uses parentheses to group conditions together, ensuring correct logic.
-- Understanding operator precedence is vital for writing accurate SQL queries.
</code></pre>

<p><strong>Exercice 6: Utiliser LIKE pour la correspondance de motifs.</strong></p>

<p>Trouvez tous les clients dont le nom commence par la lettre "A" dans la table "Clients". L'opérateur <code  class="language-sql">LIKE</code> est un outil puissant pour effectuer des recherches basées sur des motifs, permettant une flexibilité accrue dans la récupération des données.</p>

<pre><code  class="language-sql">
-- Select all columns from the 'Clients' table
-- where the 'Nom' starts with the letter 'A'
SELECT *
FROM Clients
WHERE Nom LIKE 'A%';

-- The '%' wildcard represents any sequence of characters.
-- The '_' wildcard represents a single character.  'A_' would match 'Ab' or 'Ac'.
</code></pre>

<p>Ces exercices vous permettent de mettre en pratique les concepts SQL fondamentaux. N'hésitez pas à les adapter et à les complexifier pour approfondir votre apprentissage. Expérimentez avec différentes tables, colonnes, et conditions. La maîtrise de ces bases est essentielle pour travailler efficacement avec les bases de données relationnelles et construire des applications robustes et performantes.</p>
</p>
    <h3>8.1 Exercice 1: Requêtes simples</h3>
    <p><p>Dans cet exercice, nous allons apprendre à interroger une table SQL et à trier les résultats. L'objectif est d'afficher les noms et âges de tous les utilisateurs de la table 'Users', triés par ordre alphabétique de nom.</p>

<p>Supposons que nous ayons une table nommée 'Users' avec les colonnes suivantes:</p>

<ul>
    <li><code >id</code>: User unique identifier (INT, primary key)</li>
    <li><code >name</code>: User name (VARCHAR)</li>
    <li><code >age</code>: User age (INT)</li>
</ul>

<p>Pour afficher les noms et âges de tous les utilisateurs triés par ordre alphabétique de nom, nous allons utiliser la requête SQL suivante:</p>

<pre><code  class="language-sql">
SELECT name, age
FROM Users
ORDER BY name ASC;
</code></pre>

<p>Cette requête sélectionne les colonnes <code >name</code> et <code >age</code> de la table <code >Users</code>. La clause <code >ORDER BY name ASC</code> trie les résultats par la colonne <code >name</code> en ordre ascendant (alphabétique). <code >ASC</code> est l'ordre par défaut, il peut être omis. Si l'on souhaitait un tri descendant (Z à A), on utiliserait <code >ORDER BY name DESC</code>.</p>

<p>Voici un exemple d'utilisation de cette requête avec quelques données fictives:</p>

<p>Supposons que la table <code >Users</code> contienne les données suivantes:</p>

<table>
    <thead>
        <tr>
            <th>id</th>
            <th>name</th>
            <th>age</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td>1</td>
            <td>Alice</td>
            <td>30</td>
        </tr>
        <tr>
            <td>2</td>
            <td>Bob</td>
            <td>25</td>
        </tr>
        <tr>
            <td>3</td>
            <td>Charlie</td>
            <td>35</td>
        </tr>
    </tbody>
</table>

<p>L'exécution de la requête ci-dessus produira le résultat suivant:</p>

<table>
    <thead>
        <tr>
            <th>name</th>
            <th>age</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td>Alice</td>
            <td>30</td>
        </tr>
        <tr>
            <td>Bob</td>
            <td>25</td>
        </tr>
        <tr>
            <td>Charlie</td>
            <td>35</td>
        </tr>
    </tbody>
</table>

<p>Les résultats sont triés par ordre alphabétique des noms (Alice, Bob, Charlie).  Il est important de noter que SQL est insensible à la casse par défaut, donc 'Alice' et 'alice' seraient traités de la même manière. Pour un tri sensible à la casse, des fonctions spécifiques à la base de données peuvent être utilisées.</p>

<p>En résumé, cette requête simple illustre comment sélectionner des colonnes spécifiques et trier les résultats en utilisant la clause <code >ORDER BY</code>. C'est une base essentielle pour des requêtes SQL plus complexes. On peut aussi trier par plusieurs colonnes, par exemple <code >ORDER BY age DESC, name ASC</code>, ce qui trierait d'abord par âge décroissant puis, en cas d'égalité d'âge, par nom croissant.</p>
</p>
    <h3>8.2 Exercice 2: Requêtes avec jointures</h3>
    <p><p>Les jointures (JOIN) en SQL permettent de combiner des lignes de deux tables ou plus en se basant sur une colonne liée entre elles. Elles sont essentielles pour extraire des informations pertinentes réparties dans différentes tables. Dans cet exercice, nous allons utiliser les tables 'Customers' et 'Orders' pour afficher le nom de chaque client et le nombre de commandes qu'il a passées.</p>

<p>Supposons que nous ayons les tables suivantes :</p>

<p>Table <code >Customers</code>:</p>
<pre><code  class="language-sql">
CREATE TABLE Customers (
    CustomerID INT PRIMARY KEY,
    CustomerName VARCHAR(255),
    City VARCHAR(255)
);

INSERT INTO Customers (CustomerID, CustomerName, City) VALUES
(1, 'Alfreds Futterkiste', 'Berlin'),
(2, 'Ana Trujillo Emparedados y helados', 'Mexico D.F.'),
(3, 'Antonio Moreno Taquería', 'Mexico D.F.');
</code></pre>

<p>Table <code >Orders</code>:</p>

<pre><code  class="language-sql">
CREATE TABLE Orders (
    OrderID INT PRIMARY KEY,
    CustomerID INT,
    OrderDate DATE,
    FOREIGN KEY (CustomerID) REFERENCES Customers(CustomerID)
);

INSERT INTO Orders (OrderID, CustomerID, OrderDate) VALUES
(10248, 1, '1996-07-04'),
(10249, 2, '1996-07-05'),
(10250, 3, '1996-07-08'),
(10251, 1, '1996-07-08');
</code></pre>

<p>Pour afficher le nom de chaque client et le nombre de commandes qu'il a passées, nous allons utiliser une jointure <code >LEFT JOIN</code> et la fonction d'agrégation <code >COUNT()</code>. Une jointure <code >LEFT JOIN</code> retourne toutes les lignes de la table de gauche (<code >Customers</code> dans ce cas) et les lignes correspondantes de la table de droite (<code >Orders</code>). Si aucune correspondance n'est trouvée, les colonnes de la table de droite seront remplies avec la valeur <code >NULL</code>.</p>

<pre><code  class="language-sql">
SELECT
    c.CustomerName,
    COUNT(o.OrderID) AS NumberOfOrders
FROM
    Customers c
LEFT JOIN
    Orders o ON c.CustomerID = o.CustomerID
GROUP BY
    c.CustomerName;
</code></pre>

<p>Explication de la requête:</p>
<ul>
    <li><code >SELECT c.CustomerName, COUNT(o.OrderID) AS NumberOfOrders</code>: Sélectionne le nom du client de la table <code >Customers</code> (alias <code >c</code>) et compte le nombre de commandes de la table <code >Orders</code> (alias <code >o</code>). La fonction <code >COUNT(o.OrderID)</code> compte le nombre d'ID de commande pour chaque client. <code >AS NumberOfOrders</code> donne un alias à cette colonne calculée.</li>
    <li><code >FROM Customers c LEFT JOIN Orders o ON c.CustomerID = o.CustomerID</code>: Effectue une jointure gauche entre les tables <code >Customers</code> et <code >Orders</code>, en utilisant la colonne <code >CustomerID</code> comme clé de jointure. Cela garantit que tous les clients sont inclus dans le résultat, même s'ils n'ont pas passé de commandes.</li>
    <li><code >GROUP BY c.CustomerName</code>: Regroupe les résultats par nom de client, ce qui permet de compter le nombre de commandes pour chaque client individuellement.</li>
</ul>

<p>Le résultat de cette requête sera une table avec deux colonnes: 'CustomerName' et 'NumberOfOrders'. 'NumberOfOrders' représentera le nombre de commandes passées par chaque client. Si un client n'a passé aucune commande, 'NumberOfOrders' sera égal à 0.</p>

<p>Voici le résultat attendu :</p>

<pre><code  class="language-sql">
/*
CustomerName                        NumberOfOrders
----------------------------------- --------------
Alfreds Futterkiste                 2
Ana Trujillo Emparedados y helados  1
Antonio Moreno Taquería             1
*/
</code></pre>

<p>En résumé, cette requête SQL illustre comment utiliser une jointure <code >LEFT JOIN</code> combinée avec une fonction d'agrégation (<code >COUNT()</code>) et un regroupement (<code >GROUP BY</code>) pour extraire des informations synthétiques et pertinentes à partir de tables liées. Cette technique est fondamentale pour l'analyse de données et la génération de rapports en SQL.  Il est aussi possible d'utiliser d'autres types de jointures comme <code >INNER JOIN</code> ou <code >RIGHT JOIN</code> selon le besoin.  Par exemple, une <code >INNER JOIN</code> ne retournerait que les clients ayant passé au moins une commande.</p>
</p>
    <h3>8.3 Exercice 3: Requêtes avec fonctions d'agrégation</h3>
    <p><p>Les fonctions d'agrégation en SQL permettent de réaliser des calculs synthétiques sur des ensembles de données. Elles sont essentielles pour extraire des informations comme la moyenne, le nombre d'éléments, le minimum ou le maximum d'une colonne. Combinées avec la clause <code  class="language-sql">GROUP BY</code>, elles offrent une puissance analytique considérable pour étudier les données par catégories.</p>

<p>Dans cet exercice, nous allons élaborer une requête SQL pour calculer le salaire moyen des employés par département. Nous partons du principe qu'une table nommée 'Employees' existe, contenant au moins les colonnes 'department_id' et 'salary'. Pour illustrer cela en Python, nous pouvons simuler une telle table avec Pandas :</p>

<pre><code >
import pandas as pd

# Creating a sample DataFrame to represent the 'Employees' table
data = {'department_id': [1, 1, 2, 2, 3, 3],
        'salary': [50000, 60000, 70000, 80000, 90000, 100000]}
employees_df = pd.DataFrame(data)

print(employees_df)
</code></pre>

<p>La requête SQL pour calculer le salaire moyen par département est la suivante :</p>

<pre><code  class="language-sql">
-- Calculate the average salary for each department
SELECT department_id, AVG(salary) AS average_salary
FROM Employees
GROUP BY department_id;
</code></pre>

<p>La clause <code  class="language-sql">GROUP BY</code> est cruciale. Sans elle, <code  class="language-sql">AVG()</code> calculerait la moyenne de tous les salaires dans la table entière, ce qui ne répondrait pas à notre besoin d'une moyenne par département. L'alias <code  class="language-sql">average_salary</code> améliore la lisibilité du résultat, bien qu'il ne soit pas obligatoire.  Pour visualiser le résultat de cette requête en Python avec Pandas, on peut utiliser la fonction <code >groupby()</code> :</p>

<pre><code >
# Calculate the average salary for each department using Pandas
average_salaries = employees_df.groupby('department_id')['salary'].mean().reset_index()
average_salaries.rename(columns={'salary': 'average_salary'}, inplace=True)

print(average_salaries)
</code></pre>

<p>Cette requête offre une vue d'ensemble de la répartition des salaires au sein de l'organisation, mettant en évidence les départements avec des salaires moyens plus élevés ou plus bas. Ces informations sont précieuses pour des analyses approfondies, comme l'identification des facteurs contribuant aux écarts salariaux et la prise de décisions éclairées en matière de gestion des ressources humaines.  On peut aussi étendre l'analyse pour trouver le nombre d'employés dans chaque département :</p>

<pre><code  class="language-sql">
-- Calculate the average salary and number of employees for each department
SELECT department_id, AVG(salary) AS average_salary, COUNT(*) AS employee_count
FROM Employees
GROUP BY department_id;
</code></pre>

<p>En conclusion, les fonctions d'agrégation combinées à <code  class="language-sql">GROUP BY</code> sont des outils puissants pour l'analyse de données en SQL, permettant d'extraire des informations synthétiques et de comprendre les tendances au sein des ensembles de données.</p>
</p>
  </section>
</div>


<div class="content_box">
  <section>
    <h2 class="heading">9. Résumé et Comparaisons</h2>
    <p><p>Nous avons exploré ensemble les fondements de SQL, de la simple extraction de données avec <code  class="language-sql">SELECT</code> aux jointures complexes et aux fonctions d'agrégation. Cette section a pour but de solidifier ces connaissances en offrant un résumé et en comparant différentes méthodes pour résoudre des problèmes similaires.</p>

<p>Pour récapituler, voici les principaux éléments que nous avons abordés :</p>

<ul>
    <li><strong>SELECT, FROM et WHERE :</strong> L'ossature de toute requête SQL pour sélectionner des colonnes, indiquer des tables et filtrer les résultats.</li>
    <li><strong>ORDER BY :</strong> Pour organiser les résultats en fonction d'une ou de plusieurs colonnes (ascendant ou descendant).</li>
    <li><strong>GROUP BY et fonctions d'agrégation (COUNT, SUM, AVG, MIN, MAX) :</strong> Pour regrouper les lignes et calculer des statistiques sur ces groupes.</li>
    <li><strong>JOIN (INNER, LEFT, RIGHT, FULL) :</strong> Pour combiner les données de différentes tables en fonction de critères de correspondance.</li>
    <li><strong>Les sous-requêtes :</strong> Utiliser le résultat d'une requête dans une autre pour filtrer ou calculer des valeurs.</li>
</ul>

<p>Maintenant, comparons différentes manières de réaliser des opérations courantes. Prenons l'exemple de la recherche des 5 clients ayant passé le plus grand nombre de commandes. Une approche possible consiste à utiliser une sous-requête :</p>

<pre><code  class="language-sql">
-- Using a subquery to find the top 5 customers with the most orders
SELECT customer_id, COUNT(*) AS total_orders
FROM orders
GROUP BY customer_id
ORDER BY total_orders DESC
LIMIT 5;
</code></pre>

<p>Une autre méthode, employant une table temporaire (Common Table Expression - CTE), peut améliorer la lisibilité de la requête :</p>

<pre><code  class="language-sql">
-- Using a CTE to find the top 5 customers with the most orders
WITH CustomerOrderCounts AS (
    SELECT customer_id, COUNT(*) AS total_orders
    FROM orders
    GROUP BY customer_id
)
SELECT customer_id, total_orders
FROM CustomerOrderCounts
ORDER BY total_orders DESC
LIMIT 5;
</code></pre>

<p>Bien que les deux requêtes atteignent le même objectif, la version utilisant une CTE est souvent perçue comme plus claire, notamment pour les requêtes plus complexes. Le choix entre les deux dépendra de la lisibilité souhaitée et de la complexité de la requête.</p>

<p>Un autre exemple pertinent est la distinction entre l'utilisation de <code  class="language-sql">UNION</code> et <code  class="language-sql">UNION ALL</code>. <code  class="language-sql">UNION</code> élimine les doublons, tandis que <code  class="language-sql">UNION ALL</code> conserve tous les enregistrements, y compris les doublons. Si vous êtes sûr qu'il n'y a pas de doublons ou si vous souhaitez les conserver pour des raisons de performance, <code  class="language-sql">UNION ALL</code> est généralement plus rapide.</p>

<pre><code  class="language-sql">
-- Example of UNION vs UNION ALL

-- Assuming we have a table 'employees' with 'department' and 'salary' columns

-- Using UNION (removes duplicates if any)
SELECT department FROM employees WHERE salary > 50000
UNION
SELECT department FROM employees WHERE employee_id IN (SELECT manager_id FROM managers);

-- Using UNION ALL (keeps all records, including duplicates)
SELECT department FROM employees WHERE salary > 50000
UNION ALL
SELECT department FROM employees WHERE employee_id IN (SELECT manager_id FROM managers);
</code></pre>

<p>Enfin, il est essentiel de comprendre l'incidence des différents types de <code  class="language-sql">JOIN</code> sur les résultats. <code  class="language-sql">INNER JOIN</code> ne renvoie que les lignes qui correspondent dans les deux tables, tandis que <code  class="language-sql">LEFT JOIN</code> (ou <code  class="language-sql">RIGHT JOIN</code>) renvoie toutes les lignes de la table de gauche (ou de droite) et les lignes correspondantes de l'autre table.  <code  class="language-sql">FULL OUTER JOIN</code> renvoie toutes les lignes des deux tables. Sélectionner le bon type de jointure est crucial pour obtenir les données désirées et éviter des résultats inattendus.</p>

<p>En conclusion, une bonne maîtrise des bases de SQL vous permettra de créer des requêtes efficaces et de manipuler les données avec précision. La connaissance des différentes approches pour résoudre un même problème, ainsi que la comparaison de leurs avantages et inconvénients, vous aideront à optimiser vos requêtes et à choisir la solution la plus adaptée à vos besoins.</p>
</p>
    <h3>9.1 Résumé des concepts clés</h3>
    <p><p>Ce récapitulatif consolide les fondements de SQL, offrant une vue d'ensemble des commandes, clauses, fonctions d'agrégation et jointures essentielles pour manipuler et interroger des bases de données.</p>

<p>Les commandes fondamentales de manipulation de données (DML) permettent d'interagir avec les données. La commande <code  class="language-sql">SELECT</code> est utilisée pour récupérer des données. Voici un exemple de sélection de tous les champs de la table "customers" :</p>

<pre><code  class="language-sql">
-- Select all columns from the 'customers' table
SELECT * FROM customers;
</code></pre>

<p>Pour insérer de nouvelles données, on utilise <code  class="language-sql">INSERT</code>. L'exemple ci-dessous illustre l'ajout d'un nouveau client :</p>

<pre><code  class="language-sql">
-- Insert a new customer into the 'customers' table
INSERT INTO customers (first_name, last_name, email)
VALUES ('Alice', 'Tremblay', 'alice.tremblay@example.com');
</code></pre>

<p>La commande <code  class="language-sql">UPDATE</code> permet de modifier des données existantes.  L'exemple suivant met à jour l'adresse e-mail d'un client spécifique :</p>

<pre><code  class="language-sql">
-- Update the email address of a specific customer
UPDATE customers
SET email = 'alice.t@example.com'
WHERE customer_id = 123;
</code></pre>

<p>Enfin, <code  class="language-sql">DELETE</code> supprime des données.  Il est crucial d'utiliser la clause <code  class="language-sql">WHERE</code> pour éviter la suppression involontaire de toutes les données d'une table. L'exemple suivant supprime un client spécifique :</p>

<pre><code  class="language-sql">
-- Delete a specific customer from the 'customers' table
DELETE FROM customers
WHERE customer_id = 123;
</code></pre>

<p>Les clauses <code  class="language-sql">WHERE</code>, <code  class="language-sql">ORDER BY</code> et <code  class="language-sql">LIMIT</code> sont essentielles pour filtrer, trier et paginer les résultats. <code  class="language-sql">WHERE</code> filtre les lignes en fonction d'une condition spécifiée. Par exemple, pour sélectionner uniquement les clients dont le prénom commence par "A" :</p>

<pre><code  class="language-sql">
-- Select customers whose first name starts with 'A'
SELECT * FROM customers
WHERE first_name LIKE 'A%';
</code></pre>

<p><code  class="language-sql">ORDER BY</code> trie les résultats selon une ou plusieurs colonnes. L'exemple ci-dessous trie les clients par nom de famille en ordre alphabétique inversé :</p>

<pre><code  class="language-sql">
-- Select customers and order them by last name in descending order
SELECT * FROM customers
ORDER BY last_name DESC;
</code></pre>

<p><code  class="language-sql">LIMIT</code> limite le nombre de lignes retournées. Ceci est particulièrement utile pour la pagination ou pour l'échantillonnage de données. Par exemple, pour sélectionner les 10 premiers clients :</p>

<pre><code  class="language-sql">
-- Select the top 10 customers
SELECT * FROM customers
LIMIT 10;
</code></pre>

<p>Les fonctions d'agrégation permettent de calculer des statistiques.  <code  class="language-sql">COUNT</code> compte le nombre de lignes, <code  class="language-sql">SUM</code> calcule la somme des valeurs, <code  class="language-sql">AVG</code> calcule la moyenne, <code  class="language-sql">MIN</code> trouve la valeur minimale et <code  class="language-sql">MAX</code> trouve la valeur maximale. L'exemple suivant calcule le nombre total de clients :</p>

<pre><code  class="language-sql">
-- Calculate the total number of customers
SELECT COUNT(*) AS total_customers FROM customers;
</code></pre>

<p>Les jointures permettent de combiner des données provenant de plusieurs tables en fonction de relations entre elles.  <code  class="language-sql">INNER JOIN</code> retourne uniquement les lignes où il y a une correspondance entre les tables jointes. <code  class="language-sql">LEFT JOIN</code> retourne toutes les lignes de la table de gauche et les lignes correspondantes de la table de droite (avec <code  class="language-sql">NULL</code> si aucune correspondance n'est trouvée). <code  class="language-sql">RIGHT JOIN</code> est similaire à <code  class="language-sql">LEFT JOIN</code>, mais retourne toutes les lignes de la table de droite. L'exemple suivant illustre une <code  class="language-sql">INNER JOIN</code> entre les tables "customers" et "orders" :</p>

<pre><code  class="language-sql">
-- Join the 'customers' and 'orders' tables to retrieve customer order information
SELECT c.first_name, c.last_name, o.order_date
FROM customers c
INNER JOIN orders o ON c.customer_id = o.customer_id;
</code></pre>

<p>La maîtrise de ces concepts SQL fondamentaux est essentielle pour interagir efficacement avec les bases de données et extraire des informations pertinentes. Cette section a permis de rappeler les principales commandes, clauses, fonctions d'agrégation et jointures, fournissant une base solide pour la construction de requêtes SQL plus complexes et l'analyse de données.</p>
</p>
    <h3>9.2 Comparaison des dialectes SQL (MySQL, PostgreSQL, SQL Server)</h3>
    <p><p>Bien que le SQL soit normalisé, chaque Système de Gestion de Base de Données (SGBD) implémente son propre dialecte, introduisant des variations de syntaxe et des fonctionnalités spécifiques. Comprendre ces différences est crucial pour écrire du code portable et optimisé pour un SGBD particulier. Nous allons comparer ici MySQL, PostgreSQL et SQL Server, trois des SGBD les plus populaires.</p>

<p><b>Gestion des types de données:</b></p>

<p>Les types de données sont fondamentaux, mais présentent des variations subtiles. Par exemple, pour stocker des données de type date et heure:</p>

<ul>
    <li>MySQL utilise <code  class="language-sql">DATETIME</code> et <code  class="language-sql">TIMESTAMP</code>.</li>
    <li>PostgreSQL offre <code  class="language-sql">TIMESTAMP WITH TIME ZONE</code> et <code  class="language-sql">TIMESTAMP WITHOUT TIME ZONE</code> pour une gestion explicite des fuseaux horaires.</li>
    <li>SQL Server propose <code  class="language-sql">DATETIME</code>, <code  class="language-sql">DATETIME2</code> et <code  class="language-sql">DATETIMEOFFSET</code>, ce dernier incluant également les informations de fuseau horaire.</li>
</ul>

<p><b>Gestion des séquences (auto-incrémentation):</b></p>

<p>La création de séquences auto-incrémentées pour les clés primaires diffère également:</p>

<ul>
    <li>MySQL utilise <code  class="language-sql">AUTO_INCREMENT</code> lors de la création de la table.</li>
    <li>PostgreSQL utilise des séquences et la clause <code  class="language-sql">SERIAL</code> (qui crée une séquence implicitement). La clause <code  class="language-sql">SERIAL</code> est en réalité un raccourci pour la création d'une séquence et la définition de la colonne comme utilisant la valeur par défaut de cette séquence.</li>
    <li>SQL Server utilise <code  class="language-sql">IDENTITY(seed, increment)</code>.  Le paramètre <code  class="language-sql">seed</code> spécifie la valeur de départ, et <code  class="language-sql">increment</code> spécifie l'incrément pour chaque nouvelle ligne.</li>
</ul>

<p>Exemples de création de table:</p>

<pre><code  class="language-sql">
-- MySQL
CREATE TABLE employees (
    id INT AUTO_INCREMENT PRIMARY KEY,
    name VARCHAR(255)
);

-- PostgreSQL
CREATE TABLE employees (
    id SERIAL PRIMARY KEY,
    name VARCHAR(255)
);

-- SQL Server
CREATE TABLE employees (
    id INT IDENTITY(1,1) PRIMARY KEY,
    name VARCHAR(255)
);
</code></pre>

<p><b>Fonctions de manipulation de chaînes de caractères:</b></p>

<p>Les fonctions de manipulation de chaînes varient également. Par exemple, pour concaténer des chaînes:</p>

<ul>
    <li>MySQL utilise <code  class="language-sql">CONCAT()</code>.</li>
    <li>PostgreSQL utilise l'opérateur <code  class="language-sql">||</code> ou la fonction <code  class="language-sql">CONCAT()</code>. L'opérateur <code  class="language-sql">||</code> est le moyen privilégié pour la concaténation dans PostgreSQL.</li>
    <li>SQL Server utilise l'opérateur <code  class="language-sql">+</code> ou la fonction <code  class="language-sql">CONCAT()</code>. Notez que l'opérateur <code  class="language-sql">+</code> peut entraîner des comportements inattendus si l'une des valeurs est NULL.</li>
</ul>

<p>Exemples de concaténation:</p>

<pre><code  class="language-sql">
-- MySQL
SELECT CONCAT(first_name, ' ', last_name) AS full_name FROM users;

-- PostgreSQL
SELECT first_name || ' ' || last_name AS full_name FROM users;
SELECT CONCAT(first_name, ' ', last_name) AS full_name FROM users;

-- SQL Server
SELECT first_name + ' ' + last_name AS full_name FROM users;
SELECT CONCAT(first_name, ' ', last_name) AS full_name FROM users;
</code></pre>

<p><b>Gestion des transactions:</b></p>

<p>Bien que les commandes de base soient similaires (<code  class="language-sql">START TRANSACTION</code>, <code  class="language-sql">COMMIT</code>, <code  class="language-sql">ROLLBACK</code>), les niveaux d'isolation par défaut et les options de configuration peuvent différer, affectant la concurrence et la cohérence des données. Par exemple, la configuration de l'isolation des transactions peut se faire différemment:</p>
<ul>
<li>MySQL: <code  class="language-sql">SET TRANSACTION ISOLATION LEVEL READ COMMITTED;</code></li>
<li>PostgreSQL: <code  class="language-sql">SET TRANSACTION ISOLATION LEVEL READ COMMITTED;</code></li>
<li>SQL Server: <code  class="language-sql">SET TRANSACTION ISOLATION LEVEL READ COMMITTED;</code></li>
</ul>
<p>Il est important de noter que les niveaux d'isolation par défaut varient entre les SGBD. MySQL utilise <code  class="language-sql">REPEATABLE READ</code> par défaut (avec certaines nuances selon le moteur de stockage), PostgreSQL utilise <code  class="language-sql">READ COMMITTED</code>, et SQL Server utilise également <code  class="language-sql">READ COMMITTED</code>.</p>

<p><b>Fonctionnalités avancées:</b></p>

<p>Chaque SGBD propose des fonctionnalités avancées spécifiques:</p>

<ul>
    <li>MySQL se distingue par sa simplicité et sa performance en lecture, souvent utilisé pour les applications web. Il excelle dans les environnements nécessitant une haute disponibilité et une scalabilité horizontale.</li>
    <li>PostgreSQL est réputé pour sa conformité aux standards SQL, son extensibilité (types de données personnalisés, fonctions) et ses fonctionnalités avancées comme le support natif des types JSON et les index géospatiaux.  Son architecture robuste et sa gestion avancée de la concurrence en font un choix populaire pour les applications complexes et les charges de travail transactionnelles lourdes.</li>
    <li>SQL Server est fortement intégré à l'écosystème Microsoft et offre des outils d'analyse et de reporting robustes (SSAS, SSRS, SSIS). Il est également connu pour ses fonctionnalités de sécurité avancées et ses performances optimisées pour les environnements Windows.</li>
</ul>

<p>En résumé, bien que le SQL partage un noyau commun, les dialectes de MySQL, PostgreSQL et SQL Server présentent des différences significatives en termes de types de données, de fonctions, de gestion des transactions et de fonctionnalités avancées. Le choix du SGBD dépendra donc des besoins spécifiques du projet, des contraintes de performance, de l'écosystème technologique existant et des compétences de l'équipe.</p>
</p>
    <h3>9.3 Meilleures pratiques pour écrire du code SQL efficace</h3>
    <p><p>L'écriture d'un code SQL efficace est cruciale pour la performance des applications et la gestion des ressources. Voici quelques meilleures pratiques pour optimiser vos requêtes et éviter les pièges courants.</p>

<p><strong>Utiliser <code  class="language-sql">WHERE</code> pour filtrer les données dès le début:</strong> Restreindre le nombre de lignes que la base de données doit traiter peut considérablement accélérer les requêtes. Évitez de charger de grandes quantités de données pour ensuite les filtrer côté application.  Cela réduit la quantité de données transférée et le travail du serveur de base de données.</p>

<pre><code  class="language-sql">
-- Inefficient: selecting all columns and rows, then filtering in the application.
SELECT * FROM orders;

-- Efficient: filtering the data at the database level.
SELECT * FROM orders WHERE order_date BETWEEN '2023-01-01' AND '2023-03-31';
</code></pre>

<p><strong>Éviter <code  class="language-sql">SELECT *</code> :</strong> Spécifiez toujours les colonnes dont vous avez besoin. <code  class="language-sql">SELECT *</code> peut ralentir les requêtes, surtout avec les tables larges, et peut introduire des problèmes si la structure de la table change.  De plus, cela augmente la quantité de données transférée inutilement sur le réseau.</p>

<pre><code  class="language-sql">
-- Inefficient: selecting all columns.
SELECT * FROM customers;

-- Efficient: selecting only the required columns.
SELECT customer_id, customer_name, city FROM customers;
</code></pre>

<p><strong>Exploiter les index :</strong> Les index accélèrent les recherches de données. Assurez-vous que les colonnes fréquemment utilisées dans les clauses <code  class="language-sql">WHERE</code>, <code  class="language-sql">JOIN</code> et <code  class="language-sql">ORDER BY</code> sont indexées. Cependant, il faut éviter de sur-indexer une table, car chaque index ajoute une charge supplémentaire lors des opérations d'écriture (INSERT, UPDATE, DELETE).</p>

<pre><code  class="language-sql">
-- Create an index on the 'product_name' column.
CREATE INDEX idx_product_name ON products (product_name);

-- Query that benefits from the index.
SELECT product_id, product_name FROM products WHERE product_name = 'Laptop';
</code></pre>

<p><strong>Optimiser les <code  class="language-sql">JOIN</code> :</strong> L'ordre des tables dans un <code  class="language-sql">JOIN</code> peut affecter les performances. En général, commencez par la table la plus petite et joignez-la à des tables plus grandes en utilisant des colonnes indexées. Privilégiez <code  class="language-sql">INNER JOIN</code> lorsque c'est possible, car ils sont souvent plus performants que <code  class="language-sql">LEFT JOIN</code> ou <code  class="language-sql">RIGHT JOIN</code>. Lorsque vous utilisez des <code  class="language-sql">LEFT JOIN</code>, assurez-vous que la table de gauche est la plus petite, et que vous filtrez sur la table de droite dans la clause <code  class="language-sql">WHERE</code> pour améliorer les performances.</p>

<pre><code  class="language-sql">
-- Assuming 'orders' is smaller than 'customers'.
-- And both 'orders.customer_id' and 'customers.customer_id' are indexed.
SELECT o.order_id, c.customer_name
FROM orders o
INNER JOIN customers c ON o.customer_id = c.customer_id;
</code></pre>

<p><strong>Éviter les fonctions dans la clause <code  class="language-sql">WHERE</code> :</strong> L'utilisation de fonctions sur les colonnes dans la clause <code  class="language-sql">WHERE</code> peut empêcher l'utilisation des index. Si possible, effectuez les calculs sur la valeur de recherche plutôt que sur la colonne de la table. Si vous devez absolument utiliser une fonction, envisagez de créer une colonne calculée et de l'indexer.</p>

<pre><code  class="language-sql">
-- Inefficient: function applied to the column.
SELECT * FROM orders WHERE YEAR(order_date) = 2023;

-- Efficient: function applied to the value. Requires pre-calculation in the application.
-- Assuming we have a column 'order_year' that is indexed.
SELECT * FROM orders WHERE order_year = 2023;
</code></pre>

<p><strong>Gérer les transactions :</strong> Utilisez des transactions pour grouper des opérations liées et assurer la cohérence des données. Validez (commit) les transactions rapidement pour libérer les ressources et éviter les blocages. Utilisez le niveau d'isolation approprié à votre besoin (par exemple, éviter le niveau d'isolation "serializable" si possible, car il est plus coûteux). Une bonne gestion des transactions est cruciale pour maintenir l'intégrité des données, surtout dans les environnements multi-utilisateurs.</p>

<pre><code  class="language-sql">
-- Start a transaction.
START TRANSACTION;

-- Update the inventory.
UPDATE products SET quantity = quantity - 1 WHERE product_id = 123;

-- Record the sale.
INSERT INTO sales (product_id, sale_date) VALUES (123, NOW());

-- Commit the transaction.
COMMIT;
</code></pre>

<p><strong>Utiliser <code  class="language-sql">EXISTS</code> au lieu de <code  class="language-sql">COUNT</code>:</strong> Pour vérifier l'existence de données, <code  class="language-sql">EXISTS</code> est généralement plus performant que <code  class="language-sql">COUNT(*)</code>, car il s'arrête dès qu'il trouve une correspondance.</p>

<pre><code  class="language-sql">
-- Inefficient: Counting all rows.
SELECT * FROM customers WHERE (SELECT COUNT(*) FROM orders WHERE orders.customer_id = customers.customer_id) > 0;

-- Efficient: Checking only for existence.
SELECT * FROM customers WHERE EXISTS (SELECT 1 FROM orders WHERE orders.customer_id = customers.customer_id);
</code></pre>

<p>En appliquant ces pratiques, vous pouvez améliorer significativement la performance de vos requêtes SQL et optimiser l'utilisation des ressources de votre base de données.  N'oubliez pas de surveiller régulièrement les performances de vos requêtes et d'ajuster vos stratégies en conséquence.</p>
</p>
  </section>
</div>


<div class="content_box">
  <section>
    <h2 class="heading">Conclusion</h2>
    <p><p>Nous avons exploré ensemble les fondements de SQL, des commandes de base pour interroger (<code  class="language-sql">SELECT</code>) et filtrer (<code  class="language-sql">WHERE</code>) les données, jusqu'aux jointures et sous-requêtes. Ces outils, utilisés avec rigueur, transforment les données brutes en informations exploitables et permettent d'extraire des indicateurs clés.</p>

<p>La manipulation efficace des données est essentielle dans de nombreux contextes. Considérons une application d'e-commerce où l'on souhaite identifier les meilleurs clients du mois précédent. On peut combiner plusieurs concepts SQL pour répondre à ce besoin :</p>

<pre><code  class="language-sql">
-- This query identifies the top 5 customers by total spending in the last month
SELECT customer_id, SUM(order_total) AS total_spent
FROM orders
WHERE order_date >= DATE('now', '-1 month')
GROUP BY customer_id
ORDER BY total_spent DESC
LIMIT 5;
</code></pre>

<p>Cet exemple illustre l'utilisation combinée de <code  class="language-sql">SELECT</code>, <code  class="language-sql">SUM()</code>, <code  class="language-sql">WHERE</code>, <code  class="language-sql">GROUP BY</code>, <code  class="language-sql">ORDER BY</code> et <code  class="language-sql">LIMIT</code> pour répondre à une question métier précise. La fonction <code  class="language-sql">DATE('now', '-1 month')</code>, spécifique à SQLite, sélectionne uniquement les commandes du mois précédent. L'alias <code  class="language-sql">total_spent</code> améliore la lisibilité du résultat. Il est important de noter que d'autres systèmes de gestion de bases de données (SGBD) peuvent utiliser une syntaxe différente pour la gestion des dates. Par exemple, MySQL utilise <code  class="language-sql">DATE_SUB(CURDATE(), INTERVAL 1 MONTH)</code>.</p>

<p>Pour consolider vos connaissances, rien ne remplace la pratique. Entraînez-vous sur différentes bases de données, explorez des requêtes complexes et n'hésitez pas à expérimenter avec des données réelles. La maîtrise de SQL est un atout majeur dans de nombreux domaines, ouvrant la voie à une analyse approfondie des données et à une meilleure compréhension du monde qui nous entoure.</p>
</p>
  </section>
</div>


<!-- End of Course Marker -->
<div class="course-end-marker" style="margin: 4rem auto; text-align: center; max-width: 600px">
  <div style="height: 2px; background: linear-gradient(90deg, transparent, #fb5168 50%, transparent); margin: 2rem auto;"></div>
  <p style="color: #fb5168; font-size: 1.2rem; font-weight: 500; letter-spacing: 1px; opacity: 0.9;">
    That's all folks
  </p>
</div></div>
    </main>

    <!-- (Non-critical JS after DOM parsing) -->
    <script src="/src/js/back-to-top.js" type="module" defer></script>
    <script src="/src/js/include-footer.js" type="module" defer></script>
    <script src="/src/js/include-navbar.js" type="module" defer></script>
    <script src="/src/js/include-course-navbar.js" type="module" defer></script>
    <script src="/src/js/include-mobile-course-navbar.js" type="module" defer></script>
    <script src="/src/js/slider.js" type="module" defer></script>
    <script src="/src/js/copy-code-button.js" type="module" defer></script>
    <!-- (Non-critical JS after DOM parsing) -->

 </body>
</html>