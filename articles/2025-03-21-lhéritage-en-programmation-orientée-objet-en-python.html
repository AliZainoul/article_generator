<!DOCTYPE html>
<html class="style-orange-3 custom_fonts comps live_website" lang="fr">
  <head>
    <!------------------- Essential Meta Tags ------------------>    
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta property="og:type" content="website" />
    <!------------------- Essential Meta Tags ------------------>    

    <!-------------------- Core SEO Elements -------------------->    
    <!-- Essential Title and SEO Meta Tags PLACEHOLDER -->
    <title>L'héritage en Programmation Orientée Objet en Python | Formateur</title>
    <meta name="description" content="Découvrez tout sur L'héritage en Programmation Orientée Objet en Python dans cet article détaillé." />
    <meta property="og:title" content="L'héritage en Programmation Orientée Objet en Python | Formateur" />
    <meta property="og:description" content="Découvrez tout sur L'héritage en Programmation Orientée Objet en Python dans cet article détaillé." />
    <meta name="twitter:title" content="L'héritage en Programmation Orientée Objet en Python | Formateur" />
    <meta name="twitter:description" content="Découvrez tout sur L'héritage en Programmation Orientée Objet en Python dans cet article détaillé." />
    <!-- Essential Title and SEO Meta Tags PLACEHOLDER -->
    <!-------------------- Core SEO Elements -------------------->    

    <!-- Structured Data PLACEHOLDER -->
    <!-- Structured Data -->

    <!-- End Structured Data -->
    <!-- Structured Data PLACEHOLDER -->

    <!-------------- Canonical and Alternate Links PLACEHOLDER ------------->
    <!-------------- Canonical and Alternate Links ------------->

    <!-------------- Canonical and Alternate Links ------------->
    <!-------------- Canonical and Alternate Links PLACEHOLDER ------------->

    <!----------------- Favicon and Assets ------------------->
    <!-- Favicon and Social Media Images -->
    <link
      rel="icon"
      type="image/png"
      href="https://www.clearcode.fr/assets/icons/favicon.ico"
      sizes="48x48"
    />
    <meta
      property="og:image"
      content="https://www.clearcode.fr/assets/images/og-image.png"
    />
    <meta property="og:image:width" content="1200" />
    <meta property="og:image:height" content="630" />
    <meta
      property="og:image:alt"
      content="ClearCode - Formations en mathématiques et programmation IT"
    />
    <meta property="og:image:type" content="image/png" />
    <!-- Fallback image format -->
    <meta
      property="og:image"
      content="https://www.clearcode.fr/assets/images/og-image.webp"
    />
    <meta
      name="twitter:image"
      content="https://www.clearcode.fr/assets/images/og-image.png"
    />
    <!----------------- Favicon and Assets ------------------->

    <script src="/src/js/code-preprocessor.js"></script>

    <!-- Stylesheets -->
    <link rel="stylesheet" href="/src/css/main.css" />
    <link rel="stylesheet" href="/src/css/dropdown.css" />
    <link rel="stylesheet" href="/src/css/mobile-course-navbar.css" />

    <!-- Prism.js core script -->
    <script
      src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"
      defer
    ></script>
    <!-- Prism.js language support for Python -->
    <script
      src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-python.min.js"
      defer
    ></script>
    <script 
      src="/src/js/reduce-prism-dom.js" 
      defer>
    </script>


    <!-- Python Code CSS -->
    <link rel="stylesheet" href="/src/css/python-code.css" />

    <!-- Scripts -->
  </head>

  <body class="comps">
    <main class="container">
      <!-- 0. TITRE -->
      <div class="content_box">
        <h1 class="heading heading--accent">L'héritage en Programmation Orientée Objet en Python</h1>
      </div>

<div class="content_box">
  <section>
    <h2 class="heading">Introduction</h2>
    <p><p>L'héritage est un concept central de la programmation orientée objet (POO) en Python. Il permet à une classe, appelée classe enfant ou sous-classe (<em>child class</em> ou <em>subclass</em>), d'acquérir les propriétés (attributs) et le comportement (méthodes) d'une autre classe, désignée comme classe parent ou super-classe (<em>parent class</em> ou <em>superclass</em>). Ce mécanisme puissant est un pilier de la réutilisation du code, réduisant la duplication et facilitant la création de hiérarchies de classes complexes.</p>

<p>En Python, l'implémentation de l'héritage est simple et intuitive grâce à une syntaxe claire. Lors de la définition d'une classe enfant, la classe parent est spécifiée entre parenthèses. La classe enfant peut ensuite redéfinir (<em>override</em>) les méthodes héritées de la classe parent pour adapter son comportement, ou ajouter de nouveaux attributs et méthodes spécifiques. Cette flexibilité permet un contrôle précis de la spécialisation des classes.</p>

<p>Pour illustrer le concept, prenons l'exemple d'une classe <code class="language-python">Animal</code> avec des attributs comme <code class="language-python">nom</code> (name) et <code class="language-python">age</code>, et une méthode <code class="language-python">faire_bruit()</code> (make_sound). On peut alors définir une classe <code class="language-python">Chien</code> (Dog) qui hérite de <code class="language-python">Animal</code> et redéfinit la méthode <code class="language-python">faire_bruit()</code> pour afficher "Wouf !". De même, une classe <code class="language-python">Chat</code> (Cat) peut hériter de <code class="language-python">Animal</code> et redéfinir <code class="language-python">faire_bruit()</code> pour afficher "Miaou !". Voici un aperçu du code correspondant :</p>

<pre><code class="language-python">
class Animal:
    def __init__(self, name, age):
        # Initialize the attributes of the Animal class
        self.name = name
        self.age = age

    def make_sound(self):
        # Generic sound for an animal
        print("Bruit générique d'animal")

class Dog(Animal):
    def make_sound(self):
        # Dog-specific sound
        print("Wouf !")

class Cat(Animal):
    def make_sound(self):
        # Cat-specific sound
        print("Miaou !")

my_dog = Dog("Rex", 3)
my_cat = Cat("Minou", 5)

my_dog.make_sound()  # Output: Wouf !
my_cat.make_sound()  # Output: Miaou !
</code></pre>

<p>Python propose différents types d'héritage, chacun adapté à des situations spécifiques. Nous allons explorer en détail les cinq principaux types : l'héritage simple (<em>single inheritance</em>), l'héritage multiple (<em>multiple inheritance</em>), l'héritage multi-niveau (<em>multilevel inheritance</em>), l'héritage hiérarchique (<em>hierarchical inheritance</em>) et l'héritage hybride (<em>hybrid inheritance</em>). Des exemples concrets illustreront les avantages et les inconvénients de chaque approche, ainsi que des conseils pratiques pour choisir la solution la plus appropriée à vos besoins.</p>

<p>La compréhension des différents types d'héritage est cruciale pour la conception d'applications POO robustes, flexibles et maintenables en Python. En maîtrisant ces concepts, vous serez en mesure de créer des hiérarchies de classes élégantes et efficaces, exploitant pleinement les avantages de la programmation orientée objet.</p>
</p>
  </section>
</div>


<div class="content_box">
  <section>
    <h2 class="heading">1. Les bases de l'héritage en Python</h2>
    <p><p>L'héritage est un pilier de la programmation orientée objet (POO) qui permet à une classe (appelée classe enfant, sous-classe ou classe dérivée) d'acquérir les attributs et les méthodes d'une autre classe (appelée classe parent ou super-classe). Il s'agit d'un mécanisme puissant pour la réutilisation du code, la réduction de la redondance et l'établissement d'une relation "est-un" entre les classes.  En Python, l'implémentation de l'héritage est particulièrement intuitive.</p>

<p>Pour illustrer le concept d'héritage, prenons l'exemple des formes géométriques.  Nous définirons une classe parent <code class="language-python">Shape</code> et des classes enfants telles que <code class="language-python">Rectangle</code> et <code class="language-python">Circle</code> qui hériteront de <code class="language-python">Shape</code>.</p>

<pre><code class="language-python">
# Define the parent class Shape
class Shape:
    def __init__(self, color):
        # Initialize the color attribute
        self.color = color

    def describe(self):
        # Method to describe the shape
        return f"This shape is {self.color}"

# Define the child class Rectangle inheriting from Shape
class Rectangle(Shape):
    def __init__(self, color, width, height):
        # Call the constructor of the parent class using super()
        super().__init__(color)
        # Initialize the Rectangle specific attributes
        self.width = width
        self.height = height

    def area(self):
        # Method to calculate the area of the rectangle
        return self.width * self.height

    def describe(self):
        # Override the describe method of the parent class
        return f"This rectangle is {self.color}, width: {self.width}, height: {self.height}"

# Create an instance of Rectangle
my_rectangle = Rectangle("blue", 5, 10)

# Access attributes and methods of the Rectangle instance
print(my_rectangle.describe())  # Output: This rectangle is blue, width: 5, height: 10
print(my_rectangle.area())       # Output: 50
</code></pre>

<p>Dans cet exemple, la classe <code class="language-python">Rectangle</code> hérite de la classe <code class="language-python">Shape</code>. Le mot-clé <code class="language-python">super()</code> est utilisé pour appeler le constructeur de la classe parent, assurant ainsi l'initialisation correcte de l'attribut <code class="language-python">color</code> hérité. La classe <code class="language-python">Rectangle</code> introduit également ses propres attributs, <code class="language-python">width</code> et <code class="language-python">height</code>, ainsi que sa propre méthode, <code class="language-python">area</code>.  De plus, la méthode <code class="language-python">describe()</code> est redéfinie (on dit aussi "surchargée" ou "override") dans la classe enfant pour fournir une description plus spécifique et adaptée à un rectangle.</p>

<p>L'héritage permet de structurer le code en une hiérarchie de classes, où les classes enfants héritent des caractéristiques communes de leurs classes parentes tout en pouvant implémenter leurs propres comportements spécifiques.  Il s'agit d'un outil puissant pour la modularisation et la réutilisation du code dans le cadre de projets de programmation orientée objet.</p>

<p>En conclusion, l'héritage en Python est un mécanisme à la fois simple et puissant pour créer de nouvelles classes basées sur des classes existantes, ce qui encourage la réutilisation du code et la création de hiérarchies de classes bien définies et maintenables. La maîtrise de l'héritage est fondamentale pour quiconque souhaite développer des applications robustes et bien structurées en Python.</p>
</p>
    <h3>1.1 Définition de l'héritage</h3>
    <p><p>L'héritage est un pilier de la programmation orientée objet (POO) qui permet à une classe (la <strong>classe enfant</strong>, ou <strong>sous-classe</strong>) de dériver des caractéristiques d'une autre classe (la <strong>classe parent</strong>, ou <strong>super-classe</strong>). Concrètement, la classe enfant acquiert les attributs et les méthodes de sa classe parent, favorisant ainsi la réutilisation du code et la création de hiérarchies de classes bien définies.</p>

<p>L'un des principaux avantages de l'héritage est la réduction de la duplication de code. En structurant les classes de manière hiérarchique, les classes enfants peuvent se spécialiser et étendre les fonctionnalités des classes parents, sans avoir à réécrire le code existant. Cela améliore l'organisation, la maintenabilité et la modularité du code. En Python, l'héritage s'implémente en spécifiant la classe parent entre parenthèses lors de la définition de la classe enfant, comme ceci: <code class="language-python">class Enfant(Parent):</code>.</p>

<p>Pour illustrer l'héritage en Python, prenons l'exemple d'une classe de base <code class="language-python">Vehicle</code>, représentant un véhicule générique. Cette classe pourrait avoir des attributs comme <code class="language-python">brand</code> (marque) et <code class="language-python">model</code> (modèle), et une méthode <code class="language-python">display_info()</code> pour afficher ces informations. Ensuite, nous pouvons créer des classes enfants comme <code class="language-python">Car</code> (voiture) et <code class="language-python">Motorcycle</code> (moto) qui héritent de <code class="language-python">Vehicle</code>, tout en ajoutant des attributs et méthodes spécifiques à chaque type de véhicule.</p>

<pre><code class="language-python">
# Define the parent class Vehicle
class Vehicle:
    def __init__(self, brand, model):
        # Initialize the brand and model attributes
        self.brand = brand
        self.model = model

    def display_info(self):
        # Display the brand and model of the vehicle
        print(f"Brand: {self.brand}, Model: {self.model}")

# Define the child class Car inheriting from Vehicle
class Car(Vehicle):
    def __init__(self, brand, model, num_doors):
        # Call the constructor of the parent class to initialize inherited attributes
        super().__init__(brand, model)
        # Add a specific attribute for Car: number of doors
        self.num_doors = num_doors

    def display_car_info(self):
        # Display car information, including the number of doors
        print(f"Brand: {self.brand}, Model: {self.model}, Number of doors: {self.num_doors}")

# Define the child class Motorcycle inheriting from Vehicle
class Motorcycle(Vehicle):
    def __init__(self, brand, model, has_sidecar):
        # Call the constructor of the parent class
        super().__init__(brand, model)
        # Add a specific attribute for Motorcycle: presence of a sidecar
        self.has_sidecar = has_sidecar

    def display_motorcycle_info(self):
        # Display motorcycle information, including whether it has a sidecar
        print(f"Brand: {self.brand}, Model: {self.model}, Has sidecar: {self.has_sidecar}")

# Create instances of the classes
my_car = Car("Toyota", "Corolla", 4)
my_motorcycle = Motorcycle("Harley-Davidson", "Sportster", False)

# Call the methods to display information
my_car.display_car_info()
my_motorcycle.display_motorcycle_info()
</code></pre>

<p>Dans cet exemple, les classes <code class="language-python">Car</code> et <code class="language-python">Motorcycle</code> héritent des attributs <code class="language-python">brand</code> et <code class="language-python">model</code> de la classe <code class="language-python">Vehicle</code>.  Elles ajoutent également leurs propres attributs spécifiques: <code class="language-python">num_doors</code> pour <code class="language-python">Car</code> et <code class="language-python">has_sidecar</code> pour <code class="language-python">Motorcycle</code>.  La fonction <code class="language-python">super()</code> est cruciale ici : elle permet d'appeler le constructeur de la classe parent (<code class="language-python">Vehicle</code>) depuis le constructeur des classes enfants, assurant ainsi que les attributs hérités sont correctement initialisés.</p>

<p>En résumé, l'héritage est un mécanisme puissant de la POO qui facilite la structuration hiérarchique du code, encourage la réutilisation du code existant et minimise la duplication.  Il en résulte un code plus clair, plus facile à maintenir et plus adaptable aux évolutions futures.</p>
</p>
    <h3>1.2 Syntaxe de l'héritage en Python</h3>
    <p><p>L'héritage en Python permet de créer de nouvelles classes (classes filles) à partir de classes existantes (classes mères ou classes de base). Cette fonctionnalité encourage la réutilisation du code et la création de hiérarchies de classes, facilitant ainsi la modélisation de systèmes complexes. La syntaxe de l'héritage est simple et intuitive.</p>

<p>La forme générale de la déclaration d'une classe enfant qui hérite d'une classe parent est la suivante:</p>

<pre><code class="language-python">
class ChildClass(ParentClass):
    # Class attributes and methods here
    pass
</code></pre>

<p>La classe enfant, <code class="language-python">ChildClass</code>, hérite de tous les attributs et méthodes publics de la classe parent, <code class="language-python">ParentClass</code>. Cela signifie que la classe enfant possède automatiquement les mêmes caractéristiques et comportements que la classe parent, mais peut également les étendre, les modifier (surcharge), ou ajouter de nouvelles fonctionnalités. L'héritage est un mécanisme clé de la programmation orientée objet pour établir une relation "est-un" entre les classes.</p>

<p>Voici un exemple concret pour illustrer l'héritage en Python :</p>

<pre><code class="language-python">
class ElectronicDevice:
    def __init__(self, brand, model):
        self.brand = brand
        self.model = model

    def turn_on(self):
        print("The device is turning on.")

    def turn_off(self):
        print("The device is turning off.")


class SmartPhone(ElectronicDevice):
    def __init__(self, brand, model, operating_system):
        # Call the constructor of the parent class using super()
        super().__init__(brand, model)
        self.operating_system = operating_system

    def install_app(self, app_name):
        print(f"Installing {app_name} on {self.brand} {self.model} ({self.operating_system}).")

    # Override the turn_on method
    def turn_on(self):
        print(f"The {self.brand} {self.model} is booting up with {self.operating_system}...")


# Create an instance of the SmartPhone class
my_phone = SmartPhone("Samsung", "Galaxy S23", "Android")

# Access attributes and methods from both the parent and child classes
print(my_phone.brand)  # Output: Samsung
my_phone.turn_on()       # Output: The Samsung Galaxy S23 is booting up with Android...
my_phone.install_app("WhatsApp")  # Output: Installing WhatsApp on Samsung Galaxy S23 (Android).
</code></pre>

<p>Dans cet exemple, la classe <code class="language-python">SmartPhone</code> hérite de la classe <code class="language-python">ElectronicDevice</code>. La méthode <code class="language-python">super().__init__(brand, model)</code> dans le constructeur de <code class="language-python">SmartPhone</code> appelle le constructeur de la classe parent, assurant que les attributs hérités ( <code class="language-python">brand</code> et <code class="language-python">model</code>) sont correctement initialisés.  La classe <code class="language-python">SmartPhone</code> ajoute également un attribut spécifique, <code class="language-python">operating_system</code>, et une méthode, <code class="language-python">install_app</code>. De plus, la méthode <code class="language-python">turn_on</code> est redéfinie (surchargée) dans la classe <code class="language-python">SmartPhone</code> pour fournir un comportement spécifique aux téléphones.</p>

<p>En résumé, l'héritage en Python est implémenté en spécifiant la classe parent entre parenthèses lors de la définition de la classe enfant. La fonction <code class="language-python">super()</code> facilite l'appel des méthodes de la classe parent. La classe enfant hérite de tous les attributs et méthodes publics de la classe parent, permettant ainsi la réutilisation de code, l'extension des fonctionnalités, et la création de hiérarchies de classes bien structurées. L'héritage est un outil puissant pour organiser et structurer le code en programmation orientée objet.</p>
</p>
    <h3>1.3 La fonction `super()`</h3>
    <p><p>La fonction <code class="language-python">super()</code> en Python permet d'accéder aux méthodes de la classe parente (ou des classes parentes dans le cas d'héritage multiple) depuis une classe enfant. Elle est essentielle pour réutiliser et étendre les fonctionnalités des classes parentes, tout en évitant la duplication de code et en assurant une initialisation correcte.</p>

<p>L'utilisation la plus fréquente de <code class="language-python">super()</code> se trouve dans la méthode <code class="language-python">__init__()</code> d'une classe enfant. Cela garantit que les attributs de la classe parente sont correctement initialisés avant que la classe enfant n'ajoute ses propres attributs ou ne modifie ceux hérités. Voici un exemple typique :</p>

<pre><code class="language-python">
class Parent:
    def __init__(self, name, age):
        # Constructor of the Parent class
        self.name = name
        self.age = age

    def display_info(self):
        # Method to display information about the parent
        print(f"Name: {self.name}, Age: {self.age}")

class Child(Parent):
    def __init__(self, name, age, school):
        # Call the parent's __init__ method using super()
        super().__init__(name, age)
        # Initialize the Child's specific attribute
        self.school = school

    def display_info(self):
        # Call the parent's display_info method using super()
        super().display_info()
        # Add information specific to the Child
        print(f"School: {self.school}")

# Create an instance of the Child class
child = Child("Alice", 10, "Example School")
child.display_info()
</code></pre>

<p>Dans cet exemple, <code class="language-python">super().__init__(name, age)</code> dans la classe <code class="language-python">Child</code> appelle le constructeur de la classe <code class="language-python">Parent</code>, ce qui initialise <code class="language-python">self.name</code> et <code class="language-python">self.age</code>. Ensuite, le constructeur de <code class="language-python">Child</code> initialise l'attribut <code class="language-python">self.school</code>, spécifique à la classe enfant. De même, la méthode <code class="language-python">display_info()</code> de la classe <code class="language-python">Child</code> utilise <code class="language-python">super().display_info()</code> pour appeler la méthode <code class="language-python">display_info()</code> de la classe <code class="language-python">Parent</code> avant d'afficher les informations relatives à l'école.</p>

<p>L'utilité de <code class="language-python">super()</code> ne se limite pas à l'initialisation. Elle peut être utilisée pour appeler n'importe quelle méthode de la classe parente, permettant ainsi d'étendre ou de modifier le comportement de cette méthode sans avoir à réécrire tout son code. Cela favorise la réutilisation du code et réduit les risques d'erreurs.</p>

<pre><code class="language-python">
class Calculator:
    def add(self, x, y):
        # Method to add two numbers
        return x + y

class ScientificCalculator(Calculator):
    def add(self, x, y):
        # Call the add method of the parent class using super()
        result = super().add(x, y)
        # Add additional functionality: printing the result
        print(f"Adding {x} and {y} results in {result}")
        return result

# Create an instance of the ScientificCalculator class
scientific_calc = ScientificCalculator()
scientific_calc.add(5, 3)
</code></pre>

<p>Dans cet exemple, la classe <code class="language-python">ScientificCalculator</code> hérite de la classe <code class="language-python">Calculator</code> et redéfinit (surcharge) la méthode <code class="language-python">add</code>. Elle utilise <code class="language-python">super().add(x, y)</code> pour appeler la méthode <code class="language-python">add</code> de la classe <code class="language-python">Calculator</code> et ajoute ensuite une fonctionnalité supplémentaire : l'affichage du résultat de l'addition.</p>

<p>En résumé, <code class="language-python">super()</code> est un mécanisme essentiel de l'héritage en Python. Il facilite la réutilisation du code, aide à maintenir une structure de code claire et modulaire, et assure une initialisation correcte des classes parentes. Son utilisation simplifie l'extension et la modification du comportement des classes parentes dans les classes enfants, tout en préservant la logique existante et en évitant la duplication du code.</p>
</p>
  </section>
</div>


<div class="content_box">
  <section>
    <h2 class="heading">2. Héritage simple en Python</h2>
    <p><p>L'héritage simple est la forme d'héritage la plus élémentaire en programmation orientée objet (POO). Il permet à une classe, désignée comme sous-classe (ou classe dérivée), d'acquérir les attributs et les méthodes d'une autre classe unique, appelée super-classe (ou classe de base). La sous-classe a la possibilité d'étendre ou de modifier le comportement hérité de sa super-classe.</p>

<p>En Python, l'héritage simple s'effectue en indiquant la super-classe entre parenthèses après le nom de la sous-classe lors de sa définition. Examinons un exemple concret pour illustrer ce concept :</p>

<pre><code class="language-python">
# Define a base class called Publication
class Publication:
    def __init__(self, title, author):
        # Initialize the title and author attributes
        self.title = title
        self.author = author

    def display(self):
        # Display the publication information
        print(f"Title: {self.title}")
        print(f"Author: {self.author}")

# Define a derived class called Book that inherits from Publication
class Book(Publication):
    def __init__(self, title, author, num_pages):
        # Call the constructor of the parent class (Publication)
        super().__init__(title, author)
        # Initialize the num_pages attribute, specific to Book
        self.num_pages = num_pages

    def display(self):
        # Override the display method of the parent class
        super().display()  # Call the parent's display method first
        print(f"Number of Pages: {self.num_pages}")

# Create an instance of the Book class
book = Book("The Python Book", "John Smith", 300)

# Call the display method of the Book instance
book.display()
</code></pre>

<p>Dans cet exemple, la classe <code class="language-python">Book</code> hérite de la classe <code class="language-python">Publication</code>.  Cela signifie que la classe <code class="language-python">Book</code> bénéficie des attributs <code class="language-python">title</code> et <code class="language-python">author</code>, ainsi que de la méthode <code class="language-python">display()</code>, tous initialement définis dans la classe <code class="language-python">Publication</code>. De plus, la classe <code class="language-python">Book</code> introduit un nouvel attribut, <code class="language-python">num_pages</code>, et redéfinit (override) la méthode <code class="language-python">display()</code> afin d'intégrer l'affichage du nombre de pages.</p>

<p>L'instruction <code class="language-python">super().__init__(title, author)</code>, présente dans le constructeur de <code class="language-python">Book</code>, assure l'appel du constructeur de la classe parente (<code class="language-python">Publication</code>), permettant ainsi l'initialisation correcte des attributs hérités. Similairement, <code class="language-python">super().display()</code>, utilisé dans la méthode <code class="language-python">display()</code> de <code class="language-python">Book</code>, invoque la méthode <code class="language-python">display()</code> de la classe parente avant d'exécuter sa propre logique spécifique.</p>

<p>L'héritage simple est un mécanisme puissant pour la réutilisation du code et la structuration de hiérarchies de classes claires et organisées. Il offre la possibilité de créer des classes spécialisées à partir de classes plus générales, minimisant ainsi la duplication de code et simplifiant la maintenance et l'évolution du code au fil du temps. Il favorise ainsi un code plus propre et plus facile à gérer.</p>
</p>
    <h3>2.1 Définition de l'héritage simple</h3>
    <p><p>L'héritage simple est une forme fondamentale d'héritage en programmation orientée objet, particulièrement en Python. Il se manifeste lorsqu'une classe, désignée comme classe enfant ou sous-classe, hérite d'une unique classe parent, également appelée classe mère ou super-classe. Cette approche se distingue par sa simplicité et sa clarté, établissant une relation hiérarchique directe entre les classes.</p>

<p>Dans le cadre de l'héritage simple, la classe enfant acquiert tous les attributs et méthodes de sa classe parent. Cela confère à la classe enfant la capacité d'utiliser, de modifier ou d'étendre les fonctionnalités définies dans la classe parent. L'héritage simple encourage la réutilisation du code et la spécialisation des classes, en permettant la création de classes dérivées basées sur des classes plus générales.</p>

<p>L'exemple ci-dessous illustre l'héritage simple en Python :</p>

<pre><code class="language-python">
# Define a base class called 'Person'
class Person:
    def __init__(self, name, age):
        # Initialize the attributes of the Person class
        self.name = name
        self.age = age

    def introduce(self):
        # Method to introduce the person
        print(f"Hello, my name is {self.name} and I am {self.age} years old.")

# Define a derived class called 'Employee' that inherits from 'Person'
class Employee(Person):
    def __init__(self, name, age, employee_id):
        # Call the constructor of the parent class using super() to initialize name and age
        super().__init__(name, age)
        # Initialize the employee_id attribute, specific to the Employee class
        self.employee_id = employee_id

    def introduce(self):
        # Override the introduce method to include employee ID
        print(f"Hello, my name is {self.name}, I am {self.age} years old, and my employee ID is {self.employee_id}.")

    def get_employee_id(self):
        # Method to get the employee ID
        return self.employee_id

# Create an instance of the Employee class
employee = Employee("Alice", 30, "E12345")

# Call the introduce method, which is overridden in the Employee class
employee.introduce() # Output: Hello, my name is Alice, I am 30 years old, and my employee ID is E12345.

# Call the get_employee_id method, which is specific to the Employee class
employee_id = employee.get_employee_id()
print(f"Employee ID: {employee_id}") # Output: Employee ID: E12345

# Access the name attribute inherited from the Person class
print(f"Employee Name: {employee.name}") # Output: Employee Name: Alice
</code></pre>

<p>Dans cet exemple, la classe <code class="language-python">Employee</code> hérite de la classe <code class="language-python">Person</code>. La classe <code class="language-python">Employee</code> ajoute un attribut <code class="language-python">employee_id</code> et redéfinit (override) la méthode <code class="language-python">introduce()</code> pour inclure l'identifiant de l'employé. La fonction <code class="language-python">super()</code> est utilisée pour invoquer le constructeur de la classe parent, garantissant ainsi l'initialisation correcte des attributs hérités.</p>

<p>L'héritage simple est un concept fondamental pour maîtriser la programmation orientée objet en Python. Il facilite une structuration logique du code, encourage la réutilisation des composants existants et permet la création de classes spécialisées à partir de modèles plus généraux, contribuant ainsi à un code plus clair, plus maintenable et plus facile à comprendre.</p>
</p>
    <h3>2.2 Exemple d'héritage simple avec une classe `Animal` et `Dog`</h3>
    <p><p>L'héritage simple est la forme d'héritage la plus fondamentale en Python. Il se produit lorsqu'une classe (appelée classe enfant ou sous-classe) hérite d'une seule autre classe (appelée classe parent ou super-classe).  Cette approche permet à la classe enfant d'intégrer les attributs et les méthodes de la classe parent, ce qui encourage la réutilisation du code et établit une relation de type "est-un" entre les classes.</p>

<p>Prenons l'exemple d'une classe <code class="language-python">MusicalInstrument</code> et d'une classe <code class="language-python">Guitar</code> qui hérite de <code class="language-python">MusicalInstrument</code>. La classe <code class="language-python">MusicalInstrument</code> pourrait définir des propriétés communes à tous les instruments de musique, comme un nom et une méthode générique pour produire un son. La classe <code class="language-python">Guitar</code> hériterait de ces propriétés et pourrait introduire des attributs spécifiques à la guitare, tels que le nombre de cordes, tout en modifiant la méthode de jeu pour reproduire le son caractéristique d'une guitare.</p>

<pre><code class="language-python">
class MusicalInstrument:
    """
    A base class for musical instruments.
    """
    def __init__(self, name):
        """
        Initializes the musical instrument with a name.
        :param name: The name of the musical instrument.
        """
        self.name = name

    def play_sound(self):
        """
        Plays a generic musical instrument sound.
        """
        print("Generic musical instrument sound")


class Guitar(MusicalInstrument):
    """
    A class representing a guitar, inheriting from MusicalInstrument.
    """
    def __init__(self, name, num_strings):
        """
        Initializes the guitar with a name and the number of strings.
        Calls the parent class's initializer using super().
        :param name: The name of the guitar.
        :param num_strings: The number of strings on the guitar.
        """
        super().__init__(name)
        self.num_strings = num_strings

    def play_sound(self):
        """
        Plays a guitar sound. Overrides the parent class's method.
        """
        print("Strumming a guitar chord!")
</code></pre>

<p>Dans cet exemple, la classe <code class="language-python">Guitar</code> hérite de la classe <code class="language-python">MusicalInstrument</code>. Elle utilise <code class="language-python">super().__init__(name)</code> pour invoquer le constructeur de la classe parente et initialiser l'attribut <code class="language-python">name</code>.  De plus, elle redéfinit la méthode <code class="language-python">play_sound()</code> afin de fournir un comportement plus spécifique à la guitare. Ceci démontre comment une classe enfant peut simultanément hériter et adapter le comportement de sa classe parent.</p>

<p>Pour mettre en pratique ces classes, nous pouvons créer des instances et invoquer leurs méthodes :</p>

<pre><code class="language-python">
# Create an instance of MusicalInstrument
instrument = MusicalInstrument("Generic Instrument")
instrument.play_sound()  # Output: Generic musical instrument sound

# Create an instance of Guitar
guitar = Guitar("My Guitar", 6)
print(guitar.name)  # Output: My Guitar
print(guitar.num_strings)  # Output: 6
guitar.play_sound()  # Output: Strumming a guitar chord!
</code></pre>

<p>Cet exemple illustre clairement comment l'héritage simple permet la création d'une hiérarchie de classes. Les classes enfants héritent des attributs et des méthodes des classes parentes, tout en ayant la possibilité de les étendre ou de les modifier pour satisfaire des exigences spécifiques.  Cette approche favorise un code plus structuré, réutilisable et facile à maintenir.</p>
</p>
  </section>
</div>


<div class="content_box">
  <section>
    <h2 class="heading">3. Héritage multiple en Python</h2>
    <p><p>L'héritage multiple est une fonctionnalité puissante de Python qui permet à une classe d'hériter des attributs et des méthodes de plusieurs classes parentes, offrant ainsi une grande flexibilité dans la conception et la réutilisation du code. Cependant, une compréhension approfondie des implications et des défis potentiels est essentielle pour éviter des comportements inattendus.</p>

<p>La syntaxe de l'héritage multiple est simple : les classes parentes sont spécifiées entre parenthèses après le nom de la classe enfant, séparées par des virgules.</p>

<pre><code class="language-python">
class ParentA:
    def method_a(self):
        print("Method A from ParentA")

class ParentB:
    def method_b(self):
        print("Method B from ParentB")

class Child(ParentA, ParentB):
    def method_c(self):
        print("Method C from Child")

# Create an instance of the Child class
child = Child()
child.method_a()  # Output: Method A from ParentA
child.method_b()  # Output: Method B from ParentB
child.method_c()  # Output: Method C from Child
</code></pre>

<p>Dans cet exemple, la classe <code class="language-python">Child</code> hérite des méthodes <code class="language-python">method_a</code> de <code class="language-python">ParentA</code> et <code class="language-python">method_b</code> de <code class="language-python">ParentB</code>. De plus, elle définit sa propre méthode <code class="language-python">method_c</code>.</p>

<p>Le "problème du diamant" est un défi majeur de l'héritage multiple. Il survient lorsqu'une classe hérite de deux classes qui ont une classe ancêtre commune, créant une ambiguïté quant à la version de la méthode héritée à utiliser.</p>

<pre><code class="language-python">
class Grandparent:
    def method(self):
        print("Method from Grandparent")

class Parent1(Grandparent):
    def method(self):
        print("Method from Parent1")
        # You can also call the grandparent's method if needed
        super().method()

class Parent2(Grandparent):
    def method(self):
        print("Method from Parent2")
        # You can also call the grandparent's method if needed
        super().method()

class Child(Parent1, Parent2):
    pass  # Child inherits method from Parent1 because it's listed first

# Example
child = Child()
child.method()  # Output: Method from Parent1
</code></pre>

<p>Ici, <code class="language-python">Child</code> hérite de <code class="language-python">Parent1</code> et <code class="language-python">Parent2</code>, qui héritent tous deux de <code class="language-python">Grandparent</code>. Chaque classe définit une méthode <code class="language-python">method()</code>. L'appel à <code class="language-python">child.method()</code> exécute la méthode de <code class="language-python">Parent1</code>, car <code class="language-python">Parent1</code> est spécifié en premier dans la liste d'héritage de <code class="language-python">Child</code>. La méthode <code class="language-python">super().method()</code> permettrait d'appeler la méthode de la classe parente.</p>

<p>Python utilise l'ordre de résolution des méthodes (MRO - Method Resolution Order) pour déterminer l'ordre dans lequel les classes parentes sont recherchées lors de l'appel d'une méthode. Le MRO est une liste ordonnée de classes. On peut inspecter le MRO d'une classe en utilisant l'attribut <code class="language-python">__mro__</code> ou la méthode <code class="language-python">mro()</code>.</p>

<pre><code class="language-python">
class A:
    pass

class B:
    pass

class C(A, B):
    pass

print(C.mro())
# Output: [<class '__main__.C'>, <class '__main__.A'>, <class '__main__.B'>, <class 'object'>]

print(C.__mro__)
# Output: (<class '__main__.C'>, <class '__main__.A'>, <class '__main__.B'>, <class 'object'>)
</code></pre>

<p>L'héritage multiple peut être un outil puissant, mais son utilisation nécessite une compréhension approfondie du MRO pour éviter les comportements inattendus. Dans de nombreux cas, il est préférable de privilégier la composition à l'héritage, car cela réduit la complexité et améliore la maintenabilité du code. Une bonne pratique consiste à documenter clairement l'intention derrière l'utilisation de l'héritage multiple, en expliquant pourquoi il est plus approprié que d'autres approches de conception.</p>
</p>
    <h3>3.1 Définition de l'héritage multiple</h3>
    <p><p>L'héritage multiple en Python est une fonctionnalité puissante permettant à une classe d'hériter des attributs et des méthodes de plusieurs classes parent. Cela signifie qu'une classe enfant peut combiner et étendre les fonctionnalités de différentes classes de base, offrant ainsi une grande flexibilité dans la conception de programmes orientés objet. Cette approche permet de réutiliser du code et de construire des hiérarchies de classes complexes, tout en respectant les principes de la programmation orientée objet.</p>

<p>Pour illustrer l'héritage multiple, prenons l'exemple d'une classe <code class="language-python">Swimming</code> qui définit le comportement de nage et d'une classe <code class="language-python">Flying</code> qui définit le comportement de vol. Nous pouvons ensuite créer une classe <code class="language-python">Duck</code> qui hérite des deux classes, combinant ainsi les capacités de nage et de vol, illustrant la puissance de l'héritage multiple.</p>

<pre><code class="language-python">
class Swimming:
    def swim(self):
        print("Swimming...")

class Flying:
    def fly(self):
        print("Flying...")

class Duck(Swimming, Flying):
    def quack(self):
        print("Quack!")

# Example usage
my_duck = Duck()
my_duck.swim()  # Output: Swimming...
my_duck.fly()   # Output: Flying...
my_duck.quack() # Output: Quack!
</code></pre>

<p>Dans cet exemple, la classe <code class="language-python">Duck</code> hérite des méthodes <code class="language-python">swim()</code> de la classe <code class="language-python">Swimming</code> et <code class="language-python">fly()</code> de la classe <code class="language-python">Flying</code>. Elle possède également sa propre méthode <code class="language-python">quack()</code>, spécifique à la classe <code class="language-python">Duck</code>. L'ordre dans lequel les classes parent sont spécifiées dans la définition de la classe enfant (<code class="language-python">class Duck(Swimming, Flying):</code>) est crucial car il détermine l'ordre de résolution des méthodes en cas de conflits de noms. C'est ce qu'on appelle le MRO (Method Resolution Order), un concept essentiel pour comprendre le comportement de l'héritage multiple en Python.</p>

<p>L'héritage multiple peut également être utilisé pour créer des classes plus spécialisées à partir de classes de base plus générales. Par exemple, considérons une classe <code class="language-python">LandAnimal</code> qui représente un animal terrestre et une classe <code class="language-python">Pet</code> qui représente un animal de compagnie. Nous pourrions créer une classe <code class="language-python">DomesticatedAnimal</code> qui hérite des deux, combinant ainsi les caractéristiques des animaux terrestres et des animaux de compagnie. Cela permet de modéliser des concepts plus complexes en réutilisant et en étendant des classes existantes.</p>

<pre><code class="language-python">
class LandAnimal:
    def move(self):
        print("Moving on land")

class Pet:
    def give_affection(self):
        print("Giving affection")

class DomesticatedAnimal(LandAnimal, Pet):
    def __init__(self, name):
        self.name = name

    def describe(self):
        print(f"This is {self.name}, a domesticated animal.")

# Example usage
my_pet = DomesticatedAnimal("Buddy")
my_pet.move()            # Output: Moving on land
my_pet.give_affection()  # Output: Giving affection
my_pet.describe()        # Output: This is Buddy, a domesticated animal.
</code></pre>

<p>En conclusion, l'héritage multiple est une fonctionnalité puissante et flexible de Python qui permet de combiner les propriétés de plusieurs classes parent. Bien qu'elle puisse simplifier le code en favorisant la réutilisation et en évitant la duplication, elle doit être utilisée avec prudence pour éviter des hiérarchies de classes trop complexes et des problèmes potentiels de résolution de noms. La compréhension du MRO (Method Resolution Order) est essentielle pour maîtriser l'héritage multiple et garantir un comportement prévisible du code.</p>
</p>
    <h3>3.2 Le MRO (Method Resolution Order)</h3>
    <p><p>En Python, l'héritage multiple permet à une classe d'hériter de plusieurs classes parentes. Lorsque plusieurs classes parentes définissent la même méthode, Python doit déterminer laquelle utiliser. Le MRO (Method Resolution Order) définit l'ordre de recherche des méthodes dans la hiérarchie des classes.</p>

<p>Le MRO est donc l'ordre dans lequel Python explore les classes parentes pour résoudre les appels de méthodes. Il assure une résolution des méthodes prévisible et cohérente, même dans des scénarios d'héritage complexes. Python utilise l'algorithme C3 Linearization pour calculer le MRO, garantissant ainsi un ordre qui respecte la hiérarchie des classes et les règles de précédence.</p>

<p>Pour illustrer le fonctionnement du MRO, prenons un exemple simple avec des mixins :</p>

<pre><code class="language-python">
class Base:
    def greet(self):
        print("Base greeting")

class Mixin1:
    def greet(self):
        print("Mixin1 greeting")

class Mixin2:
    def hello(self):
        print("Mixin2 hello")

class MyClass(Base, Mixin1, Mixin2):
    pass

# Let's check the MRO
print(MyClass.__mro__)

instance = MyClass()
instance.greet() # Calls Mixin1's greet method because Mixin1 appears earlier in the MRO than Base
instance.hello() # Calls Mixin2's hello method
</code></pre>

<p>Dans cet exemple :</p>

<ul>
    <li><code class="language-python">Base</code> est une classe de base qui fournit une implémentation par défaut de la méthode <code class="language-python">greet</code>.</li>
    <li><code class="language-python">Mixin1</code> et <code class="language-python">Mixin2</code> sont des mixins, c'est-à-dire des classes conçues pour enrichir d'autres classes via l'héritage multiple.  <code class="language-python">Mixin1</code> redéfinit la méthode <code class="language-python">greet</code>, tandis que <code class="language-python">Mixin2</code> introduit une nouvelle méthode, <code class="language-python">hello</code>.</li>
    <li><code class="language-python">MyClass</code> hérite de <code class="language-python">Base</code>, <code class="language-python">Mixin1</code> et <code class="language-python">Mixin2</code> dans cet ordre précis.</li>
    <li>L'attribut <code class="language-python">__mro__</code> de <code class="language-python">MyClass</code> affiche le MRO, qui détermine l'ordre de recherche des méthodes.</li>
</ul>

<p>L'exécution de ce code affichera le MRO de <code class="language-python">MyClass</code> et démontrera que la méthode <code class="language-python">greet()</code> de <code class="language-python">Mixin1</code> est appelée au lieu de celle de <code class="language-python">Base</code>.  Ceci est dû au fait que <code class="language-python">Mixin1</code> apparaît plus tôt dans le MRO que <code class="language-python">Base</code>. Comprendre le MRO permet de prévoir quel <code class="language-python">greet()</code> sera exécuté.</p>

<p>Voici un exemple plus complexe pour souligner l'importance du MRO et de la C3 Linearization :</p>

<pre><code class="language-python">
class A:
    def say_hello(self):
        print("Hello from A")

class B(A):
    pass

class C(A):
    def say_hello(self):
        print("Hello from C")

class D(B, C):
    pass

d = D()
d.say_hello()
print(D.__mro__)
</code></pre>

<p>Dans cet exemple :</p>

<ul>
    <li><code class="language-python">A</code> définit la méthode <code class="language-python">say_hello</code>.</li>
    <li><code class="language-python">B</code> hérite de <code class="language-python">A</code> sans redéfinir <code class="language-python">say_hello</code>.</li>
    <li><code class="language-python">C</code> hérite de <code class="language-python">A</code> et redéfinit <code class="language-python">say_hello</code>.</li>
    <li><code class="language-python">D</code> hérite de <code class="language-python">B</code> et <code class="language-python">C</code>.  L'ordre de l'héritage est important.</li>
</ul>

<p>Le MRO de <code class="language-python">D</code> est <code class="language-python">(D, B, C, A, object)</code>. Par conséquent, lorsque <code class="language-python">d.say_hello()</code> est appelé, Python recherche la méthode dans <code class="language-python">D</code>, puis dans <code class="language-python">B</code>, puis dans <code class="language-python">C</code>. Il trouve <code class="language-python">say_hello</code> dans <code class="language-python">C</code> et l'exécute. Sans le MRO et l'algorithme C3 Linearization, la résolution de la méthode pourrait être ambiguë, surtout dans des hiérarchies plus profondes.</p>

<p>En conclusion, le MRO est un concept essentiel de l'héritage multiple en Python. Une bonne compréhension du MRO est indispensable pour éviter des comportements inattendus et pour écrire du code robuste et maintenable. L'algorithme C3 Linearization assure un ordre de résolution des méthodes cohérent et logique, mais il est impératif de le prendre en compte lors de la conception de hiérarchies d'héritage, en particulier lorsque celles-ci deviennent complexes.</p>
</p>
    <h3>3.3 Exemple d'héritage multiple avec `Employee` et `Speaker`</h3>
    <p><p>L'héritage multiple permet à une classe d'hériter des attributs et méthodes de plusieurs classes parent. Python supporte nativement cette fonctionnalité, offrant une grande flexibilité dans la conception de classes complexes. Cependant, il est crucial de bien comprendre ses mécanismes pour éviter les ambiguïtés et les conflits potentiels.</p>

<p>Prenons l'exemple d'une classe <code class="language-python">Employee</code> représentant un employé et une classe <code class="language-python">Speaker</code> représentant une personne capable de prendre la parole en public. Nous souhaitons créer une nouvelle classe, <code class="language-python">TalkingEmployee</code>, qui hérite des caractéristiques des deux classes parent, combinant ainsi les attributs et méthodes d'un employé et d'un orateur.</p>

<pre><code class="language-python">
class Employee:
    def __init__(self, name):
        self.name = name

    def do_work(self):
        print(f'{self.name} is working...')


class Speaker:
    def __init__(self, topic):
        self.topic = topic

    def speak(self):
        print(f'Speaking about {self.topic}...')


class TalkingEmployee(Employee, Speaker):
    def __init__(self, name, topic):
        Employee.__init__(self, name)
        Speaker.__init__(self, topic)


# Example usage
talking_employee = TalkingEmployee("Alice", "Python Inheritance")
talking_employee.do_work()
talking_employee.speak()
</code></pre>

<p>Dans cet exemple, la classe <code class="language-python">TalkingEmployee</code> hérite des méthodes <code class="language-python">do_work</code> de la classe <code class="language-python">Employee</code> et <code class="language-python">speak</code> de la classe <code class="language-python">Speaker</code>. De plus, elle initialise les attributs des deux classes parent dans son propre constructeur <code class="language-python">__init__</code>. L'ordre dans lequel les classes sont listées dans la définition de <code class="language-python">TalkingEmployee</code> est crucial, car il détermine l'ordre de résolution des méthodes (MRO - Method Resolution Order) en cas de conflit de noms ou d'attributs.</p>

<p>L'héritage multiple est un outil puissant, mais il peut introduire une complexité significative, notamment le "Diamond Problem" (problème du diamant). Ce problème survient lorsqu'une classe hérite de deux classes qui héritent elles-mêmes d'une même classe ancêtre. Dans ce cas, l'ordre de résolution des méthodes (MRO) de Python, basé sur l'algorithme C3 linearization, détermine quelle méthode est appelée en cas de conflit. Il est donc essentiel de bien comprendre l'ordre d'héritage et les potentielles collisions de noms pour éviter des comportements inattendus et assurer la cohérence du code.  Une bonne pratique consiste à utiliser l'héritage multiple avec parcimonie et à privilégier la composition lorsque cela est possible, pour maintenir un code clair et maintenable.</p>
</p>
  </section>
</div>


<div class="content_box">
  <section>
    <h2 class="heading">4. Héritage multiniveau en Python</h2>
    <p><p>L'héritage multiniveau se produit lorsqu'une classe hérite d'une autre classe, qui à son tour hérite d'une autre classe, formant ainsi une chaîne d'héritage hiérarchique.</p>

<p>Imaginez une structure où une classe de base sert de fondation. Une classe intermédiaire hérite de cette classe de base, étendant ou modifiant ses fonctionnalités. Ensuite, une classe finale hérite de la classe intermédiaire, héritant ainsi indirectement des caractéristiques de la classe de base originale. C'est ce qu'on appelle l'héritage multiniveau.</p>

<p>Voici un exemple concret pour illustrer ce concept :</p>

<pre><code class="language-python">
# Base class
class Grandparent:
    def __init__(self, grandparent_name):
        self.grandparent_name = grandparent_name

    def grandparent_info(self):
        return f"Grandparent's name: {self.grandparent_name}"

# Intermediate class inheriting from Grandparent
class Parent(Grandparent):
    def __init__(self, grandparent_name, parent_name, parent_occupation):
        Grandparent.__init__(self, grandparent_name)
        self.parent_name = parent_name
        self.parent_occupation = parent_occupation

    def parent_info(self):
        return f"Parent's name: {self.parent_name}, Occupation: {self.parent_occupation}, {Grandparent.grandparent_info(self)}"

# Child class inheriting from Parent
class Child(Parent):
    def __init__(self, grandparent_name, parent_name, parent_occupation, child_name, child_hobby):
        Parent.__init__(self, grandparent_name, parent_name, parent_occupation)
        self.child_name = child_name
        self.child_hobby = child_hobby

    def child_info(self):
        return f"Child's name: {self.child_name}, Hobby: {self.child_hobby}, {Parent.parent_info(self)}"

# Example usage
my_child = Child("John Senior", "John Junior", "Teacher", "Johnny", "Soccer")
print(my_child.child_info())
</code></pre>

<p>Dans cet exemple d'héritage multiniveau:</p>
<ul>
    <li>La classe <code class="language-python">Grandparent</code> est la classe de base, définissant un attribut <code class="language-python">grandparent_name</code> et une méthode <code class="language-python">grandparent_info</code>.</li>
    <li>La classe <code class="language-python">Parent</code> hérite de <code class="language-python">Grandparent</code>, ajoutant son propre attribut <code class="language-python">parent_name</code>, <code class="language-python">parent_occupation</code> et une méthode <code class="language-python">parent_info</code> tout en réutilisant les fonctionnalités de <code class="language-python">Grandparent</code>.</li>
    <li>La classe <code class="language-python">Child</code> hérite de <code class="language-python">Parent</code>, ajoutant un attribut <code class="language-python">child_name</code>, <code class="language-python">child_hobby</code> et une méthode <code class="language-python">child_info</code>. Elle hérite indirectement de <code class="language-python">Grandparent</code> via <code class="language-python">Parent</code>.</li>
    <li>L'objet <code class="language-python">my_child</code>, instancié à partir de la classe <code class="language-python">Child</code>, peut accéder aux attributs et méthodes définis dans les classes <code class="language-python">Grandparent</code> et <code class="language-python">Parent</code> grâce à l'héritage.</li>
</ul>

<p>L'héritage multiniveau offre une manière structurée d'organiser le code et de minimiser la redondance en permettant aux classes de partager des attributs et des méthodes communs. Cependant, il est crucial de l'utiliser judicieusement, car une chaîne d'héritage excessivement longue peut compliquer la compréhension et la maintenance du code.  Il est donc important de bien réfléchir à la conception de la hiérarchie des classes.</p>

<p>Il est essentiel de se rappeler que Python prend en charge l'héritage multiple, où une classe peut hériter directement de plusieurs classes parentes. L'héritage multiniveau est un cas particulier d'héritage où une classe hérite d'une seule classe parente à chaque niveau de la hiérarchie.</p>
</p>
    <h3>4.1 Définition de l'héritage multiniveau</h3>
    <p><p>L'héritage multiniveau est une forme d'héritage en programmation orientée objet où une classe dérive d'une autre classe, qui elle-même dérive d'une autre classe. On peut le représenter comme une hiérarchie ou une chaîne d'héritage, où chaque classe enfant hérite des propriétés et méthodes de ses classes parentes successives. Cela permet de construire des structures de classes complexes, favorisant la réutilisation du code et la création de modèles plus spécifiques.</p>

<p>Pour illustrer ce concept, prenons l'exemple d'une hiérarchie de classes représentant différents types de véhicules. La classe de base pourrait être <code class="language-python">Vehicle</code>, définissant des attributs communs à tous les véhicules, comme le nombre de roues et une méthode pour démarrer le moteur. Ensuite, une classe <code class="language-python">FourWheeledVehicle</code> hériterait de <code class="language-python">Vehicle</code> et ajouterait des caractéristiques propres aux véhicules à quatre roues. Enfin, une classe <code class="language-python">Car</code> hériterait de <code class="language-python">FourWheeledVehicle</code>, ajoutant des attributs spécifiques aux voitures, comme le modèle et le nombre de portes.</p>

<p>Voici un exemple de code Python qui illustre l'héritage multiniveau :</p>

<pre><code class="language-python">
# Base class
class Vehicle:
    def __init__(self, num_wheels):
        # Initialize the number of wheels
        self.num_wheels = num_wheels

    def start_engine(self):
        # Method to start the engine
        print("Engine started!")

# Intermediate class inheriting from Vehicle
class FourWheeledVehicle(Vehicle):
    def __init__(self, model):
        # Call the constructor of the parent class Vehicle with 4 wheels
        super().__init__(4)
        # Initialize the model of the vehicle
        self.model = model

    def drive(self):
        # Method to simulate driving
        print("Driving a", self.model)

# Child class inheriting from FourWheeledVehicle
class Car(FourWheeledVehicle):
    def __init__(self, model, num_doors):
        # Call the constructor of the parent class FourWheeledVehicle
        super().__init__(model)
        # Initialize the number of doors
        self.num_doors = num_doors

    def display_details(self):
        # Method to display car details
        print("Model:", self.model)
        print("Number of doors:", self.num_doors)
        print("Number of wheels:", self.num_wheels)

# Creating an instance of the Car class
my_car = Car("Sedan", 4)
my_car.start_engine()  # Inherited from Vehicle
my_car.drive()       # Inherited from FourWheeledVehicle
my_car.display_details() # Specific to Car class
</code></pre>

<p>Dans cet exemple, la classe <code class="language-python">Car</code> hérite de <code class="language-python">FourWheeledVehicle</code>, qui elle-même hérite de <code class="language-python">Vehicle</code>. L'objet <code class="language-python">my_car</code> peut ainsi accéder aux méthodes définies dans toutes ces classes. L'appel à <code class="language-python">super().__init__(4)</code> dans la classe <code class="language-python">FourWheeledVehicle</code> garantit l'initialisation correcte de la classe parente <code class="language-python">Vehicle</code>, en spécifiant le nombre de roues à 4. De même, la classe <code class="language-python">Car</code> utilise <code class="language-python">super().__init__(model)</code> pour initialiser la classe <code class="language-python">FourWheeledVehicle</code> avec le modèle de la voiture.</p>

<p>L'héritage multiniveau offre une excellente réutilisation du code et permet d'organiser les classes de manière hiérarchique, facilitant ainsi la modélisation de systèmes complexes. Cependant, il est crucial de l'utiliser avec discernement afin d'éviter une complexité excessive et des dépendances inutiles entre les classes. Une hiérarchie d'héritage trop profonde peut rendre le code difficile à comprendre, à déboguer et à maintenir. Il est donc important de bien peser les avantages et les inconvénients avant d'opter pour cette approche.</p>
</p>
    <h3>4.2 Exemple d'héritage multiniveau avec `Vehicle`, `Car`, et `ElectricCar`</h3>
    <p><p>L'héritage multiniveau est une forme d'héritage où une classe dérive d'une classe qui dérive elle-même d'une autre classe. Cela crée une hiérarchie en forme de chaîne. Python supporte l'héritage multiniveau, permettant ainsi la construction de structures de classes complexes et bien organisées.</p>

<p>Prenons l'exemple concret d'une classe de base <code class="language-python">Vehicle</code>, d'une classe <code class="language-python">Car</code> qui hérite de <code class="language-python">Vehicle</code>, et enfin, d'une classe <code class="language-python">ElectricCar</code> qui hérite de <code class="language-python">Car</code>.</p>

<pre><code class="language-python">
class Vehicle:
    """
    Base class representing a generic vehicle.
    """
    def __init__(self, brand, model):
        """
        Initializes a Vehicle object.
        Args:
            brand (str): The brand of the vehicle.
            model (str): The model of the vehicle.
        """
        self.brand = brand
        self.model = model

    def display_info(self):
        """
        Displays basic information about the vehicle.
        """
        print(f"Brand: {self.brand}, Model: {self.model}")


class Car(Vehicle):
    """
    Class representing a car, inheriting from Vehicle.
    """
    def __init__(self, brand, model, num_doors):
        """
        Initializes a Car object.
        Args:
            brand (str): The brand of the car.
            model (str): The model of the car.
            num_doors (int): The number of doors the car has.
        """
        super().__init__(brand, model)  # Call the parent class's constructor
        self.num_doors = num_doors

    def display_car_info(self):
        """
        Displays car-specific information.
        """
        self.display_info() # Calls the display_info method from the Vehicle class
        print(f"Number of doors: {self.num_doors}")


class ElectricCar(Car):
    """
    Class representing an electric car, inheriting from Car.
    """
    def __init__(self, brand, model, num_doors, battery_capacity):
        """
        Initializes an ElectricCar object.
        Args:
            brand (str): The brand of the electric car.
            model (str): The model of the electric car.
            num_doors (int): The number of doors the electric car has.
            battery_capacity (int): The battery capacity of the electric car in kWh.
        """
        super().__init__(brand, model, num_doors)  # Call the parent class's constructor
        self.battery_capacity = battery_capacity

    def display_electric_car_info(self):
        """
        Displays electric car-specific information.
        """
        self.display_car_info() # Calls the display_car_info method from the Car class
        print(f"Battery Capacity: {self.battery_capacity} kWh")


# Example usage
my_electric_car = ElectricCar("Tesla", "Model 3", 4, 75)
my_electric_car.display_electric_car_info()
</code></pre>

<p>Dans cet exemple de code :</p>
<ul>
    <li>La classe <code class="language-python">Vehicle</code> sert de base et définit les attributs communs à tous les véhicules, tels que la marque (<code class="language-python">brand</code>) et le modèle (<code class="language-python">model</code>).</li>
    <li>La classe <code class="language-python">Car</code> hérite de <code class="language-python">Vehicle</code> et introduit l'attribut <code class="language-python">num_doors</code>, spécifique aux voitures. L'appel à <code class="language-python">super().__init__()</code> assure que les attributs de la classe parente (<code class="language-python">Vehicle</code>) sont correctement initialisés.</li>
    <li>La classe <code class="language-python">ElectricCar</code> hérite de <code class="language-python">Car</code> et ajoute l'attribut <code class="language-python">battery_capacity</code>, propre aux voitures électriques. De même, <code class="language-python">super().__init__()</code> est utilisé pour initialiser les attributs hérités des classes parentes.</li>
</ul>

<p>Ainsi, lorsqu'une instance de <code class="language-python">ElectricCar</code> est créée, elle possède non seulement les attributs définis dans sa propre classe (comme <code class="language-python">battery_capacity</code>), mais aussi ceux hérités de <code class="language-python">Car</code> (<code class="language-python">num_doors</code>) et de <code class="language-python">Vehicle</code> (<code class="language-python">brand</code> et <code class="language-python">model</code>).  L'appel à la méthode <code class="language-python">display_electric_car_info()</code> démontre l'accès aux méthodes des classes ancêtres, illustrant le principe de l'héritage multiniveau. L'utilisation correcte de <code class="language-python">super()</code> est cruciale pour garantir que l'initialisation des classes parentes se fait de manière appropriée, évitant ainsi des erreurs potentielles et assurant un comportement prévisible du code.</p>
</p>
  </section>
</div>


<div class="content_box">
  <section>
    <h2 class="heading">5. Héritage hiérarchique en Python</h2>
    <p><p>L'héritage hiérarchique se manifeste lorsqu'une classe sert de classe parente, ou classe de base, à plusieurs classes enfants. En d'autres termes, plusieurs classes enfants dérivent d'une seule et même classe parente, formant ainsi une structure arborescente, semblable à une hiérarchie.</p>

<p>Ce type d'héritage permet de centraliser le code commun à plusieurs classes dans une classe de base unique. Cela évite la duplication de code, améliore la maintenabilité et favorise la réutilisation. Chaque classe enfant peut ensuite implémenter ses propres fonctionnalités spécifiques, tout en bénéficiant des attributs et méthodes hérités de la classe parente.</p>

<p>Voici un exemple concret illustrant l'héritage hiérarchique en Python :</p>

<pre><code class="language-python">
# Define the base class
class Device:
    """
    A base class representing a generic electronic device.
    """
    def __init__(self, brand, model):
        """
        Initializes a Device object.
        Args:
            brand (str): The brand of the device.
            model (str): The model of the device.
        """
        self.brand = brand
        self.model = model

    def turn_on(self):
        """
        Turns the device on.
        """
        print(f"Turning on the {self.brand} {self.model}")

    def turn_off(self):
        """
        Turns the device off.
        """
        print(f"Turning off the {self.brand} {self.model}")


# Define the child classes inheriting from Device
class Television(Device):
    """
    A class representing a television, inheriting from Device.
    """
    def __init__(self, brand, model, screen_size):
        """
        Initializes a Television object.
        Args:
            brand (str): The brand of the television.
            model (str): The model of the television.
            screen_size (int): The screen size of the television in inches.
        """
        super().__init__(brand, model)
        self.screen_size = screen_size

    def watch(self, channel):
        """
        Simulates watching a specific channel on the television.
        Args:
            channel (int): The channel number to watch.
        """
        print(f"Watching channel {channel} on the {self.brand} {self.model} ({self.screen_size} inch)")


class Radio(Device):
    """
    A class representing a radio, inheriting from Device.
    """
    def __init__(self, brand, model, frequency_range):
        """
        Initializes a Radio object.
        Args:
            brand (str): The brand of the radio.
            model (str): The model of the radio.
            frequency_range (str): The frequency range of the radio (e.g., "FM/AM").
        """
        super().__init__(brand, model)
        self.frequency_range = frequency_range

    def tune(self, frequency):
        """
        Simulates tuning to a specific frequency on the radio.
        Args:
            frequency (float): The frequency to tune to in MHz.
        """
        print(f"Tuning to {frequency} MHz on the {self.brand} {self.model} ({self.frequency_range})")


# Create instances of the child classes
tv = Television("Sony", "Bravia X1", 55)
radio = Radio("Panasonic", "RF-2400D", "FM/AM")

# Demonstrate the use of the inherited methods
tv.turn_on()
tv.watch(4)
tv.turn_off()

radio.turn_on()
radio.tune(98.5)
radio.turn_off()
</code></pre>

<p>Dans cet exemple, la classe <code class="language-python">Device</code> est la classe de base. Les classes <code class="language-python">Television</code> et <code class="language-python">Radio</code> héritent de <code class="language-python">Device</code>. Chaque classe enfant ajoute ses propres attributs (par exemple, <code class="language-python">screen_size</code> pour <code class="language-python">Television</code> et <code class="language-python">frequency_range</code> pour <code class="language-python">Radio</code>) et méthodes spécifiques (par exemple, <code class="language-python">watch</code> et <code class="language-python">tune</code>), tout en héritant des méthodes <code class="language-python">turn_on</code> et <code class="language-python">turn_off</code> de la classe de base. L'appel à <code class="language-python">super().__init__(brand, model)</code> dans les constructeurs des classes filles assure que l'initialisation de la classe parent est correctement exécutée.</p>

<p>L'héritage hiérarchique est une technique précieuse pour structurer le code, en particulier lorsqu'un ensemble commun de propriétés et de comportements est partagé par plusieurs classes. Il encourage la réutilisation du code, la modularité et contribue à réduire la complexité globale du programme. Il est essentiel de bien concevoir la hiérarchie pour maintenir un code clair et facile à maintenir.</p>
</p>
    <h3>5.1 Définition de l'héritage hiérarchique</h3>
    <p><p>L'héritage hiérarchique est une forme d'héritage où une classe de base, également appelée classe parent, sert de parent à plusieurs classes dérivées, aussi appelées classes enfants. En d'autres termes, plusieurs classes enfants héritent d'une seule et même classe parent, formant ainsi une hiérarchie.</p>

<p>Imaginez une classe de base nommée <code class="language-python">Shape</code> (Forme). Cette classe pourrait contenir des attributs communs à toutes les formes géométriques, comme une couleur ou une position. Ensuite, nous aurions des classes enfants telles que <code class="language-python">Circle</code> (Cercle), <code class="language-python">Rectangle</code> (Rectangle) et <code class="language-python">Triangle</code> (Triangle), chacune héritant de la classe <code class="language-python">Shape</code> et ajoutant ses propres attributs spécifiques, comme le rayon pour un cercle, ou la longueur et la largeur pour un rectangle.</p>

<p>Voici un exemple simple en Python pour illustrer l'héritage hiérarchique :</p>

<pre><code class="language-python">
# Define the base class
class Shape:
    def __init__(self, color="black"):
        self.color = color

    def get_color(self):
        return self.color

    def __str__(self):
        return f"Shape with color: {self.color}"


# Define the derived classes
class Circle(Shape):
    def __init__(self, radius, color="black"):
        super().__init__(color)
        self.radius = radius

    def area(self):
        return 3.14 * self.radius * self.radius

    def __str__(self):
        return f"Circle with radius: {self.radius} and color: {self.color}"


class Square(Shape):
    def __init__(self, side, color="black"):
        super().__init__(color)
        self.side = side

    def area(self):
        return self.side * self.side

    def __str__(self):
        return f"Square with side: {self.side} and color: {self.color}"


# Create instances of the derived classes
my_circle = Circle(radius=5, color="red")
my_square = Square(side=4, color="blue")

# Access the attributes and methods
print(f"The circle's color is: {my_circle.get_color()}")
print(f"The circle's area is: {my_circle.area()}")
print(f"The square's color is: {my_square.get_color()}")
print(f"The square's area is: {my_square.area()}")

# Print object representation using the overridden __str__ method
print(my_circle)
print(my_square)
</code></pre>

<p>Dans cet exemple, <code class="language-python">Shape</code> est la classe parent, et <code class="language-python">Circle</code> et <code class="language-python">Square</code> sont les classes enfants. Chaque classe enfant hérite de l'attribut <code class="language-python">color</code> de la classe <code class="language-python">Shape</code> et définit sa propre méthode <code class="language-python">area()</code> pour calculer sa surface. De plus, la méthode <code class="language-python">__str__()</code> est redéfinie dans chaque classe pour fournir une représentation en chaîne de caractères de l'objet.</p>

<p>L'héritage hiérarchique est un outil puissant pour structurer le code de manière logique et favoriser la réutilisation. Il est particulièrement pertinent lorsque vous avez des classes qui partagent des caractéristiques communes tout en possédant des spécificités qui leur sont propres, permettant ainsi une organisation claire et maintenable de votre codebase.</p>
</p>
    <h3>5.2 Exemple d'héritage hiérarchique avec `Shape`, `Circle`, et `Square`</h3>
    <p><p>L'héritage hiérarchique se produit lorsqu'une classe sert de classe parente (ou classe de base) à plusieurs classes enfants. Chaque classe enfant hérite des attributs et des méthodes de la classe parente, mais peut également définir ses propres attributs et méthodes spécifiques. Ces classes enfants peuvent ensuite servir de classes de base à d'autres classes, formant ainsi une hiérarchie. Cela permet une organisation du code plus claire, une réutilisation efficace des fonctionnalités communes et une spécialisation des comportements.</p>

<p>Considérons un exemple avec une classe de base nommée <code class="language-python">Shape</code>. Cette classe définit une méthode générale pour calculer l'aire, <code class="language-python">area()</code>. Cependant, elle ne fournit pas d'implémentation spécifique car le calcul de l'aire varie en fonction de la forme. Deux classes, <code class="language-python">Circle</code> et <code class="language-python">Square</code>, héritent de <code class="language-python">Shape</code> et implémentent la méthode <code class="language-python">area()</code> de manière spécifique à chaque forme.</p>

<pre><code class="language-python">
class Shape:
    """
    Base class for shapes.
    """
    def __init__(self, name):
        """
        Initializes the shape with a name.
        """
        self.name = name

    def area(self):
        """
        Method to calculate the area of a shape.
        This should be implemented by the derived classes.
        """
        pass

    def __str__(self):
        """
        Returns a string representation of the shape.
        """
        return f"Shape: {self.name}"


class Circle(Shape):
    """
    Class representing a circle, inheriting from Shape.
    """
    def __init__(self, radius):
        """
        Initializes the circle with a radius.
        """
        super().__init__("Circle")
        self.radius = radius

    def area(self):
        """
        Calculates the area of the circle.
        """
        return 3.14159 * self.radius * self.radius

    def __str__(self):
        """
        Returns a string representation of the circle.
        """
        return f"{super().__str__()} with radius: {self.radius}"


class Square(Shape):
    """
    Class representing a square, inheriting from Shape.
    """
    def __init__(self, side):
        """
        Initializes the square with a side length.
        """
        super().__init__("Square")
        self.side = side

    def area(self):
        """
        Calculates the area of the square.
        """
        return self.side * self.side

    def __str__(self):
        """
        Returns a string representation of the square.
        """
        return f"{super().__str__()} with side: {self.side}"


# Example usage
my_circle = Circle(radius=5)
my_square = Square(side=4)

print(my_circle)
print(f"The area of the circle is: {my_circle.area()}")
print(my_square)
print(f"The area of the square is: {my_square.area()}")
</code></pre>

<p>Dans cet exemple, <code class="language-python">Shape</code> est la classe de base, et <code class="language-python">Circle</code> et <code class="language-python">Square</code> sont les classes dérivées. Chaque classe dérivée implémente la méthode <code class="language-python">area()</code> de manière appropriée pour sa forme spécifique. De plus, chaque classe dérivée a son propre constructeur (<code class="language-python">__init__</code>) pour initialiser ses attributs spécifiques (rayon pour le cercle, côté pour le carré). L'héritage hiérarchique permet de définir une structure claire et réutilisable pour différentes formes, tout en maintenant une interface commune via la classe de base <code class="language-python">Shape</code>. La méthode <code class="language-python">__str__</code> est surchargée pour fournir une représentation en chaîne plus informative de chaque objet.</p>
</p>
  </section>
</div>


<div class="content_box">
  <section>
    <h2 class="heading">6. Héritage hybride en Python</h2>
    <p><p>L'héritage hybride est une combinaison de plusieurs types d'héritage, combinant généralement l'héritage multiple et l'héritage hiérarchique. Cette approche permet de bâtir des structures de classes complexes où une classe enfant hérite de plusieurs classes parentes, lesquelles peuvent aussi hériter d'autres classes. Il offre une grande flexibilité dans la modélisation des relations entre les objets.</p>

<p>Bien que l'héritage hybride offre une grande puissance pour modéliser des relations complexes, il peut également augmenter la difficulté de compréhension et de maintenance du code. Une attention particulière doit être accordée à l'ordre de résolution des méthodes (MRO - Method Resolution Order) pour éviter des comportements inattendus et garantir le bon fonctionnement du programme.</p>

<p>Voici un exemple concret illustrant l'héritage hybride. Imaginons une classe <code class="language-python">Transport</code> qui définit les propriétés générales d'un moyen de transport. Nous avons ensuite une classe <code class="language-python">RoadVehicle</code> et une classe <code class="language-python">WaterVehicle</code> qui héritent de <code class="language-python">Transport</code> et ajoutent des propriétés spécifiques à chaque type de véhicule. Enfin, une classe <code class="language-python">AmphibiousVehicle</code> hérite à la fois de <code class="language-python">RoadVehicle</code> et de <code class="language-python">WaterVehicle</code>, combinant ainsi les caractéristiques des deux pour modéliser un véhicule amphibie.</p>

<pre><code class="language-python">
class Transport:
    """
    Base class representing a general means of transport.
    """
    def __init__(self, name):
        """
        Initializes the Transport object with a name.
        """
        self.name = name

    def travel(self):
        """
        Prints a message indicating that the transport is traveling.
        """
        print(f"The {self.name} is traveling.")


class RoadVehicle(Transport):
    """
    Class representing a road vehicle.
    Inherits from Transport.
    """
    def __init__(self, name, num_wheels):
        """
        Initializes the RoadVehicle object with a name and number of wheels.
        Calls the constructor of the parent class (Transport).
        """
        super().__init__(name)
        self.num_wheels = num_wheels

    def drive(self):
        """
        Prints a message indicating that the vehicle is driving on the road.
        """
        print(f"The {self.name} is driving on the road with {self.num_wheels} wheels.")


class WaterVehicle(Transport):
    """
    Class representing a water vehicle.
    Inherits from Transport.
    """
    def __init__(self, name, displacement):
        """
        Initializes the WaterVehicle object with a name and displacement.
        Calls the constructor of the parent class (Transport).
        """
        super().__init__(name)
        self.displacement = displacement

    def navigate(self):
        """
        Prints a message indicating that the vehicle is navigating on the water.
        """
        print(f"The {self.name} is navigating on the water with a displacement of {self.displacement} tons.")


class AmphibiousVehicle(RoadVehicle, WaterVehicle):
    """
    Class representing an amphibious vehicle.
    Inherits from both RoadVehicle and WaterVehicle (multiple inheritance).
    """
    def __init__(self, name, num_wheels, displacement):
        """
        Initializes the AmphibiousVehicle object with a name, number of wheels, and displacement.
        Explicitly calls the constructors of both parent classes (RoadVehicle and WaterVehicle).
        """
        RoadVehicle.__init__(self, name, num_wheels)
        WaterVehicle.__init__(self, name, displacement)

    def operate(self):
        """
        Prints a message indicating that the vehicle is operating as an amphibious vehicle.
        Calls the drive and navigate methods to simulate amphibious operation.
        """
        print(f"The {self.name} is operating as an amphibious vehicle.")
        self.drive()
        self.navigate()


# Example usage
amphibious_car = AmphibiousVehicle("Amphicar", 4, 1.5)
amphibious_car.operate()
</code></pre>

<p>Dans cet exemple, la classe <code class="language-python">AmphibiousVehicle</code> hérite des attributs et des méthodes de <code class="language-python">RoadVehicle</code> et <code class="language-python">WaterVehicle</code>. L'appel explicite à <code class="language-python">RoadVehicle.__init__(self, name, num_wheels)</code> et <code class="language-python">WaterVehicle.__init__(self, name, displacement)</code> dans le constructeur de <code class="language-python">AmphibiousVehicle</code> est crucial pour initialiser correctement les attributs hérités des deux classes parentes. Si nous utilisions <code class="language-python">super().__init__()</code>, seul le constructeur de la première classe parente dans l'ordre d'héritage (ici, <code class="language-python">RoadVehicle</code>) serait appelé, laissant les attributs de <code class="language-python">WaterVehicle</code> non initialisés. L'utilisation de <code class="language-python">super()</code> dans un héritage hybride complexe nécessite une conception soignée et une compréhension approfondie du MRO.</p>

<p>Il est important de noter que, dans l'héritage hybride, l'ordre dans lequel les classes parentes sont listées lors de la définition de la classe enfant influence l'ordre de résolution des méthodes (MRO). Cela peut avoir un impact significatif sur le comportement du programme, en particulier si les classes parentes ont des méthodes avec le même nom. Dans cet exemple, il est essentiel de s'assurer que les deux classes parentes sont correctement initialisées et que l'ordre d'héritage est logique pour éviter des conflits ou des comportements inattendus.</p>
</p>
    <h3>6.1 Définition de l'héritage hybride</h3>
    <p><p>L'héritage hybride est une forme d'héritage en programmation orientée objet (POO) qui combine plusieurs types d'héritage, tels que l'héritage simple, l'héritage multiple, l'héritage multiniveau et l'héritage hiérarchique.  Il se produit lorsqu'une classe dérive d'une combinaison de classes parentes, où certaines de ces classes parentes peuvent elles-mêmes hériter d'autres classes.  Cette approche offre une grande flexibilité dans la modélisation de relations complexes entre les classes, mais peut rapidement devenir difficile à gérer si elle n'est pas mise en œuvre avec soin.</p>

<p>En général, l'héritage hybride doit être utilisé avec prudence en raison de sa complexité. Les structures d'héritage complexes peuvent conduire à une maintenance difficile et à une compréhension obscure du code. L'ambiguïté peut apparaître, notamment avec le "Diamond Problem" (problème du diamant), où une classe hérite de deux classes qui ont une ancêtre commune. Cependant, dans certains cas bien définis, l'héritage hybride peut être la solution la plus appropriée pour modéliser des relations complexes du monde réel.</p>

<p>Pour illustrer l'héritage hybride, prenons un exemple concret. Imaginons que nous ayons une classe de base <code class="language-python">Animal</code>, et deux classes dérivées <code class="language-python">Mammal</code> et <code class="language-python">Bird</code>. Nous pourrions ensuite créer une classe <code class="language-python">FlyingMammal</code> qui hérite à la fois de <code class="language-python">Mammal</code> et de <code class="language-python">Bird</code> pour représenter un animal qui possède les caractéristiques des deux (comme une chauve-souris). Voici comment cela pourrait être implémenté en Python :</p>

<pre><code class="language-python">
class Animal:
    def __init__(self, name):
        self.name = name

    def breathe(self):
        print("Animal breathing")

class Mammal(Animal):
    def __init__(self, name):
        super().__init__(name)
        self.has_fur = True

    def give_birth(self):
        print("Mammal giving birth")

class Bird(Animal):
    def __init__(self, name):
        super().__init__(name)
        self.has_feathers = True

    def lay_eggs(self):
        print("Bird laying eggs")

class FlyingMammal(Mammal, Bird):
    def __init__(self, name):
        Mammal.__init__(self, name)
        Bird.__init__(self, name)

    def fly(self):
        print("Flying mammal flying")

# Example usage
bat = FlyingMammal("Bat")
bat.breathe()  # Output: Animal breathing
bat.give_birth() # Output: Mammal giving birth
bat.lay_eggs() # Output: Bird laying eggs
bat.fly() # Output: Flying mammal flying
print(f"{bat.name} has fur: {bat.has_fur}")   # Output: Bat has fur: True
print(f"{bat.name} has feathers: {bat.has_feathers}") # Output: Bat has feathers: True
</code></pre>

<p>Dans cet exemple, la classe <code class="language-python">FlyingMammal</code> hérite des propriétés et des méthodes des classes <code class="language-python">Mammal</code> et <code class="language-python">Bird</code>. L'ordre d'héritage est important car il affecte l'ordre dans lequel les méthodes sont recherchées (MRO - Method Resolution Order). Il est essentiel de bien comprendre le MRO pour éviter des comportements inattendus. L'appel des constructeurs des classes parentes (<code class="language-python">Mammal.__init__(self, name)</code> et <code class="language-python">Bird.__init__(self, name)</code>) est également crucial pour initialiser correctement les attributs hérités.</p>

<p>En conclusion, l'héritage hybride peut être un outil puissant pour modéliser des relations complexes entre les classes, mais il doit être utilisé avec discernement. Une planification minutieuse, une compréhension claire du MRO et une documentation adéquate sont essentielles pour garantir que le code reste maintenable et compréhensible. Privilégier la composition à l'héritage peut souvent être une alternative plus simple et plus robuste, en particulier lorsque la complexité de l'héritage hybride devient excessive.</p>
</p>
    <h3>6.2 Les défis de l'héritage hybride</h3>
    <p><p>L'héritage hybride, bien que théoriquement puissant, peut rapidement devenir un véritable défi de maintenance en raison de sa complexité intrinsèque. Combiner différents types d'héritage aboutit souvent à des hiérarchies de classes profondes et imbriquées, rendant le code difficile à comprendre, à déboguer et à modifier.</p>

<p>Un des principaux écueils de l'héritage hybride est la gestion de l'ordre de résolution des méthodes (MRO - Method Resolution Order). Le MRO définit la séquence dans laquelle les classes parentes sont explorées pour trouver une méthode spécifique. Dans les situations d'héritage multiple, particulièrement avec l'héritage hybride, le MRO peut se complexifier et devenir contre-intuitif, compliquant la prédiction de la méthode qui sera effectivement exécutée.</p>

<p>Prenons l'exemple suivant :</p>

<pre><code class="language-python">
class BaseClass:
    def display(self):
        print("Base class display")

class FirstMixin(BaseClass):
    def display(self):
        print("First Mixin display")
        super().display()

class SecondMixin(BaseClass):
    def display(self):
        print("Second Mixin display")
        super().display()

class HybridClass(FirstMixin, SecondMixin):
    pass

# Example Usage
hybrid_obj = HybridClass()
hybrid_obj.display()
# Output:
# First Mixin display
# Second Mixin display
# Base class display
</code></pre>

<p>Dans cet exemple, la classe <code class="language-python">HybridClass</code> hérite de <code class="language-python">FirstMixin</code> et <code class="language-python">SecondMixin</code>, qui héritent toutes deux de <code class="language-python">BaseClass</code>. Le MRO va déterminer l'ordre d'exécution des méthodes <code class="language-python">display()</code>, ce qui peut s'avérer déroutant sans une compréhension approfondie du MRO en Python. Pour examiner le MRO, vous pouvez utiliser l'attribut <code class="language-python">__mro__</code> :</p>

<pre><code class="language-python">
print(HybridClass.__mro__)
# Output:
# (&lt;class '__main__.HybridClass'&gt;, &lt;class '__main__.FirstMixin'&gt;, &lt;class '__main__.SecondMixin'&gt;, &lt;class '__main__.BaseClass'&gt;, &lt;class 'object'&gt;)
</code></pre>

<p>Plus la hiérarchie devient complexe, plus il est difficile de maîtriser le MRO et d'anticiper le comportement du code. La fonction <code class="language-python">super()</code>, utilisée pour appeler la méthode de la classe parente, se base sur le MRO pour déterminer quelle méthode appeler ensuite. Une mauvaise compréhension du MRO peut entraîner des comportements inattendus et des bugs difficiles à traquer.</p>

<p>En raison de ces complications, il est souvent préférable d'opter pour la composition plutôt que l'héritage hybride lorsque cela est possible. La composition permet de construire des objets complexes en assemblant des objets plus simples, ce qui résulte généralement en un code plus clair, plus flexible et plus facile à maintenir.</p>

<p>Par exemple, au lieu d'utiliser l'héritage pour combiner des fonctionnalités, on peut créer des classes distinctes et les assembler dans une autre classe :</p>

<pre><code class="language-python">
class Engine:
    def start(self):
        print("Engine started")

class Radio:
    def play_music(self):
        print("Playing music")

class Car:
    def __init__(self):
        self.engine = Engine()
        self.radio = Radio()

    def drive(self):
        self.engine.start()
        print("Car is driving")
        self.radio.play_music()

# Example usage
my_car = Car()
my_car.drive()
# Output:
# Engine started
# Car is driving
# Playing music
</code></pre>

<p>Dans cet exemple, la classe <code class="language-python">Car</code> utilise les classes <code class="language-python">Engine</code> et <code class="language-python">Radio</code> par composition, ce qui rend le code plus modulaire et plus facile à comprendre que si nous avions eu recours à l'héritage multiple pour regrouper ces fonctionnalités dans une seule classe.</p>

<p>En conclusion, bien que l'héritage hybride offre une certaine souplesse, il est essentiel de bien évaluer ses avantages par rapport à sa complexité potentielle. La composition constitue souvent une alternative plus judicieuse pour atteindre la réutilisation du code et la flexibilité, tout en conservant un code clair et maintenable. L'héritage hybride doit être utilisé avec prudence et uniquement lorsque ses avantages surpassent clairement les inconvénients liés à sa complexité.</p>
</p>
  </section>
</div>


<div class="content_box">
  <section>
    <h2 class="heading">7. Cas d'utilisation pratiques de l'héritage en Python</h2>
    <p><p>L'héritage est une fonctionnalité puissante de la programmation orientée objet qui favorise la réutilisation du code et la création de hiérarchies de classes. Il permet de définir de nouvelles classes basées sur des classes existantes, en héritant de leurs attributs et méthodes. Découvrons quelques cas d'utilisation pratiques.</p>

<p><strong>Modélisation de concepts du monde réel :</strong> L'héritage est idéal pour représenter les relations "est un" (<em>is-a</em>). Prenons l'exemple d'un <code class="language-python">Etudiant</code> qui <em>est une</em> <code class="language-python">Personne</code>. On peut définir une classe de base <code class="language-python">Personne</code> avec des attributs communs comme le nom et l'âge, puis créer une classe <code class="language-python">Etudiant</code> qui hérite de <code class="language-python">Personne</code> et ajoute des attributs spécifiques comme le numéro d'étudiant et la spécialisation. Ceci permet d'éviter la redondance et de structurer le code de manière logique.</p>
<pre><code class="language-python">
class Person:
    def __init__(self, name, age):
        self.name = name
        self.age = age

    def introduce(self):
        print(f"Hello, my name is {self.name} and I am {self.age} years old.")

class Student(Person):
    def __init__(self, name, age, student_id, major):
        # Call the constructor of the parent class (Person)
        super().__init__(name, age)
        self.student_id = student_id
        self.major = major

    def introduce(self):
        # Call the introduce method of the parent class
        super().introduce()
        print(f"I am a student with ID {self.student_id} majoring in {self.major}.")

# Example usage
student = Student("Alice", 20, "12345", "Computer Science")
student.introduce()
</code></pre>
<p>Dans cet exemple, la classe <code class="language-python">Student</code> hérite des attributs <code class="language-python">name</code> et <code class="language-python">age</code> de la classe <code class="language-python">Person</code>, et ajoute ses propres attributs <code class="language-python">student_id</code> et <code class="language-python">major</code>. La méthode <code class="language-python">super()</code> est utilisée pour appeler le constructeur de la classe parente et sa méthode <code class="language-python">introduce()</code>, ce qui permet de réutiliser le code et d'éviter les doublons.</p>

<p><strong>Factorisation du code :</strong> L'héritage permet de centraliser le code commun à plusieurs classes. Si plusieurs classes partagent des attributs ou des méthodes, il est préférable de créer une classe de base contenant ces éléments communs et de faire hériter les autres classes de cette classe de base. Cela simplifie la maintenance et la mise à jour du code. Considérons différents types de comptes bancaires :</p>
<pre><code class="language-python">
class BankAccount:
    def __init__(self, account_number, balance):
        self.account_number = account_number
        self.balance = balance

    def deposit(self, amount):
        self.balance += amount
        print(f"Deposited {amount}. New balance: {self.balance}")

    def withdraw(self, amount):
        if amount <= self.balance:
            self.balance -= amount
            print(f"Withdrew {amount}. New balance: {self.balance}")
        else:
            print("Insufficient funds.")

class SavingsAccount(BankAccount):
    def __init__(self, account_number, balance, interest_rate):
        # Call the constructor of the parent class (BankAccount)
        super().__init__(account_number, balance)
        self.interest_rate = interest_rate

    def apply_interest(self):
        interest = self.balance * self.interest_rate
        self.deposit(interest)
        print(f"Applied interest. New balance: {self.balance}")

class CheckingAccount(BankAccount):
    def __init__(self, account_number, balance, overdraft_limit):
        # Call the constructor of the parent class (BankAccount)
        super().__init__(account_number, balance)
        self.overdraft_limit = overdraft_limit

    def withdraw(self, amount):
        # Override the withdraw method to allow overdraft
        if amount <= self.balance + self.overdraft_limit:
            self.balance -= amount
            print(f"Withdrew {amount}. New balance: {self.balance}")
        else:
            print("Withdrawal exceeds overdraft limit.")

# Example usage
savings_account = SavingsAccount("SA123", 1000, 0.05)
savings_account.deposit(500)
savings_account.apply_interest()

checking_account = CheckingAccount("CA456", 500, 200)
checking_account.withdraw(600)
</code></pre>
<p>Ici, <code class="language-python">SavingsAccount</code> et <code class="language-python">CheckingAccount</code> héritent de <code class="language-python">BankAccount</code>, évitant de réécrire les méthodes <code class="language-python">deposit</code> et une partie de <code class="language-python">withdraw</code>.  La classe <code class="language-python">CheckingAccount</code> redéfinit (<em>overrides</em>) la méthode <code class="language-python">withdraw</code> pour implémenter une logique spécifique aux comptes courants, comme la gestion du découvert.</p>

<p><strong>Création de hiérarchies de classes :</strong> L'héritage permet de construire des hiérarchies de classes pour structurer le code de manière logique et intuitive. Ceci est particulièrement utile dans les grands projets où la complexité peut rapidement devenir un problème. Imaginons une application de dessin :</p>
<pre><code class="language-python">
class Shape:
    def __init__(self, color):
        self.color = color

    def draw(self):
        print("Drawing a shape")

class Rectangle(Shape):
    def __init__(self, color, width, height):
        # Call the constructor of the parent class (Shape)
        super().__init__(color)
        self.width = width
        self.height = height

    def draw(self):
        print(f"Drawing a {self.color} rectangle with width {self.width} and height {self.height}")

class Circle(Shape):
    def __init__(self, color, radius):
        # Call the constructor of the parent class (Shape)
        super().__init__(color)
        self.radius = radius

    def draw(self):
        print(f"Drawing a {self.color} circle with radius {self.radius}")

# Example usage
rectangle = Rectangle("red", 10, 5)
circle = Circle("blue", 7)

rectangle.draw()
circle.draw()
</code></pre>
<p>Dans cet exemple, <code class="language-python">Rectangle</code> et <code class="language-python">Circle</code> héritent de <code class="language-python">Shape</code>.  Chaque classe enfant redéfinit (<em>overrides</em>) la méthode <code class="language-python">draw()</code> pour fournir une implémentation spécifique à sa forme. Ceci illustre comment l'héritage permet d'organiser le code de manière modulaire et extensible.</p>

<p><strong>Extension de bibliothèques existantes :</strong>  L'héritage permet d'étendre ou de modifier le comportement de classes définies dans des bibliothèques existantes sans avoir à modifier directement le code de ces bibliothèques. Ceci est particulièrement utile lorsque l'on souhaite ajouter des fonctionnalités spécifiques à une classe existante. Imaginons une bibliothèque simple pour gérer des fichiers :</p>
<pre><code class="language-python">
# Assume this class is part of a library you don't want to modify directly
class FileManager:
    def __init__(self, filename):
        self.filename = filename

    def read_file(self):
        try:
            with open(self.filename, 'r') as f:
                return f.read()
        except FileNotFoundError:
            return "File not found."

# Extend the FileManager class to add logging functionality
class LoggedFileManager(FileManager):
    def __init__(self, filename, log_file):
        # Call the constructor of the parent class (FileManager)
        super().__init__(filename)
        self.log_file = log_file

    def read_file(self):
        # Extend the read_file method to add logging
        content = super().read_file()
        with open(self.log_file, 'a') as log:
            log.write(f"File '{self.filename}' was read.\n")
        return content

# Example usage
logged_file_manager = LoggedFileManager("my_file.txt", "log.txt")
file_content = logged_file_manager.read_file()
print(file_content)
</code></pre>
<p>La classe <code class="language-python">LoggedFileManager</code> hérite de <code class="language-python">FileManager</code> et ajoute une fonctionnalité de journalisation (<em>logging</em>) lors de la lecture du fichier. La méthode <code class="language-python">read_file()</code> est étendue pour écrire un message dans un fichier de log à chaque fois qu'un fichier est lu. Ceci permet de modifier le comportement de la classe <code class="language-python">FileManager</code> sans la modifier directement.</p>

<p>En résumé, l'héritage est un mécanisme puissant pour structurer le code, éviter la redondance, faciliter la réutilisation et étendre des fonctionnalités existantes. Les exemples présentés illustrent son application dans divers contextes, de la modélisation d'entités du monde réel à l'ajout de fonctionnalités à des bibliothèques existantes.  En comprenant et en utilisant l'héritage, vous pouvez écrire un code plus propre, plus maintenable et plus évolutif.</p>
</p>
    <h3>7.1 Frameworks GUI</h3>
    <p><p>Dans les frameworks d'interface graphique (GUI) tels que Tkinter ou PyQt, l'héritage est un mécanisme essentiel pour la création de composants d'interface utilisateur personnalisés. Il permet aux développeurs d'étendre les classes de widgets de base et de modifier leur comportement afin de répondre à des exigences spécifiques, favorisant ainsi la réutilisation du code et la modularité.</p>
<p>Prenons l'exemple de la création d'un bouton personnalisé avec une couleur de fond spécifique et un comportement particulier lors d'un clic. Pour cela, nous pouvons créer une nouvelle classe qui hérite de la classe <code class="language-python">Button</code> de Tkinter et redéfinir certaines de ses méthodes.</p>
<pre><code class="language-python">
import tkinter as tk

class CustomButton(tk.Button):
    """
    A custom button class inheriting from tk.Button.
    It allows setting a custom background color and executing a custom command on click.
    """
    def __init__(self, master=None, bg_color="lightblue", command=None, **kwargs):
        """
        Initializes the CustomButton with custom properties.
        Args:
            master: The parent widget.
            bg_color: The background color of the button. Defaults to "lightblue".
            command: The function to be executed when the button is clicked. Defaults to None.
            **kwargs: Additional keyword arguments to be passed to the tk.Button constructor.
        """
        super().__init__(master, bg=bg_color, command=self._on_click, **kwargs)
        self.custom_command = command

    def _on_click(self):
        """
        Internal method called when the button is clicked.
        Executes the custom command if provided.
        """
        print("Custom button clicked!")
        if self.custom_command:
            self.custom_command()

def my_custom_function():
    """
    A custom function to be executed when the button is clicked.
    """
    print("Custom function executed!")

if __name__ == '__main__':
    root = tk.Tk()
    root.title("Custom Button Example")

    # Create a custom button with a specific background color and command
    custom_button = CustomButton(root, text="Click Me!", bg_color="lightgreen", command=my_custom_function)
    custom_button.pack(pady=20)

    root.mainloop()
</code></pre>
<p>Dans cet exemple, la classe <code class="language-python">CustomButton</code> hérite de <code class="language-python">tk.Button</code>. Le constructeur <code class="language-python">__init__</code> appelle le constructeur de la classe parente via <code class="language-python">super()</code> et initialise la couleur de fond du bouton. La méthode <code class="language-python">_on_click</code> est redéfinie pour ajouter un comportement personnalisé lors du clic sur le bouton. Cela illustre comment l'héritage facilite la création de widgets personnalisés et réutilisables avec des fonctionnalités spécifiques.</p>
<p>L'héritage simplifie également la maintenance du code. Si le comportement de tous les boutons personnalisés doit être modifié, il suffit d'apporter les modifications nécessaires à la classe <code class="language-python">CustomButton</code>, plutôt que de modifier chaque instance individuellement. Cela garantit la cohérence et réduit le risque d'erreurs de manière significative.</p>
<p>En conclusion, l'héritage est un outil puissant dans les frameworks GUI, permettant de développer des interfaces utilisateur modulaires, réutilisables et faciles à maintenir, tout en réduisant la duplication de code et en améliorant l'organisation du projet.</p>
</p>
    <h3>7.2 Frameworks web</h3>
    <p><p>L'héritage est un concept clé dans le développement web Python, particulièrement au sein de frameworks comme Django et Flask. Il favorise la création d'un code modulaire, la réutilisation des composants et une organisation claire, des atouts indispensables pour gérer la complexité des applications web modernes.</p>

<p>Dans Django, l'héritage est massivement utilisé pour la définition des modèles de données via l'ORM (Object-Relational Mapper). Un modèle représente une table de la base de données, et l'héritage permet de créer des modèles spécialisés qui partagent une base commune. En héritant de la classe <code class="language-python">Model</code> de Django, un modèle hérite automatiquement des fonctionnalités essentielles comme l'interaction avec la base de données, la validation des données et la sérialisation.</p>

<p>Voici un exemple illustrant l'utilisation de l'héritage pour définir des modèles personnalisés dans Django:</p>

<pre><code class="language-python">
from django.db import models

# Define a base model for products
class Product(models.Model):
    name = models.CharField(max_length=200)
    description = models.TextField()
    price = models.DecimalField(max_digits=10, decimal_places=2)
    created_at = models.DateTimeField(auto_now_add=True) # Automatically set on creation
    updated_at = models.DateTimeField(auto_now=True)     # Automatically updated on each save

    def __str__(self):
        return self.name

# Inherit from Product to create a more specific model for books
class Book(Product):
    author = models.CharField(max_length=200)
    isbn = models.CharField(max_length=13)
    genre = models.CharField(max_length=100, default='Fiction')  # Add default value

    def __str__(self):
        return f"{self.name} by {self.author}"

# Inherit from Product to create a model for electronic devices
class ElectronicDevice(Product):
    brand = models.CharField(max_length=100)
    model_number = models.CharField(max_length=100)
    power_consumption = models.IntegerField(default=0) # Power consumption in Watts
    warranty_months = models.IntegerField(default=12)  # Warranty duration in months

    def __str__(self):
        return f"{self.brand} {self.model_number}"
</code></pre>

<p>Dans cet exemple, les classes <code class="language-python">Book</code> et <code class="language-python">ElectronicDevice</code> héritent de <code class="language-python">Product</code>. Elles héritent des champs de <code class="language-python">Product</code> (name, description, price, created_at, updated_at) et ajoutent leurs propres champs spécifiques (author, ISBN, genre pour <code class="language-python">Book</code> et brand, model_number, power_consumption, warranty_months pour <code class="language-python">ElectronicDevice</code>). Cette approche évite la redondance du code et clarifie la structure des données.  L'ajout des champs <code class="language-python">created_at</code> et <code class="language-python">updated_at</code> dans la classe parent <code class="language-python">Product</code> permet de suivre automatiquement la création et la modification des produits, ce qui est une pratique courante.</p>

<p>L'héritage trouve également son utilité dans les vues et les formulaires de Django, et de manière similaire dans Flask, en permettant l'extension des fonctionnalités de base et la personnalisation du comportement. Cela permet de structurer une hiérarchie de classes qui reflète l'architecture de l'application web, simplifiant ainsi la maintenance du code.</p>

<p>Par exemple, l'héritage peut servir à créer des vues génériques pour gérer des tâches récurrentes comme l'affichage de listes d'objets, la création de nouveaux objets ou la mise à jour d'objets existants. En héritant de ces vues génériques, il est possible de personnaliser leur fonctionnement en modifiant certaines méthodes ou en intégrant de nouvelles fonctionnalités spécifiques au besoin.</p>

<p>En résumé, l'héritage est un outil puissant dans les frameworks web Python, facilitant la création d'applications bien structurées, modulaires et faciles à maintenir. Il encourage la réutilisation du code, simplifie la gestion de la complexité et contribue à une architecture logicielle plus robuste.</p>
</p>
  </section>
</div>


<div class="content_box">
  <section>
    <h2 class="heading">8. Exercices sur l'héritage en Python</h2>
    <p><p>Pour consolider votre compréhension de l'héritage en Python, voici quelques exercices pratiques. Ils couvrent différents aspects, des bases aux concepts avancés comme l'héritage multiple, et vous permettront d'appliquer ce que vous avez appris.</p>

<p><strong>Exercice 1 : Héritage Simple</strong></p>
<p>Créez une classe de base nommée <code class="language-python">Forme</code> avec une méthode <code class="language-python">aire()</code> qui retourne 0. Ensuite, créez une classe dérivée nommée <code class="language-python">Cercle</code> qui hérite de <code class="language-python">Forme</code>. Redéfinissez la méthode <code class="language-python">aire()</code> dans la classe <code class="language-python">Cercle</code> pour calculer et retourner l'aire du cercle, en utilisant le rayon comme attribut. Cet exercice met en pratique le concept fondamental de l'héritage : la spécialisation d'une classe de base.</p>
<pre><code class="language-python">
import math

class Shape:
    def area(self):
        return 0

class Circle(Shape):
    def __init__(self, radius):
        self.radius = radius

    def area(self):
        # Calculate the area of the circle
        return math.pi * self.radius * self.radius

# Example usage
my_circle = Circle(5)
print(f"The area of the circle is: {my_circle.area()}")
</code></pre>

<p><strong>Exercice 2 : Héritage Multiple</strong></p>
<p>Définissez deux classes, <code class="language-python">Volant</code> et <code class="language-python">Nageant</code>, avec des méthodes <code class="language-python">voler()</code> et <code class="language-python">nager()</code> respectivement. Créez ensuite une classe <code class="language-python">Canard</code> qui hérite des deux classes. Implémentez les méthodes <code class="language-python">voler()</code> et <code class="language-python">nager()</code> dans la classe <code class="language-python">Canard</code> pour afficher un comportement spécifique. Cet exercice illustre comment une classe peut hériter des caractéristiques de plusieurs classes parentes, combinant ainsi différents comportements.</p>
<pre><code class="language-python">
class Flying:
    def fly(self):
        print("Cannot fly")

class Swimming:
    def swim(self):
        print("Cannot swim")

class Duck(Flying, Swimming):
    def fly(self):
        print("Duck is flying")

    def swim(self):
        print("Duck is swimming")

# Example usage
my_duck = Duck()
my_duck.fly()
my_duck.swim()
</code></pre>

<p><strong>Exercice 3 : Utilisation de <code class="language-python">super()</code></strong></p>

<p>Créez une classe parente <code class="language-python">Ordinateur</code> avec un constructeur initialisant un attribut <code class="language-python">marque</code>. Créez une classe enfant <code class="language-python">OrdinateurPortable</code> qui hérite de <code class="language-python">Ordinateur</code> et ajoute un attribut <code class="language-python">taille_ecran</code>. Utilisez <code class="language-python">super()</code> dans le constructeur de <code class="language-python">OrdinateurPortable</code> pour initialiser l'attribut <code class="language-python">marque</code> de la classe parente.  L'utilisation de <code class="language-python">super()</code> permet d'appeler le constructeur de la classe parente, assurant ainsi l'initialisation correcte des attributs hérités.</p>

<pre><code class="language-python">
class Computer:
    def __init__(self, brand):
        self.brand = brand

class Laptop(Computer):
    def __init__(self, brand, screen_size):
        # Call the constructor of the parent class
        super().__init__(brand)
        self.screen_size = screen_size

    def display_info(self):
        print(f"Brand: {self.brand}, Screen Size: {self.screen_size}")

# Example Usage
my_laptop = Laptop("Dell", 15.6)
my_laptop.display_info()
</code></pre>

<p><strong>Exercice 4 : Surcharge de méthodes</strong></p>
<p>Définissez une classe <code class="language-python">Instrument</code> avec une méthode <code class="language-python">jouer()</code> qui affiche un message générique. Créez ensuite des classes dérivées comme <code class="language-python">Piano</code> et <code class="language-python">Guitare</code> qui héritent de <code class="language-python">Instrument</code>. Redéfinissez la méthode <code class="language-python">jouer()</code> dans chaque classe dérivée pour afficher un message spécifique à l'instrument.  La surcharge de méthodes permet à chaque classe dérivée d'implémenter un comportement spécifique tout en conservant la même interface, ce qui est un principe clé du polymorphisme.</p>

<pre><code class="language-python">
class Instrument:
    def play(self):
        print("Playing a generic instrument")

class Piano(Instrument):
    def play(self):
        print("Playing the Piano")

class Guitar(Instrument):
    def play(self):
        print("Playing the Guitar")

# Example usage
instrument = Instrument()
piano = Piano()
guitar = Guitar()

instrument.play()
piano.play()
guitar.play()
</code></pre>

<p>Ces exercices vous fourniront une expérience pratique de l'implémentation de l'héritage en Python, couvrant les aspects essentiels tels que l'héritage simple, l'héritage multiple, l'utilisation de <code class="language-python">super()</code>, et la surcharge de méthodes. En modifiant et en complexifiant ces exercices, vous pourrez approfondir davantage votre compréhension et explorer les nombreuses possibilités offertes par l'héritage en Python.</p>
</p>
  </section>
</div>


<div class="content_box">
  <section>
    <h2 class="heading">9. Résumé et Comparaisons des types d'héritage</h2>
    <p><p>L'héritage en Python est un mécanisme puissant qui permet de créer des classes basées sur des classes existantes, favorisant la réutilisation du code et la modélisation de relations complexes. Python prend en charge différents types d'héritage, chacun adapté à des scénarios spécifiques. Le choix du type d'héritage approprié dépend de la structure et des besoins de votre application.</p>

<p><strong>Héritage Simple :</strong> C'est la forme la plus élémentaire d'héritage. Une classe enfant hérite d'une seule classe parent.  Cela établit une relation "est-un" claire et facilite la compréhension et la maintenance du code. La classe enfant hérite de tous les attributs et méthodes de la classe parent et peut les étendre ou les redéfinir.</p>
<pre><code class="language-python">
# Simple inheritance example
class Animal:
    def __init__(self, name):
        self.name = name

    def speak(self):
        return "Generic animal sound"

class Dog(Animal):
    def speak(self):
        return "Woof!"

my_dog = Dog("Buddy")
print(my_dog.speak()) # Output: Woof!
print(my_dog.name)  # Output: Buddy, demonstrating inheritance of attributes
</code></pre>

<p><strong>Héritage Multiple :</strong> Dans ce type d'héritage, une classe enfant peut hériter de plusieurs classes parents.  Cela permet de combiner les fonctionnalités de différentes classes en une seule classe. Cependant, l'héritage multiple peut entraîner des conflits de noms si plusieurs classes parents définissent des attributs ou des méthodes portant le même nom (problème dit "Diamond Problem"). Python résout ce problème en utilisant l'ordre de résolution des méthodes (MRO - Method Resolution Order), qui définit l'ordre dans lequel les classes parents sont recherchées pour trouver une méthode.</p>
<pre><code class="language-python">
# Multiple inheritance example
class Swimmer:
    def swim(self):
        return "Swimming..."

class Walker:
    def walk(self):
        return "Walking..."

class Amphibian(Swimmer, Walker):
    pass

frog = Amphibian()
print(frog.swim()) # Output: Swimming...
print(frog.walk()) # Output: Walking...

# Demonstrating MRO (Method Resolution Order)
print(Amphibian.__mro__) # Output: (&lt;class '__main__.Amphibian'&gt;, &lt;class '__main__.Swimmer'&gt;, &lt;class '__main__.Walker'&gt;, &lt;class 'object'&gt;)
</code></pre>

<p><strong>Héritage Multi-niveau :</strong> L'héritage multi-niveau se produit lorsqu'une classe hérite d'une classe qui hérite elle-même d'une autre classe. Cela crée une hiérarchie d'héritage à plusieurs niveaux. Il est crucial de s'assurer que chaque niveau de la hiérarchie ajoute une valeur significative et maintient la cohérence de la conception.</p>
<pre><code class="language-python">
# Multilevel inheritance example
class Grandparent:
    def has_wisdom(self):
        return True

class Parent(Grandparent):
    def has_experience(self):
        return True

class Child(Parent):
    def is_learning(self):
        return True

child = Child()
print(child.has_wisdom())    # Output: True
print(child.has_experience()) # Output: True
print(child.is_learning())   # Output: True
</code></pre>

<p><strong>Héritage Hiérarchique :</strong> Dans l'héritage hiérarchique, plusieurs classes enfants héritent d'une seule classe parent. Ce modèle est utile lorsque plusieurs classes partagent un ensemble commun d'attributs et de méthodes définis dans la classe parent.  Chaque classe enfant peut ensuite implémenter ses propres spécialisations.</p>
<pre><code class="language-python">
# Hierarchical inheritance example
class Shape:
    def area(self):
        return "Area not defined"

class Rectangle(Shape):
    def __init__(self, width, height):
        self.width = width
        self.height = height
    def area(self):
        return self.width * self.height

class Circle(Shape):
    def __init__(self, radius):
        self.radius = radius
    def area(self):
        return 3.14159 * self.radius * self.radius

rect = Rectangle(5, 10)
circ = Circle(7)
print(rect.area()) # Output: 50
print(circ.area()) # Output: 153.93791
</code></pre>

<p><strong>Héritage Hybride :</strong> L'héritage hybride est une combinaison de plusieurs types d'héritage (simple, multiple, multi-niveau et hiérarchique). Bien qu'il offre une grande flexibilité, il peut rendre la structure de la classe complexe et difficile à comprendre. Il est important de bien planifier la hiérarchie des classes pour éviter toute ambiguïté et assurer la maintenabilité du code.</p>
<pre><code class="language-python">
# Hybrid inheritance example (combination of multiple and hierarchical)
class Engine:
    def start(self):
        return "Engine started"

class ElectricEngine(Engine):
    def charge(self):
        return "Charging..."

class FuelEngine(Engine):
    def refuel(self):
        return "Refueling..."

class HybridCar(ElectricEngine, FuelEngine):
    pass

hybrid_car = HybridCar()
print(hybrid_car.start())  # Output: Engine started
print(hybrid_car.charge()) # Output: Charging...
print(hybrid_car.refuel()) # Output: Refueling...
</code></pre>

<p>En conclusion, le choix du type d'héritage dépend de la complexité et des exigences du projet. L'héritage simple est idéal pour les relations "est-un" directes, tandis que l'héritage multiple et hybride offrent une plus grande flexibilité pour les scénarios complexes. Une compréhension approfondie de chaque type d'héritage est essentielle pour concevoir des classes efficaces, maintenables et évolutives en Python. Il est important de considérer attentivement les compromis entre flexibilité et complexité lors du choix d'une stratégie d'héritage.</p>
</p>
    <h3>9.1 Tableau comparatif des types d'héritage</h3>
    <p><table>
  <thead>
    <tr>
      <th>Type d'héritage</th>
      <th>Description</th>
      <th>Avantages</th>
      <th>Inconvénients</th>
      <th>Exemple</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>Héritage simple</td>
      <td>Une classe hérite d'une seule classe parente, établissant une relation directe et unique.</td>
      <td>Simplicité et clarté du code, facilitant la compréhension et la maintenance. Réduction de la complexité globale du système.</td>
      <td>Manque de flexibilité dans les scénarios nécessitant l'héritage de multiples comportements ou attributs. Limitation de la réutilisation du code provenant de différentes sources.</td>
      <td>
        <pre><code class="language-python">
# Define a parent class Animal
class Animal:
    def __init__(self, name):
        self.name = name

    def speak(self):
        return "Generic animal sound"

# Define a child class Cat inheriting from Animal
class Cat(Animal):
    def speak(self):
        return "Meow!"

# Create an instance of Cat
my_cat = Cat("Whiskers")
print(my_cat.speak()) # Output: Meow!
</code></pre>
      </td>
    </tr>
    <tr>
      <td>Héritage multiple</td>
      <td>Une classe hérite simultanément de plusieurs classes parentes, combinant leurs attributs et méthodes.</td>
      <td>Augmentation de la réutilisation du code en intégrant des fonctionnalités provenant de différentes classes. Permet de modéliser des entités complexes avec des caractéristiques variées.</td>
      <td>Introduction potentielle de complexité, notamment le "Diamond Problem" (ambiguïté en cas de méthodes portant le même nom). Nécessite une gestion rigoureuse de l'ordre d'héritage et de la résolution des conflits de noms.</td>
      <td>
        <pre><code class="language-python">
# Define a class Swimmer
class Swimmer:
    def swim(self):
        return "Swimming"

# Define a class Runner
class Runner:
    def run(self):
        return "Running"

# Define a class Athlete inheriting from both Swimmer and Runner
class Athlete(Swimmer, Runner):
    pass

# Create an instance of Athlete
athlete = Athlete()
print(athlete.swim()) # Output: Swimming
print(athlete.run()) # Output: Running
</code></pre>
      </td>
    </tr>
    <tr>
      <td>Héritage multiniveau</td>
      <td>Une classe hérite d'une classe, qui hérite elle-même d'une autre classe, créant ainsi une chaîne d'héritage.</td>
      <td>Facilite une structuration logique et hiérarchique du code, permettant une spécialisation progressive des classes. Favorise l'extension des fonctionnalités à travers les niveaux de la hiérarchie.</td>
      <td>Risque de complexité accrue si la hiérarchie devient trop profonde, rendant le code difficile à comprendre et à maintenir. Les modifications apportées aux classes de base peuvent avoir des répercussions importantes sur les classes dérivées.</td>
      <td>
        <pre><code class="language-python">
# Define a class Grandparent
class Grandparent:
    def has_property(self):
        return "Has inherited property"

# Define a class Parent inheriting from Grandparent
class Parent(Grandparent):
    def has_skill(self):
        return "Has acquired skill"

# Define a class Child inheriting from Parent
class Child(Parent):
    def has_talent(self):
        return "Has developed talent"

# Create an instance of Child
child = Child()
print(child.has_property()) # Output: Has inherited property
print(child.has_skill()) # Output: Has acquired skill
print(child.has_talent()) # Output: Has developed talent
</code></pre>
      </td>
    </tr>
    <tr>
      <td>Héritage hiérarchique</td>
      <td>Plusieurs classes héritent directement d'une seule classe parente, formant une arborescence d'héritage.</td>
      <td>Permet de créer des classes spécialisées partageant une base commune, favorisant la réutilisation du code et la cohérence. Facilite la modélisation de catégories d'objets similaires avec des variations spécifiques.</td>
      <td>La classe de base peut devenir trop générale si elle doit répondre aux besoins spécifiques de toutes les classes dérivées, conduisant à une perte de spécificité. Risque de duplication de code si les classes dérivées ont des fonctionnalités similaires non factorisées dans la classe de base.</td>
      <td>
        <pre><code class="language-python">
# Define a class Shape
class Shape:
    def area(self):
        return "Area not defined"

# Define a class Rectangle inheriting from Shape
class Rectangle(Shape):
    def __init__(self, width, height):
        self.width = width
        self.height = height
    def area(self):
        return self.width * self.height

# Define a class Circle inheriting from Shape
class Circle(Shape):
    def __init__(self, radius):
        self.radius = radius
    def area(self):
        return 3.14 * self.radius * self.radius

# Create instances of Rectangle and Circle
rect = Rectangle(5, 10)
circ = Circle(7)
print(rect.area()) # Output: 50
print(circ.area()) # Output: 153.86
</code></pre>
      </td>
    </tr>
    <tr>
      <td>Héritage hybride</td>
      <td>Combinaison de plusieurs types d'héritage (simple, multiple, multiniveau, hiérarchique) pour modéliser des relations complexes.</td>
      <td>Offre une flexibilité maximale pour représenter des structures de données et des comportements complexes. Permet de combiner les avantages spécifiques de chaque type d'héritage.</td>
      <td>Très complexe à concevoir, à comprendre et à maintenir. Augmente considérablement le risque d'erreurs difficiles à diagnostiquer et à corriger. L'utilisation de la composition est souvent préférable pour éviter les pièges de l'héritage hybride.</td>
      <td>
        <pre><code class="language-python">
# Define a class Engine
class Engine:
    def start(self):
        return "Engine started"

# Define a class ElectricEngine inheriting from Engine
class ElectricEngine(Engine):
    def charge(self):
        return "Charging"

# Define a class FuelEngine inheriting from Engine
class FuelEngine(Engine):
    def refuel(self):
        return "Refueling"

# Define a class Vehicle
class Vehicle:
    pass

# Define a class Car inheriting from Vehicle and FuelEngine (multiple inheritance)
class Car(Vehicle, FuelEngine):
    pass

# Define a class ElectricCar inheriting from Vehicle and ElectricEngine (multiple inheritance)
class ElectricCar(Vehicle, ElectricEngine):
    pass

# Create instances of Car and ElectricCar
my_car = Car()
my_electric_car = ElectricCar()

print(my_car.start()) # Output: Engine started
print(my_car.refuel()) # Output: Refueling
print(my_electric_car.start()) # Output: Engine started
print(my_electric_car.charge()) # Output: Charging
</code></pre>
      </td>
    </tr>
  </tbody>
</table>
</p>
    <h3>9.2 Quand utiliser quel type d'héritage?</h3>
    <p><p>Le choix du type d'héritage approprié dépend des besoins spécifiques de votre projet. Chaque type a ses avantages et ses inconvénients, et certains sont plus adaptés à certaines situations que d'autres.</p>

<p><strong>Héritage Simple:</strong> C'est la forme d'héritage la plus simple et la plus courante. Utilisez l'héritage simple lorsque vous avez une relation "est-un" claire entre deux classes. Par exemple, une classe <code class="language-python">Avion</code> "est un" type de <code class="language-python">Vehicule</code>.</p>

<pre><code class="language-python">
class Vehicle:
    def __init__(self, brand, model):
        self.brand = brand
        self.model = model

    def display_info(self):
        print(f"Brand: {self.brand}, Model: {self.model}")

class Airplane(Vehicle):
    def __init__(self, brand, model, wingspan):
        super().__init__(brand, model) # Call the parent class's constructor
        self.wingspan = wingspan

    def display_info(self):
        super().display_info() # Call the parent class's display_info method
        print(f"Wingspan: {self.wingspan}")

# Example usage:
my_airplane = Airplane("Boeing", "747", "68.4 m")
my_airplane.display_info()
</code></pre>

<p><strong>Héritage Multiple:</strong> L'héritage multiple permet à une classe d'hériter de plusieurs classes parentes. Cela peut être utile pour combiner les fonctionnalités de différentes classes, mais cela peut également entraîner des problèmes de complexité et d'ambiguïté (le fameux "Diamond Problem"). Utilisez-le avec précaution et seulement lorsque c'est vraiment nécessaire. Il est crucial de bien comprendre l'ordre de résolution des méthodes (MRO - Method Resolution Order) dans ce cas.</p>

<pre><code class="language-python">
class Logger:
    def log(self, message):
        print(f"Log: {message}")

class Authorizer:
    def authorize(self, user):
        print(f"Authorizing user: {user}")

class Service(Logger, Authorizer):
    def run(self, user, action):
        self.authorize(user)
        print(f"Performing action: {action}")
        self.log(f"Action {action} performed by {user}")

# Example usage:
my_service = Service()
my_service.run("Alice", "Update database")
</code></pre>

<p><strong>Héritage Multi-niveau:</strong> L'héritage multi-niveau est une forme d'héritage où une classe hérite d'une classe enfant, qui hérite elle-même d'une classe parente. Cela peut être utilisé pour créer une hiérarchie de classes, mais il est important de veiller à ce que la hiérarchie reste claire et compréhensible. Une profondeur excessive peut rendre le code difficile à maintenir.</p>

<pre><code class="language-python">
class LivingBeing:
    def breathe(self):
        print("Living being is breathing.")

class Animal(LivingBeing):
    def eat(self):
        print("Animal is eating.")

class Mammal(Animal):
    def give_birth(self):
        print("Mammal is giving birth.")

# Example usage:
my_mammal = Mammal()
my_mammal.breathe()
my_mammal.eat()
my_mammal.give_birth()
</code></pre>

<p><strong>Héritage Hybride:</strong> L'héritage hybride est une combinaison de l'héritage simple, multiple et multi-niveau. Il est généralement complexe et difficile à maintenir. Évitez-le autant que possible. Si vous pensez avoir besoin d'un héritage hybride, examinez attentivement votre conception et voyez si vous pouvez la simplifier en utilisant d'autres techniques, comme la composition. L'héritage hybride peut rapidement devenir un cauchemar de maintenance.</p>

<p><strong>Héritage Cyclique:</strong> L'héritage cyclique se produit lorsque des classes héritent les unes des autres en formant un cycle (par exemple, A hérite de B, B hérite de C, et C hérite de A). Python détecte les cycles d'héritage directs et lève une exception <code class="language-python">TypeError</code>. Cependant, des cycles indirects peuvent survenir dans des structures complexes, rendant le code très difficile à comprendre et à déboguer. Évitez absolument l'héritage cyclique.</p>

<p><strong>Recommandations:</strong></p>
<ul>
    <li>Privilégiez l'héritage simple lorsque cela est possible.</li>
    <li>Utilisez l'héritage multiple avec parcimonie et uniquement lorsque cela apporte une valeur ajoutée significative. Soyez conscient des problèmes potentiels liés au "Diamond Problem" et utilisez <code class="language-python">super()</code> correctement pour gérer l'ordre de résolution des méthodes (MRO - Method Resolution Order).  Comprenez bien le MRO avec <code class="language-python">Class.mro()</code>.</li>
    <li>Évitez l'héritage hybride et cyclique autant que possible.</li>
    <li>Considérez la composition comme une alternative à l'héritage. La composition consiste à créer des objets en combinant d'autres objets, plutôt que d'hériter de leurs classes. Cela peut souvent conduire à une conception plus flexible et plus facile à maintenir.  Par exemple, au lieu de faire hériter une classe <code class="language-python">Voiture</code> d'une classe <code class="language-python">Moteur</code>, la classe <code class="language-python">Voiture</code> pourrait avoir un attribut qui est une instance de la classe <code class="language-python">Moteur</code>.</li>
</ul>

<p>En résumé, choisissez le type d'héritage le plus simple possible qui répond à vos besoins. Une conception de code claire et maintenable est toujours préférable à une solution complexe qui utilise des formes d'héritage avancées sans raison valable. La composition est souvent une alternative plus élégante et flexible à l'héritage multiple ou hybride. Pensez à utiliser des interfaces (classes abstraites en Python avec le module <code class="language-python">abc</code>) pour définir un comportement attendu sans imposer une implémentation particulière.</p>
</p>
  </section>
</div>


<div class="content_box">
  <section>
    <h2 class="heading">Conclusion</h2>
    <p><p>En conclusion, l'héritage est un pilier central de la programmation orientée objet en Python. Il offre la possibilité de structurer des hiérarchies de classes claires, concises et maintenables, encourageant ainsi la réutilisation du code et minimisant la redondance. Les cinq types d'héritage que nous avons examinés – simple, multiple, multiniveau, hiérarchique et hybride – fournissent une grande flexibilité pour la modélisation de systèmes complexes.</p>

<p>L'héritage simple, caractérisé par une relation parent-enfant directe, représente la forme la plus fondamentale et la plus largement utilisée. L'héritage multiple, bien que puissant, nécessite une gestion prudente pour éviter les complications potentielles associées au problème du "Diamond Problem" (héritage en losange). L'héritage multiniveau permet la création de chaînes d'héritage plus profondes et spécialisées, tandis que l'héritage hiérarchique offre une structure arborescente où une classe parent partage des attributs et des méthodes communs avec plusieurs classes enfants. Enfin, l'héritage hybride, combinant plusieurs de ces approches, offre une flexibilité maximale, mais requiert une conception méticuleuse pour garantir la cohérence et la maintenabilité.</p>

<p>Une compréhension approfondie de ces différents types d'héritage est essentielle pour développer du code Python propre, robuste et facile à maintenir. Prenons l'exemple d'un système de gestion de formes géométriques. Une classe de base <code class="language-python">GeometricShape</code> pourrait être définie, servant de point de départ pour l'héritage vers des classes plus spécifiques telles que <code class="language-python">Circle</code>, <code class="language-python">Rectangle</code>, et <code class="language-python">Square</code>. Cela permet d'éviter la duplication de code et de centraliser les propriétés et méthodes communes.</p>

<pre><code class="language-python">
class GeometricShape:
    """
    Base class for geometric shapes.  All specific shapes will inherit from this class.
    """
    def __init__(self, color="black"):
        """
        Initializes the geometric shape with a default color of black.
        """
        self.color = color

    def area(self):
        """
        Placeholder for area calculation.  Subclasses must implement this method.
        """
        raise NotImplementedError("Area calculation not implemented for this shape.")

    def display_color(self):
        """
        Displays the color of the shape.
        """
        print(f"The color of the shape is {self.color}.")


class Circle(GeometricShape):
    """
    Represents a circle, inheriting from GeometricShape.
    """
    def __init__(self, radius, color="black"):
        """
        Initializes the circle with a radius and a color.
        Calls the parent class's constructor using super().
        """
        super().__init__(color)
        self.radius = radius

    def area(self):
        """
        Calculates and returns the area of the circle.
        """
        return 3.14159 * self.radius * self.radius


class Rectangle(GeometricShape):
    """
    Represents a rectangle, inheriting from GeometricShape.
    """
    def __init__(self, width, height, color="black"):
        """
        Initializes the rectangle with a width, height, and a color.
        Calls the parent class's constructor using super().
        """
        super().__init__(color)
        self.width = width
        self.height = height

    def area(self):
        """
        Calculates and returns the area of the rectangle.
        """
        return self.width * self.height


# Example usage: creating instances of Circle and Rectangle
my_circle = Circle(radius=5, color="red")
my_rectangle = Rectangle(width=4, height=6, color="blue")

# Calling the area method on both instances
print(f"The area of the circle is: {my_circle.area()}")
print(f"The area of the rectangle is: {my_rectangle.area()}")

# Calling the display_color method on both instances
my_circle.display_color()
my_rectangle.display_color()
</code></pre>

<p>Toutefois, il est crucial de reconnaître que l'héritage n'est pas toujours la solution la plus appropriée. Une utilisation excessive peut entraîner des hiérarchies de classes complexes et difficiles à appréhender. Dans de nombreux cas, la composition – c'est-à-dire l'utilisation d'instances d'autres classes comme attributs – peut offrir une alternative plus souple et plus claire. Par exemple, au lieu de faire hériter une classe <code class="language-python">Car</code> d'une classe <code class="language-python">Engine</code>, on pourrait inclure une instance de <code class="language-python">Engine</code> comme attribut de la classe <code class="language-python">Car</code>.</p>

<p>En définitive, une maîtrise efficace de l'héritage en Python requiert un équilibre délicat entre l'exploitation de ses avantages et la reconnaissance de ses limites potentielles. En comprenant les différents types d'héritage disponibles et en évaluant attentivement les alternatives telles que la composition, vous serez en mesure de développer du code Python robuste, maintenable et adaptable aux exigences changeantes.</p>
</p>
  </section>
</div>


<!-- End of Course Marker -->
<div class="course-end-marker" style="margin: 4rem auto; text-align: center; max-width: 600px">
  <div style="height: 2px; background: linear-gradient(90deg, transparent, #fb5168 50%, transparent); margin: 2rem auto;"></div>
  <p style="color: #fb5168; font-size: 1.2rem; font-weight: 500; letter-spacing: 1px; opacity: 0.9;">
    That's all folks
  </p>
</div></div>
    </main>

    <!-- (Non-critical JS after DOM parsing) -->
    <script src="/src/js/back-to-top.js" type="module" defer></script>
    <script src="/src/js/include-footer.js" type="module" defer></script>
    <script src="/src/js/include-navbar.js" type="module" defer></script>
    <script src="/src/js/include-course-navbar.js" type="module" defer></script>
    <script src="/src/js/include-mobile-course-navbar.js" type="module" defer></script>
    <script src="/src/js/slider.js" type="module" defer></script>
    <script src="/src/js/copy-code-button.js" type="module" defer></script>
    <!-- (Non-critical JS after DOM parsing) -->

 </body>
</html>