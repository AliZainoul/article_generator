<!DOCTYPE html>
<html class="style-orange-3 custom_fonts comps live_website" lang="fr">
  <head>
    <!------------------- Essential Meta Tags ------------------>    
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta property="og:type" content="website" />
    <!------------------- Essential Meta Tags ------------------>    

    <!-------------------- Core SEO Elements -------------------->    
    <!-- Essential Title and SEO Meta Tags -->
    <title>Les properties en POO | Formateur</title>
    <meta name="description" content="Découvrez tout sur Les properties en POO dans cet article détaillé." />
    <meta property="og:title" content="Les properties en POO | Formateur" />
    <meta property="og:description" content="Découvrez tout sur Les properties en POO dans cet article détaillé." />
    <meta name="twitter:title" content="Les properties en POO | Formateur" />
    <meta name="twitter:description" content="Découvrez tout sur Les properties en POO dans cet article détaillé." />
    <!-- Essential Title and SEO Meta Tags -->
    <!-------------------- Core SEO Elements -------------------->    

    <!-- Structured Data -->
    <script type="application/ld+json">
    {
      "@context": "https://schema.org",
      "@graph": [
        {
          "@type": "Organization",
          "@id": "https://www.clearcode.fr/#organization",
          "name": "ClearCode",
          "url": "https://www.clearcode.fr",
          "logo": {
            "@type": "ImageObject",
            "url": "https://www.clearcode.fr/assets/images/og-image.png",
            "width": 1200,
            "height": 630
          },
          "description": "Formations en mathématiques et programmation IT"
        },
        {
          "@type": "BreadcrumbList",
          "itemListElement": [
            {
              "@type": "ListItem",
              "position": 1,
              "name": "Cours",
              "item": "https://www.clearcode.fr/cours"
            },
            {
              "@type": "ListItem",
              "position": 2,
              "name": "Programming",
              "item": "https://www.clearcode.fr/cours/programming"
            },
            {
              "@type": "ListItem",
              "position": 3,
              "name": "Python",
              "item": "https://www.clearcode.fr/cours/programming/python"
            },
            {
              "@type": "ListItem",
              "position": 4,
              "name": "Data Structures",
              "item": "https://www.clearcode.fr/cours/programming/python/data-structures"
            },
            {
              "@type": "ListItem",
              "position": 5,
              "name": "Mutable",
              "item": "https://www.clearcode.fr/cours/programming/python/data-structures/mutable"
            },
            {
              "@type": "ListItem",
              "position": 6,
              "name": "Les properties en POO",
              "item": "https://www.clearcode.fr/cours/programming/python/data-structures/mutable/lists"
            }
          ]
        },
        {
          "@type": "Article",
          "headline": "Les properties en POO",
          "description": "Découvrez les listes en Python, une structure de données mutable et flexible.",
          "image": "https://www.clearcode.fr/assets/images/og-image.png",
          "author": {
            "@type": "Organization",
            "name": "ClearCode"
          },
          "publisher": {
            "@type": "Organization",
            "name": "ClearCode",
            "logo": {
              "@type": "ImageObject",
              "url": "https://www.clearcode.fr/assets/images/og-image.png",
              "width": 1200,
              "height": 630
            }
          },
          "url": "https://www.clearcode.fr/cours/programming/python/data-structures/mutable/lists",
          "mainEntityOfPage": {
            "@type": "WebPage",
            "@id": "https://www.clearcode.fr/cours/programming/python/data-structures/mutable/lists"
          },
          "inLanguage": "fr"
        }
      ]
    }
    </script>
    <!-- End Structured Data -->


    <!-------------- Canonical and Alternate Links ------------->
    <link
      rel="canonical"
      href="https://www.clearcode.fr/cours/programming/python/data-structures/mutable/lists"
    />
    <link
      rel="alternate"
      href="https://www.clearcode.fr/cours/programming/python/data-structures/mutable/lists"
      hreflang="fr"
    />
    <meta
      name="twitter:url"
      content="https://www.clearcode.fr/cours/programming/python/data-structures/mutable/lists"
    />
    <meta
      property="og:url"
      content="https://www.clearcode.fr/cours/programming/python/data-structures/mutable/lists"
    />
    <meta name="robots" content="index, follow" />
    <!-------------- Canonical and Alternate Links ------------->

    <!----------------- Favicon and Assets ------------------->
    <!-- Favicon and Social Media Images -->
    <link
      rel="icon"
      type="image/png"
      href="https://www.clearcode.fr/assets/icons/favicon.ico"
      sizes="48x48"
    />
    <meta
      property="og:image"
      content="https://www.clearcode.fr/assets/images/og-image.png"
    />
    <meta property="og:image:width" content="1200" />
    <meta property="og:image:height" content="630" />
    <meta
      property="og:image:alt"
      content="ClearCode - Formations en mathématiques et programmation IT"
    />
    <meta property="og:image:type" content="image/png" />
    <!-- Fallback image format -->
    <meta
      property="og:image"
      content="https://www.clearcode.fr/assets/images/og-image.webp"
    />
    <meta
      name="twitter:image"
      content="https://www.clearcode.fr/assets/images/og-image.png"
    />
    <!----------------- Favicon and Assets ------------------->

    <!-- Stylesheets -->
    <link rel="stylesheet" href="/src/css/main.css" />
    <link rel="stylesheet" href="/src/css/dropdown.css" />
    <link rel="stylesheet" href="/src/css/mobile-course-navbar.css" />

    <!-- Prism.js core script -->
    <script
      src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"
      defer
    ></script>
    <!-- Prism.js language support for Python -->
    <script
      src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-python.min.js"
      defer
    ></script>
    <!-- Python Code CSS -->
    <link rel="stylesheet" href="/src/css/python-code.css" />

    <!-- Scripts -->
    <script src="/src/js/include-navbar.js" type="module" defer></script>
    <script src="/src/js/include-course-navbar.js" type="module" defer></script>
    <script src="/src/js/include-mobile-course-navbar.js" type="module" defer></script>
    <script src="/src/js/include-footer.js" type="module" defer></script>
    <script src="/src/js/slider.js" type="module" defer></script>
    <script src="/src/js/back-to-top.js" type="module" defer></script>
  </head>

  <body class="custom-google-fonts-enabled comps has-nocache">
    <main class="container">
      <!-- 0. TITRE -->
      <div class="content_box">
        <h1 class="heading heading--accent">Les properties en POO</h1>
      </div><div class="content_box">
  <section>
    <h2 class="heading">Introduction</h2>
    <p>Dans le monde fascinant de la programmation orientée objet (POO) avec Python, les <code class="language-python">properties</code> ou propriétés constituent un mécanisme puissant pour contrôler l'accès et la modification des attributs d'une classe. Imaginez une boîte noire où vous pouvez interagir avec des données internes sans nécessairement connaître les détails complexes de leur stockage. C'est exactement ce que les properties vous permettent de faire. Elles agissent comme une passerelle, interceptant les opérations de lecture, d'écriture et de suppression sur les attributs, et vous offrant la possibilité d'exécuter du code supplémentaire avant ou après ces opérations.

Les propriétés en Python ne sont pas de simples variables. Elles sont, en réalité, des méthodes spéciales qui sont invoquées lorsque vous tentez d'accéder, de modifier ou de supprimer la valeur d'un attribut. Cette technique est cruciale pour l'encapsulation, un des piliers de la POO. L'encapsulation, c'est la capacité à masquer les détails internes d'une classe et à n'exposer que ce qui est nécessaire, protégeant ainsi les données et garantissant une meilleure maintenabilité du code.

Prenons un exemple concret. Supposons que vous construisiez une classe <code class="language-python">Rectangle</code>. Un de ses attributs pourrait être la surface. Cependant, la surface n'est pas une donnée que vous souhaitez enregistrer directement. Elle est calculée à partir de la longueur et de la largeur. Utiliser une property permet de calculer la surface à chaque fois qu'elle est demandée, assurant ainsi la cohérence des données et simplifiant la gestion de la classe.

Voici un exemple simple pour illustrer ce concept :

<div class="python-code">
    <pre><code class="language-python">
class Rectangle:
    def __init__(self, length, width):
        self._length = length
        self._width = width

    # Getter method for length
    @property
    def length(self):
        return self._length

    # Setter method for length
    @length.setter
    def length(self, value):
        if value > 0:
            self._length = value
        else:
            raise ValueError("Length must be positive")

    # Getter method for width
    @property
    def width(self):
        return self._width

    # Setter method for width
    @width.setter
    def width(self, value):
        if value > 0:
            self._width = value
        else:
            raise ValueError("Width must be positive")

    # Property for area (calculated on the fly)
    @property
    def area(self):
        return self._length * self._width

# Example usage
rectangle = Rectangle(5, 10)
print(f"Initial area: {rectangle.area}")  # Output: Initial area: 50

rectangle.length = 8
print(f"New area: {rectangle.area}")  # Output: New area: 80

try:
    rectangle.width = -2  # This will raise a ValueError
except ValueError as e:
    print(e) # Output: Width must be positive
    </code></pre>
</div>

Dans ce code, chaque fois que vous accédez à <code class="language-python">rectangle.area</code>, la méthode <code class="language-python">area</code> est automatiquement exécutée. De même, les méthodes <code class="language-python">length</code> et <code class="language-python">width</code> agissent comme des intercepteurs pour l'accès et la modification des attributs internes <code class="language-python">_length</code> et <code class="language-python">_width</code>. Les <code class="language-python">@property</code>, <code class="language-python">@length.setter</code> et <code class="language-python">@width.setter</code> sont appelés des décorateurs, une fonctionnalité spécifique de Python qui simplifie la syntaxe de l'implémentation des propriétés.

Les properties offrent de nombreux avantages :

<ul>
    <li><code class="language-python">Encapsulation</code> : Elles cachent les détails internes et abstraient la complexité des calculs ou de validation.</li>
    <li><code class="language-python">Validation des données</code> : Vous pouvez contrôler les valeurs assignées aux attributs, assurant ainsi l'intégrité des données.</li>
    <li><code class="language-python">Calcul à la volée</code> : Elles permettent de calculer des valeurs dynamiquement, comme dans l'exemple de la surface, sans avoir à les stocker.</li>
    <li><code class="language-python">Flexibilité</code> : Elles fournissent un point d'entrée unique pour interagir avec les attributs, ce qui facilite les modifications et l'amélioration du code.</li>
</ul>

En somme, les properties en Python constituent un outil essentiel pour écrire du code orienté objet de qualité. Elles favorisent la clarté, la maintenabilité et la robustesse de vos applications. Dans les sections suivantes, nous explorerons plus en détail les différentes façons d'utiliser les properties, leurs avantages et leurs cas d'utilisation.</p>
  </section>
</div>
<div class="content_box">
  <section>
    <h2 class="heading">1. 1. Comprendre l'Encapsulation et le Besoin des Properties en Python</h2>
    <p><p>En programmation orientée objet (POO), l’<strong>encapsulation</strong> est un principe clé qui consiste à regrouper les données (attributs) et les fonctions (méthodes) manipulant ces données au sein d’une <code class="language-python">class</code>, tout en <strong>restreignant l’accès direct aux attributs</strong>. Son objectif principal est de garantir l’intégrité des données en contrôlant comment elles sont lues, modifiées ou calculées. C’est justement ce besoin de contrôler l’accès qui motive l’usage des <strong>properties</strong> en Python.</p>

<p>Prenons un exemple concret : une classe modélisant un compte bancaire. Sans encapsulation, les attributs comme <code class="language-python">balance</code> (solde) pourraient être modifiés directement, ce qui est risqué (ex: solde négatif non autorisé). Le code suivant illustre ce problème :</p>

<div class="python-code">
    <pre><code class="language-python">
# Non-encapsulated example: risk of invalid data
class SimpleBankAccount:
    def __init__(self, owner, initial_balance=0):
        self.owner = owner
        self.balance = initial_balance  # Public attribute, freely accessible

account = SimpleBankAccount("Alice")
account.balance = -1000  # Impossible validation: invalid negative balance
    </code></pre>
</div>

<p>Pour résoudre cela, l’encapsulation impose de faire passer par des <strong>méthodes d’accès</strong> (<em>getters</em> et <em>setters</em>). Voici une première solution en rendant l’attribut privé :</p>

<div class="python-code">
    <pre><code class="language-python">
# Basic encapsulation with getters and setters
class EncapsulatedAccount:
    def __init__(self, owner, balance=0):
        self._balance = balance  # Private attribute (naming convention)
        self.owner = owner

    def get_balance(self):
        """Get the balance."""
        return self._balance

    def set_balance(self, new_balance):
        """Update the balance with validation."""
        if new_balance >= 0:
            self._balance = new_balance
        else:
            raise ValueError("Balance cannot be negative")

account = EncapsulatedAccount("Bob")
account.set_balance(500)          # OK
# account.set_balance(-200)       # Raises an error if uncommented
    </code></pre>
</div>

<p>Malgré le contrôle, ce mécanisme force l’utilisateur de la classe à appeler <code class="language-python">get_balance()</code> et <code class="language-python">set_balance()</code> à chaque interaction, ce qui rompt l’illusion de l’accès direct aux attributs. Voici où <strong>les properties</strong> (via <code class="language-python">@property</code>) offrent une solution plus naturelle :</p>

<div class="python-code">
    <pre><code class="language-python">
# Implementation with properties for a fluid syntax
class PropertyAccount:
    def __init__(self, owner, balance=0):
        self._balance = balance  # Backing attribute
        self.owner = owner

    @property
    def balance(self):
        """Getter: Returns the balance with documentation."""
        return self._balance

    @balance.setter
    def balance(self, new_balance):
        """Setter with transparent validation logic."""
        if new_balance >= 0:
            self._balance = new_balance
        else:
            raise ValueError("Invalid balance")

    @property
    def overdraft_limit(self):
        """Computed method (no base attribute)."""
        return self._balance - 750  # Example of business logic

# Natural usage thanks to properties
alice_account = PropertyAccount("Alice", 1500)
alice_account.balance = 300         # Uses the setter
print(alice_account.balance)       # Calls the getter → "300"
# alice_account.balance = -50       # Raises an error
print(alice_account.overdraft_limit)  # Dynamic calculation → "1500 - 750" = 750
    </code></pre>
</div>

<p>Cette approche apporte plusieurs avantages techniques spécifiques à Python :</p>
<ul>
    <li><code class="language-python">@property</code> : Decorator to redirect read accesses to a method</li>
    <li><code class="language-python">@.setter</code> : Completes the decorator to handle write assignments</li>
    <li>Encapsulation transparente : L’API extérieure ressemble à l’accès direct aux attributs</li>
    <li>Logique métier centralisée : La validation se fait une seule fois, pas à chaque appel manuel</li>
</ul>

<p>En résumé, les <strong>properties</strong> en Python combinent encapsulation et simplicité utilisateur, rendant le code plus robuste sans sacrifier la lisibilité ou le confort d’usage.</p></p>
    <h3>1.1 1.1 Accès Direct aux Attributs vs. Encapsulation en POO Python</h3>
    <p>```html
<p>L'accès direct aux attributs d'un objet en Python, bien que pratique, peut entraîner des problèmes majeurs de maintenance et de robustesse. En POO, l'encapsulation consiste à cacher l'état interne d'un objet et à le contrôler via des méthodes. Cela permet de garantir l'intégrité des données et de modifier le fonctionnement interne sans affecter le code externe. Voyons pourquoi l'accès direct pose des défis.</p>

<h3>Problèmes de l'accès direct aux attributs</h3>

<ul>
    <li><code class="language-python">Maintenance difficile</code> : Si la logique interne change (ex: ajout de validation), le code existant qui accède directement à l'attribut peut cesser de fonctionner.</li>
    <li><code class="language-python">Absence de contrôle</code> : Les valeurs invalides peuvent être assignées sans vérification.</li>
    <li>Risque de <strong>violations d'invariant</strong> : L'objet peut se retrouver dans un état non cohérent.</li>
</ul>

<h3>Exemple concret : Un système de gestion de températures</h3>

<p>Supposons une classe <code class="language-python">Temperature</code> qui enregistre des valeurs en degrés Celsius :</p>

<div class="python-code">
    <pre><code class="language-python">
class Temperature:
    def __init__(self, celsius):
        self.celsius = celsius  # Direct access without validation
    </code></pre>
</div>

<p>Un utilisateur peut créer un objet et modifier la température directement :</p>

<div class="python-code">
    <pre><code class="language-python">
temp = Temperature(25)
temp.celsius = -300  # Physically impossible value (-273.15°C is absolute zero)
print(temp.celsius)  # Output: -300
    </code></pre>
</div>

<p>Ce code fonctionne, mais il viole les lois de la physique. Si plus tard, on décide d'ajouter une validation pour interdire les valeurs en dessous du zéro absolu :</p>

<div class="python-code">
    <pre><code class="language-python">
class Temperature:
    def __init__(self, celsius):
        self.set_celsius(celsius)  # Using a method for setting
    
    def set_celsius(self, value):
        if value < -273.15:
            raise ValueError("Invalid temperature!")
        self._celsius = value  # Storing in a "protected" attribute
    
    def get_celsius(self):
        return self._celsius
    </code></pre>
</div>

<p>Cette modification brise le code existant qui accède directement à <code class="language-python">temp.celsius</code>. Les utilisateurs doivent désormais passer par <code class="language-python">set_celsius()</code> et <code class="language-python">get_celsius()</code>, ce qui nécessite une refonte du code dépendant. C'est un <strong>cas classique de violation de l'encapsulation</strong>.</p>

<h3>Caractéristiques Pythoniques</h3>

<p>En Python :</p>
<ol>
    <li>Il n'existe pas de modificateurs d'accès (<code class="language-python">private</code> ou <code class="language-python">protected</code>), contrairement à Java ou C++.</li>
    <li>Les attributs commençant par un tiret bas (<code class="language-python">_attribute</code>) indiquent une convention de non-accessibilité publique, mais restent accessibles.</li>
    <li>L'encapsulation est donc <strong>volontaire</strong> et repose sur la collaboration des développeurs.</li>
</ol>

<p>Cette approche, appelée "We're all consenting adults", permet une grande flexibilité mais exige une rigueur pour éviter les erreurs. Les <strong>properties</strong> (sujet de la section suivante) offrent une solution optimale en combinant accès fluide et contrôle encapsulé.</p>
```</p>
    <h3>1.2 1.2 Les Limitations des Méthodes Getter et Setter Classiques en Python</h3>
    <p>Bien sûr, je suis prêt à vérifier et corriger le contenu de votre section "1.2 Les Limitations des Méthodes Getter et Setter Classiques en Python" pour votre article sur les properties en Python.

**Veuillez me fournir le contenu généré que vous souhaitez que je vérifie et corrige.**

Une fois que vous m'aurez fourni le texte, je suivrai scrupuleusement toutes les règles de formatage HTML et les critères de qualité que vous avez définis pour vous fournir une version impeccable et optimisée.

J'attends votre contenu pour commencer la vérification et la correction.</p>
    <h3>1.3 1.3 Introduction aux Properties comme Solution Pythonique</h3>
    <p><p>Les properties en Python offrent une solution élégante et "pythonique" pour gérer l'accès aux attributs d'une classe.  Elles agissent comme une "interface intelligente" qui s'interpose entre l'utilisateur de la classe et la donnée brute (l'attribut).  Cette interface vous permet de conserver la simplicité d'accès direct à un attribut (comme s'il était public) tout en bénéficiant des avantages de l'encapsulation.</p>

<p>Concrètement, une property vous donne le pouvoir d'exécuter du code personnalisé chaque fois qu'un attribut est lu, modifié, ou supprimé.  Ce code peut effectuer des validations, des transformations, ou toute autre logique avant de renvoyer la valeur à l'utilisateur, d'accepter une modification, ou de procéder à la suppression.  Imaginez une property comme un gardien vigilant, qui surveille et contrôle l'accès à un attribut précieux.</p>

<p>Pour créer une property, Python utilise des décorateurs.  Un décorateur, en Python, est une manière concise d'appliquer une fonction (ou, dans ce cas, un comportement) à une autre fonction (ou méthode) sans modifier directement le code de cette dernière. Le décorateur principal pour les properties est <code class="language-python">@property</code>. Il est suivi de méthodes spécifiques qui définissent le comportement de la property lors de la lecture (getter), de l'écriture (setter) et de la suppression (deleter) de l'attribut.</p>

<p>Jetons un coup d'œil à un exemple concret. Supposons que nous créions une classe pour représenter un cercle et que nous souhaitions contrôler le rayon:</p>

<div class="python-code">
<pre><code class="language-python">
class Circle:
    def __init__(self, initial_radius):
        # We use a "private" attribute to store the actual radius.
        self._radius = initial_radius

    @property
    def radius(self):
        # The getter method. Called when someone accesses the 'radius' attribute.
        print("Getting radius") #Imagine, log actions
        return self._radius

    @radius.setter
    def radius(self, new_radius):
        # The setter method. Called when someone assigns a value to the 'radius' attribute.
        print("Setting radius") #Or interact with a database
        if new_radius &lt; 0:
            raise ValueError("Radius cannot be negative")
        self._radius = new_radius

    @radius.deleter
    def radius(self):
        #The deleter.
        print("Deleting radius")#Clean-up actions
        del self._radius
</code></pre>
</div>

<p>Dans cet exemple :</p>
<ul>
    <li><code class="language-python">_radius</code> :  C'est l'attribut "privé" (conventionnellement, un attribut commençant par un underscore est considéré comme privé en Python). C'est ici que la valeur réelle du rayon est stockée.</li>
    <li><code class="language-python">@property</code> :  Ce décorateur transforme la méthode <code class="language-python">radius</code> en getter.  Lorsque vous accédez à <code class="language-python">circle.radius</code>, c'est cette méthode qui est exécutée.</li>
    <li><code class="language-python">@radius.setter</code> :  Ce décorateur transforme la deuxième méthode <code class="language-python">radius</code> en setter.  Elle est appelée lorsque vous essayez d'assigner une valeur à <code class="language-python">circle.radius</code> (par exemple, <code class="language-python">circle.radius = 5</code>). Ici, nous vérifions que le rayon n'est pas négatif.</li>
   <li><code class="language-python">@radius.deleter</code>: Ce décorateur associe la fonction deleter.</li>
</ul>

<p>Voyons maintenant comment utiliser cette classe :</p>

<div class="python-code">
<pre><code class="language-python">
# Create a Circle instance
my_circle = Circle(5)

# Accessing the radius (calls the getter)
print(my_circle.radius)

# Setting a new radius (calls the setter)
my_circle.radius = 10
print(my_circle.radius)

# Trying to set a negative radius (raises ValueError)
try:
    my_circle.radius = -5
except ValueError as e:
    print(e)

#Delete the radius
del my_circle.radius

#Try to access it will throw and error
try:
    print(my_circle.radius)
except AttributeError as e:
    print(e)
</code></pre>
</div>

<p>Ce code démontre la puissance des properties.  L'utilisateur de la classe <code class="language-python">Circle</code> interagit avec <code class="language-python">radius</code> comme s'il s'agissait d'un simple attribut.  Cependant, en coulisses, les méthodes getter et setter de la property sont exécutées, permettant la validation et la gestion de l'accès à la donnée.  Le code reste propre, lisible, et respecte les principes de l'encapsulation, grâce à la nature "pythonique" des properties.</p></p>
  </section>
</div>
<div class="content_box">
  <section>
    <h2 class="heading">2. 2. Définir une Property en Python : Le Décorateur `@property`</h2>
    <p><p>Les properties en Python offrent une manière élégante de gérer l'accès aux attributs d'une classe en utilisant des méthodes spécialisées. Le décorateur <code class="language-python">@property</code> permet de définir une propriété qui encapsule des logiques de validation ou de calcul tout en maintenant une interface simple et intuitive pour l'utilisateur.</p>

<p>Pour créer une property, on suit généralement ces étapes :</p>

<ol>
    <li><code class="language-python">@property</code> : Définit la méthode comme getter pour accéder à l'attribut</li>
    <li><code class="language-python">@nom_property.setter</code> : Permet de modifier l'attribut avec validation</li>
    <li><code class="language-python">@nom_property.deleter</code> : Contrôle la suppression de l'attribut</li>
</ol>

<p>Voici un exemple concret utilisant une classe <code class="language-python">Book</code> pour illustrer le mécanisme :</p>

<div class="python-code">
    <pre><code class="language-python">
class Book:
    def __init__(self, title, page_count):
        self._title = title
        self.page_count = page_count  # Uses the setter for validation

    @property
    def title(self):
        """Retrieve the book title"""
        return self._title

    @property
    def page_count(self):
        """Get the validated page count"""
        return self._page_count

    @page_count.setter
    def page_count(self, value):
        """Validate page count is a positive integer"""
        if not isinstance(value, int) or value <= 0:
            raise ValueError("Page count must be a positive integer")
        self._page_count = value

# Usage
novel = Book("1984", 328)
print(novel.title)           # Access via the getter
novel.page_count = 400       # Modification via the setter
try:
    novel.page_count = -50   # Triggers an error
except ValueError as e:
    print(f"Error: {e}")
    </code></pre>
</div>

<p>Points clés à retenir :</p>
<ul>
    <li><code class="language-python">@property</code> transforme une méthode en attribut en lecture seule par défaut</li>
    <li>Les setters permettent d'ajouter des validations sans changer l'API publique</li>
    <li>La convention <code class="language-python">_variable</code> indique une variable interne protégée</li>
</ul>

<p>Un cas avancé montre comment créer des propriétés calculées dynamiquement. Observons une classe <code class="language-python">Triangle</code> :</p>

<div class="python-code">
    <pre><code class="language-python">
class Triangle:
    def __init__(self, a, b, c):
        self.a = a
        self.b = b
        self.c = c

    @property
    def perimeter(self):
        """Calculate perimeter dynamically"""
        return self.a + self.b + self.c

    @property
    def is_valid(self):
        """Check triangle inequality theorem"""
        return (self.a + self.b > self.c) and \
               (self.a + self.c > self.b) and \
               (self.b + self.c > self.a)

# Instance creation
tri = Triangle(3, 4, 5)
print(f"Perimeter: {tri.perimeter}")  # 12
print(f"Valid: {tri.is_valid}")       # True
tri.c = 10
print(f"Valid: {tri.is_valid}")       # False
    </code></pre>
</div>

<p>Ce dernier exemple démontre comment les properties peuvent :</p>
<ul>
    <li>Calculer des valeurs à la volée</li>
    <li>Maintenir des règles de cohérence métier</li>
    <li>Fournir une interface unifiée pour des attributs dérivés</li>
</ul>

<p>En maîtrisant les properties, les développeurs Python peuvent créer des APIs plus robustes et maintenables tout en respectant les principes d'encapsulation.</p></p>
    <h3>2.1 2.1 Le Décorateur `@property` : Syntaxe et Fonctionnement de Base</h3>
    <p>Le décorateur <code class="language-python">@property</code> est l'outil principal pour définir des properties en Python. Il offre une syntaxe élégante et permet d'encapsuler l'accès aux attributs d'une classe de manière contrôlée.

<p>En termes simples, le décorateur <code class="language-python">@property</code> transforme une méthode en une property, ce qui signifie que la méthode peut être accédée comme si c'était un simple attribut. Lorsqu'on accède à la property (par exemple : <code class="language-python">objet.property_name</code>), la méthode décorée avec <code class="language-python">@property</code> (le "getter") est automatiquement exécutée. Cela permet d'ajouter une logique personnalisée lors de l'accès à la valeur de l'attribut, comme la validation des données ou le calcul de la valeur à la volée.</p>

<p>Analysons cela avec un exemple concret. Imaginez une classe <code class="language-python">BlogPost</code> qui représente un article de blog. Nous allons implémenter une property pour le nombre de mots du contenu du blog, qui sera calculé à chaque fois, évitant ainsi de stocker cette information en mémoire.</p>

<div class="python-code">
    <pre><code class="language-python">
class BlogPost:
    """Represents a blog post."""

    def __init__(self, title, content):
        """Initializes a BlogPost object."""
        self.title = title
        self.content = content

    @property
    def word_count(self):
        """Returns the number of words in the content."""
        # Splits the content into words and returns the count.
        words = self.content.split()
        return len(words)

# Create a BlogPost instance
my_post = BlogPost("My Awesome Article", "This is the content of my blog post.  It is a very interesting article.")

# Access the word_count property
print(my_post.word_count)  # Output: 14
    </code></pre>
</div>

<p>Dans cet exemple:</p>
<ul>
    <li><code class="language-python">word_count</code> : La méthode <code class="language-python">word_count</code> est décorée avec <code class="language-python">@property</code>.</li>
    <li>Lorsque nous accédons à <code class="language-python">my_post.word_count</code>, la méthode <code class="language-python">word_count</code> est exécutée. Elle prend donc le contenu du blog et calcule le nombre de mots.</li>
    <li>Nous n'appelons pas <code class="language-python">word_count()</code> comme une méthode normale avec des parenthèses, mais comme un simple attribut : Python gère l'appel de la méthode en arrière-plan.</li>
</ul>

<p>Le décorateur <code class="language-python">@property</code> simplifie l'encapsulation et facilite la maintenance du code. Il permet de modifier la manière dont une donnée est exposée sans impacter directement le code qui l'utilise. Il améliore également la lisibilité en permettant aux utilisateurs de la classe d'accéder à des valeurs calculées de manière intuitive.</p></p>
    <h3>2.2 2.2 Créer une Property Read-Only (Lecture Seule) en Python</h3>
    <p>Par défaut, les properties définies en Python à l'aide du décorateur <code class="language-python">@property</code> sont en lecture seule. Autrement dit, vous pouvez accéder à la valeur via la property, mais vous ne pouvez pas la modifier directement. Si vous tentez de le faire sans définir de méthode setter (expliqué plus tard dans cet article), une exception <code class="language-python">AttributeError</code> sera levée. Ceci renforce le principe d'encapsulation et permet de contrôler l'accès aux données d'un objet.

<p>Prenons l'exemple d'une classe représentant un fichier.</p>

<div class="python-code">
    <pre><code class="language-python">
class File:
    def __init__(self, filename, size_kb):
        self._filename = filename
        self._size_kb = size_kb  # Size in kilobytes

    @property
    def filename(self):
        """
        Property to get the filename.  Read-only.
        Could perform some logic here before returning the value,
        like checking if the file exists.
        """
        return self._filename

    @property
    def size_mb(self):
        """
        Property to calculate the file size in megabytes. Read-only.
        Demonstrates calculated properties.
        """
        return self._size_kb / 1024  # Conversion from KB to MB
</code></pre>
</div>

<p>Dans cet exemple, nous avons deux properties : <code class="language-python">filename</code> et <code class="language-python">size_mb</code>. La propriété <code class="language-python">filename</code> renvoie simplement le nom du fichier, tandis que <code class="language-python">size_mb</code> calcule la taille du fichier en mégaoctets à partir de la taille en kilo-octets.</p>

<p>Maintenant, créons une instance de la classe <code class="language-python">File</code> et essayons de modifier la property <code class="language-python">filename</code>.</p>

<div class="python-code">
    <pre><code class="language-python">
my_file = File("document.txt", 2048)  # File of 2 MB (2048 KB)

print(f"Original filename: {my_file.filename}")
print(f"File size in MB: {my_file.size_mb}")

try:
    my_file.filename = "report.pdf"  # Attempt to change the filename
except AttributeError as e:
    print(f"Error: {e}")
</code></pre>
</div>

<p>L'exécution de ce code affichera l'erreur suivante, car l'assignation directe à <code class="language-python">filename</code> n'est pas permise :</p>

<p><code>Error: can't set attribute 'filename'</code></p>

<p>Cela démontre clairement que sans un <code class="language-python">setter</code> explicitement défini, une property créée avec <code class="language-python">@property</code> est en lecture seule. Vous ne pouvez que lire la valeur, mais pas la modifier directement via l'affectation.</p></p>
    <h3>2.3 2.3 Accéder à l'attribut 'Privé' Sous-jacent avec le Getter de la Property</h3>
    <p>```html
<p>Le getter d'une property, décoré avec <code>@property</code>, agit comme un pont contrôlé entre l'extérieur de la classe et un attribut stocké en interne avec un préfixe <code>_</code>. Il permet d'exposer une valeur sans exposer directement le mécanisme de stockage. Voici un exemple clair :</p>

<div class="python-code">
    <pre><code class="language-python">
class SoftwareLicense:
    def __init__(self, expiry_date):
        self._expiration_date = expiry_date  # Internal attribute marked as private by convention

    @property
    def expiration(self):
        """Getter that accesses the private attribute, ensured"""
        return self._expiration_date
    </code></pre>
</div>

<p>Dans cette classe <strong>SoftwareLicense</strong> :</p>
<ul>
    <li><code class="language-python">_expiration_date</code> : Le nom <code>_expiration_date</code> indique que cet attribut est privé par convention selon PEP 8.</li>
    <li><code class="language-python">expiration()</code> : La méthode <code>@property</code> <code>expiration()</code> expose une interface légitime pour accéder à la valeur, évitant un accès direct à l'attribut.</li>
    <li><code>my_license.expiration</code> : Lorsque vous appelez <code>my_license.expiration</code>, Python exécute automatiquement ce getter et retourne la valeur stockée.</li>
</ul>

<p>La propriété agit comme un "portail" :<br>
- <strong>Interopérabilité</strong> : Le code extérieur incrémente l'attribut comme s'il était accessible directement (grâce au décorateur <code>@property</code>).<br>
- <strong>Contrôle</strong> : Si vous souhaitez modifier ultérieurement le mécanisme de stockage (ex.: calculer l'expiration à la volée), vous n'avez pas à changer l'interface.</p>

<p>Simon note technique :<br>
Python ne bloque pas un accès à <code>_expiration_date</code> — le tiret bas est une convention, pas une protection technique. Cependant, cela indique aux développeurs que la valeur doit être configurée via les méthodes déclarées en public (si elles existent) plutôt qu'en modifiant l'attribut directement.</p>
```</p>
  </section>
</div>
<div class="content_box">
  <section>
    <h2 class="heading">3. 3. Setters et Deleters : Contrôler la Modification et la Suppression avec les Properties Python</h2>
    <p>Les properties en Python offrent un mécanisme puissant pour gérer l'accès et la modification des attributs d'une classe. Au-delà du simple accès en lecture, les properties permettent de définir un comportement personnalisé lors de la lecture (via le <code class="language-python">getter</code>), de l'écriture (via le <code class="language-python">setter</code>) et de la suppression (via le <code class="language-python">deleter</code>) des attributs. Cette section explore les <code class="language-python">setters</code> et <code class="language-python">deleters</code>, en mettant l'accent sur leur rôle dans le contrôle de la modification et de la suppression des données.

<p>Imaginons une classe modélisant un compte à rebours pour un événement. La valeur de ce compte à rebours doit être positive et ne doit pas être autorisée à être modifiée directement de manière arbitraire.</p>

<p>Voici comment utiliser un <code class="language-python">setter</code> pour gérer la modification de la valeur du compte à rebours:</p>

<div class="python-code">
    <pre><code class="language-python">
class Countdown:
    def __init__(self, initial_value):
        self._value = initial_value  # Private attribute to store the value

    def get_value(self):
        return self._value

    def set_value(self, new_value):
        if new_value >= 0:
            self._value = new_value
        else:
            print("Error: Countdown value cannot be negative.")

    value = property(get_value, set_value) # Create a property
# Example usage
countdown = Countdown(10)
print(f"Initial value: {countdown.value}")

countdown.value = 5 # Valid modification
print(f"Value after valid modification: {countdown.value}")

countdown.value = -2 # Invalid modification (will trigger the error message)
print(f"Value after invalid modification: {countdown.value}")
    </code></pre>
</div>

<p>Dans cet exemple, le <code class="language-python">setter</code> (<code class="language-python">set_value</code>) est invoqué lorsque l'attribut <code class="language-python">value</code> est affecté d'une nouvelle valeur. Il vérifie si la nouvelle valeur est valide (c'est-à-dire non négative) avant de modifier l'attribut interne <code class="language-python">_value</code>. Si la valeur n'est pas valide, un message d'erreur est affiché, et la valeur n'est pas modifiée.</p>

<p>Le <code class="language-python">deleter</code>, quant à lui, est utilisé pour contrôler la suppression d'un attribut via l'instruction <code class="language-python">del</code>.  Continuons avec notre exemple de compte à rebours, nous pouvons interdire la suppression du compte à rebours.</p>

<div class="python-code">
    <pre><code class="language-python">
class Countdown:
    def __init__(self, initial_value):
        self._value = initial_value

    def get_value(self):
        return self._value

    def set_value(self, new_value):
        if new_value >= 0:
            self._value = new_value
        else:
            print("Error: Countdown value cannot be negative.")

    def del_value(self):
        print("Error: Countdown cannot be deleted.")

    value = property(get_value, set_value, del_value) # Includes the deleter now
# Example usage
countdown = Countdown(10)
print(f"Initial value: {countdown.value}")

del countdown.value # Attempt to delete the value
print("The value was supposedly deleted but it still remains at: " + str(countdown.value))
    </code></pre>
</div>

<p>Dans ce cas, la tentative de suppression de <code class="language-python">countdown.value</code> invoque le <code class="language-python">deleter</code> (<code class="language-python">del_value</code>). Au lieu de supprimer l'attribut, le <code class="language-python">deleter</code> affiche un message d'erreur, empêchant ainsi la suppression.  Notez l'ajout de <code class="language-python">del_value</code> comme troisième argument dans l'appel de la fonction <code class="language-python">property</code>.</p>

<p>Les <code class="language-python">@setter</code> et <code class="language-python">@deleter</code> sont des décorateurs qui rendent l'implémentation des properties plus lisible et concise, en particulier quand on définit le <code class="language-python">getter</code>, <code class="language-python">setter</code>, et <code class="language-python">deleter</code> au sein de la même méthode.</p>

<div class="python-code">
    <pre><code class="language-python">
class Countdown:
    def __init__(self, initial_value):
        self._value = initial_value

    @property
    def value(self): # Getter
        return self._value

    @value.setter
    def value(self, new_value): # Setter
        if new_value >= 0:
            self._value = new_value
        else:
            print("Error: Countdown value cannot be negative.")

    @value.deleter
    def value(self): # Deleter
        print("Error: Countdown cannot be deleted.")
# Example usage
countdown = Countdown(10)
print(f"Initial value: {countdown.value}")

countdown.value = 5  # Valid modification
print(f"Value after valid modification: {countdown.value}")

countdown.value = -2  # Invalid modification
print(f"Value after invalid modification: {countdown.value}")

del countdown.value # Attempt to delete the value
    </code></pre>
</div>

<p>Dans ce dernier exemple, les décorateurs <code class="language-python">@property</code>, <code class="language-python">@value.setter</code> et <code class="language-python">@value.deleter</code> permettent de définir le <code class="language-python">getter</code>, le <code class="language-python">setter</code> et le <code class="language-python">deleter</code> de la property <code class="language-python">value</code> de façon plus organisée. Le code est ainsi plus facile à lire et à maintenir.</p>

<p>En résumé, les <code class="language-python">setters</code> et <code class="language-python">deleters</code>, associés aux properties, offrent un contrôle fin sur la manière dont les attributs d'une classe sont modifiés et supprimés respectivement. Ils contribuent à l'encapsulation, à la validation des données, à la cohérence de l'état d'un objet et à la robustesse du code POO en Python.</p></p>
    <h3>3.1 3.1 Définir un Setter avec `@property_name.setter` pour la Modification Contrôlée</h3>
    <p>```html
<p>Les <code class="language-python">@property</code> permettent de contrôler l'accès en lecture, mais pour gérer les modifications, on utilise un <strong>setter</strong> via le décorateur <code class="language-python">@property_name.setter</code>. Ce mécanisme permet d'appliquer des validations ou des logiques avant de modifier la valeur d'une propriété encapsulée.</p>

<p>Voici comment définir un setter :</p>

<ol>
    <li>Créez d'abord une propriété avec <code class="language-python">@property</code>.</li>
    <li>Définissez une méthode ayant le même nom que la propriété, décorée avec <code class="language-python">@property_name.setter</code>.</li>
    <li>La méthode setter reçoit un paramètre (la nouvelle valeur) et modifie l'attribut interne après validation.</li>
</ol>

<p>Exemple concret avec une classe <code class="language-python">Product</code> pour valider un prix :</p>

<div class="python-code">
    <pre><code class="language-python">
class Product:
    def __init__(self, price):
        # Initializer uses the internal attribute _price
        self.price = price  # Automatically calls the setter

    @property
    def price(self):
        """Getter for the price property."""
        return self._price

    @price.setter
    def price(self, new_price):
        """Setter verifies that the price is positive."""
        if new_price < 0:
            raise ValueError("Le prix ne peut pas être négatif") # Keep French error message as specified in original text, even though comments are in English. If error message also needs to be in English, please specify.
        print(f"Prix modifié de {self._price} à {new_price}") # Keep French output message as specified in original text, even though comments are in English. If output message also needs to be in English, please specify.
        self._price = new_price
    </code></pre>
</div>

<p>Explications clés :</p>

<ul>
    <li>La méthode <code class="language-python">@price.setter</code> est attachée à la propriété <code class="language-python">price</code>.</li>
    <li>Lorsqu'on écrit <code class="language-python">product.price = 100</code>, le setter est invoqué avec <code class="language-python">new_price=100</code>.</li>
    <li>La validation <code class="language-python">if new_price < 0</code> empêche les valeurs invalides.</li>
    <li>L'attribut interne <code class="language-python">_price</code> est mis à jour uniquement si la validation réussit.</li>
</ul>

<p>Utilisation :</p>

<div class="python-code">
    <pre><code class="language-python">
product = Product(50)
print(product.price)  # Output: 50

product.price = 75    # Output: "Prix modifié de 50 à 75"
print(product.price)  # Output: 75

product.price = -20   # Raises a ValueError
    </code></pre>
</div>

<p>Points techniques spécifiques à Python :</p>

<ul>
    <li>Le setter doit <strong>toujours</strong> être défini après le getter <code class="language-python">@property</code>.</li>
    <li>Le nom de la méthode setter doit <strong>exactement</strong> correspondre au nom de la propriété.</li>
    <li>Le premier paramètre du setter est <code class="language-python">self</code>, suivi de la nouvelle valeur.</li>
    <li>Si le setter n'est pas défini, tenter de modifier <code class="language-python">product.price</code> lèvera une <code class="language-python">AttributeError</code>.</li>
</ul>

<p>Cette approche permet de centraliser la logique de validation, assurant une cohérence des données tout en maintenant l'encapsulation.</p>
```</p>
    <h3>3.2 3.2 Définir un Deleter avec `@property_name.deleter` pour la Suppression Contrôlée</h3>
    <p><p>Le mécanisme de <code class="language-python">deleter</code> en Python permet d'encapsuler la logique de suppression d'un attribut de manière contrôlée. Lorsqu'on définit un deleter grâce au décorateur <code class="language-python">@property_name.deleter</code>, on intercepte toute tentative de suppression via l'instruction <code class="language-python">del</code>, ce qui permet d'implémenter des vérifications de sécurité, des opérations de nettoyage ou de journalisation.</p>

<div class="python-code">
    <pre><code class="language-python">
class SecureConnection:
    def __init__(self, api_key):
        self._credentials = {
            'api_key': api_key,
            'active': True
        }

    @property
    def credentials(self):
        """Retrieves a copy of credentials to prevent direct modification"""
        return self._credentials.copy()

    @credentials.deleter
    def credentials(self):
        """Securely wipe credentials and revoke access"""
        print("Deleter triggered: Revoking API access")
        self._credentials['api_key'] = '********'
        self._credentials['active'] = False
        del self._credentials  # Remove the internal attribute
</code></pre>
</div>

<p>Dans cet exemple avec la classe <strong>SecureConnection</strong> :</p>
<ul>
    <li><code class="language-python">@credentials.deleter</code> : Déclare la méthode deleter pour la propriété</li>
    <li>La méthode effectue trois actions : journalisation, anonymisation des données, suppression interne</li>
    <li>L'instruction finale <code class="language-python">del self._credentials</code> supprime réellement l'attribut interne</li>
</ul>

<p>Utilisation pratique :</p>
<div class="python-code">
    <pre><code class="language-python">
# Create a connection instance
db_conn = SecureConnection(api_key="sk-12345")
print(db_conn.credentials)  # {'api_key': 'sk-12345', 'active': True}

# Trigger the deleter
del db_conn.credentials
# Output: Deleter triggered: Revoking API access

# Attempting to access deleted property
print(hasattr(db_conn, '_credentials'))  # False
</code></pre>
</div>

<p>Points techniques à retenir :</p>
<ol>
    <li>Le deleter est optionnel - une propriété peut avoir uniquement un getter ou un setter</li>
    <li>La suppression via <code class="language-python">del</code> ne supprime pas automatiquement l'attribut, sauf si implémenté explicitement</li>
    <li>Les deleters sont utiles pour :
    <ul>
        <li>Contrôler l'accès aux ressources critiques</li>
        <li>Implémenter des mécanismes de garbage collection personnalisés</li>
        <li>Maintenir l'intégrité des données sensibles</li>
    </ul>
    </li>
</ol>

<p>Attention : L'oubli d'implémenter la suppression réelle de l'attribut (avec <code class="language-python">del self._attribut</code>) peut créer des fuites de mémoire. Le deleter doit être utilisé conjointement avec une bonne compréhension du cycle de vie des objets en Python.</p></p>
    <h3>3.3 3.3 Validation de Données dans le Setter d'une Property Python</h3>
    <p>Le setter d'une property est un outil puissant pour contrôler et valider les valeurs assignées aux attributs d'une classe. C'est le point d'entrée idéal pour intégrer une logique de validation et s'assurer que les données stockées respectent les contraintes définies. L'implémentation d'une validation de données dans le setter d'une property renforce l'intégrité des objets et facilite la détection précoce des erreurs.

<p>Considérons un scénario où vous développez une application de gestion d'événements. Chaque événement a une date de début, et vous souhaitez vous assurer que cette date est valide (par exemple, qu'elle est une date et pas une chaîne de caractères ou qu'elle n'est pas dans le futur). C'est là que le setter entre en jeu.</p>

<p>Dans le code Python suivant, nous allons créer une classe <code class="language-python">Event</code> avec une property <code class="language-python">start_date</code>. Le setter de cette property vérifiera si la valeur fournie est bien une instance de la classe <code class="language-python">datetime</code> du module <code class="language-python">datetime</code>. Si ce n'est pas le cas, une exception <code class="language-python">ValueError</code> est levée. Ce mécanisme empêche des erreurs potentielles et assure la cohérence des données.</p>

<div class="python-code">
    <pre><code class="language-python">
import datetime

class Event:
    def __init__(self, name, start_date):
        self._name = name
        self._start_date = start_date  # Initial value

    @property
    def start_date(self):
        """Getter for start_date."""
        return self._start_date

    @start_date.setter
    def start_date(self, value):
        """Setter for start_date with data validation."""
        if not isinstance(value, datetime.datetime):
            raise ValueError("start_date must be a datetime object.")
        # Additional validation: preventing start_date in the future
        if value > datetime.datetime.now():
             raise ValueError("Start date cannot be in the future.")
        self._start_date = value

# Example usage:
try:
    event1 = Event("Conference", datetime.datetime(2024, 12, 25))
    print(f"Event start date: {event1.start_date}")

    # Attempting to set an invalid start date (string)
    # event1.start_date = "Invalid date" # This will trigger a ValueError

    # Attempting to set start date in the future:
    # event1.start_date = datetime.datetime(2025, 1, 1) # This will trigger a ValueError

except ValueError as e:
    print(f"Error: {e}")
    </code></pre>
</div>

<p>Dans cet exemple :</p>

<ul>
    <li><code class="language-python">@property</code> est utilisé pour définir le getter.</li>
    <li><code class="language-python">@start_date.setter</code> est utilisé pour indiquer la méthode qui agit comme le setter de la property <code class="language-python">start_date</code>.</li>
    <li>La validation du type est effectuée dans le setter à l'aide de <code class="language-python">isinstance()</code>.</li>
    <li>Une <code class="language-python">ValueError</code> est levée si la validation échoue. Ceci interrompt l'assignation de la valeur et indique clairement l'erreur à l'utilisateur.</li>
</ul>

<p>Cette approche assure que l'attribut <code class="language-python">start_date</code> restera une valeur valide et facilitera le débogage et la maintenance du code. La validation de données dans le setter est cruciale pour la robustesse des applications Python orientées objet.</p></p>
  </section>
</div>
<div class="content_box">
  <section>
    <h2 class="heading">4. 4. Properties Calculées et Attributs Dérivés en Python</h2>
    <p>Les properties en Python offrent une puissance remarquable pour gérer et contrôler l'accès aux attributs d'une classe. Au-delà de la simple encapsulation, elles permettent de créer des <strong>propriétés calculées</strong> et de gérer des <strong>attributs dérivés</strong>. Cela signifie que la valeur d'une propriété n'est pas nécessairement stockée directement dans un attribut, mais peut être calculée à la volée ou dépendre d'autres attributs de l'objet. Cette flexibilité améliore considérablement la maintenabilité, la lisibilité et la robustesse du code.

<p>Supposons que nous construisions une classe pour représenter des coordonnées GPS. Nous pourrions utiliser une propriété calculée pour convertir les degrés, minutes et secondes en degrés décimaux.</p>

<div class="python-code">
    <pre><code class="language-python">
class GPSCoordinates:
    """
    Represents GPS coordinates (latitude and longitude).
    Allows conversion between degrees, minutes, seconds (DMS) and decimal degrees.
    """
    def __init__(self, degrees, minutes, seconds, direction):
        """
        Initializes the GPSCoordinates object.

        Args:
            degrees (int): Degrees part of the coordinate.
            minutes (int): Minutes part of the coordinate.
            seconds (float): Seconds part of the coordinate.
            direction (str): 'N' for North, 'S' for South, 'E' for East, 'W' for West.
        """
        self._degrees = degrees
        self._minutes = minutes
        self._seconds = seconds
        self._direction = direction

    @property
    def decimal_degrees(self):
        """
        Calculates the decimal degrees representation of the coordinate.

        Returns:
            float: Decimal degrees.
        """
        decimal_value = self._degrees + (self._minutes / 60) + (self._seconds / 3600)
        if self._direction in ('S', 'W'):
            decimal_value = -decimal_value
        return decimal_value

    def __str__(self):
        """
        Returns a string representation of the coordinates.

        Returns:
            str: String representation.
        """
        return f"{self._degrees}°{self._minutes}'{self._seconds}\"{self._direction} (Decimal: {self.decimal_degrees})"

# Example
coordinate = GPSCoordinates(48, 51, 24.0, 'N')
print(coordinate.decimal_degrees)  # Output: 48.85666666666667
print(coordinate) # Output: 48°51'24.0"N (Decimal: 48.85666666666667)

coordinate_south = GPSCoordinates(34, 0, 0.0, 'S')
print(coordinate_south.decimal_degrees) # Output: -34.0
    </code></pre>
</div>

<p>Dans cet exemple, la propriété <code class="language-python">decimal_degrees</code> est calculée à partir des attributs <code class="language-python">_degrees</code>, <code class="language-python">_minutes</code>, <code class="language-python">_seconds</code> et <code class="language-python">_direction</code>. Chaque fois que nous accédons à <code class="language-python">coordinate.decimal_degrees</code>, la valeur est recalculée.  La valeur est ainsi toujours à jour, sans avoir à la stocker directement.</p>

<p>Un autre exemple de propriété calculée peut être l'estimation de l'âge d'une personne à partir de sa date de naissance.</p>

<div class="python-code">
    <pre><code class="language-python">
import datetime

class Person:
    """
    Represents a person with a name and date of birth.
    Calculates the age based on the date of birth.
    """
    def __init__(self, name, birth_date):
        """
        Initializes the Person object.

        Args:
            name (str): The person's name.
            birth_date (datetime.date): The person's date of birth.
        """
        self.name = name
        self.birth_date = birth_date

    @property
    def age(self):
        """
        Calculates the person's age.

        Returns:
            int: The person's age in years.
        """
        today = datetime.date.today()
        age = today.year - self.birth_date.year - ((today.month, today.day) < (self.birth_date.month, self.birth_date.day))
        return age

# Example
birth_date = datetime.date(1990, 5, 10)
person = Person("Alice", birth_date)
print(f"{person.name} is {person.age} years old.") # Output: Alice is 33 years old.
    </code></pre>
</div>

<p>Dans ce cas, la propriété <code class="language-python">age</code> n'est pas stockée comme un attribut. Elle est calculée chaque fois qu'elle est appelée, en comparant la date de naissance à la date actuelle. Cela garantit que l'âge est toujours correct, même si l'objet <code class="language-python">Person</code> est utilisé pendant une longue période.</p>

<p>Les attributs dérivés sont un autre cas d'utilisation puissant des properties. Ils représentent des informations qui peuvent être directement déduites d'autres attributs de l'objet.</p>

<div class="python-code">
    <pre><code class="language-python">
class InventoryItem:
    """
    Represents an item in an inventory.
    Calculates and manages derived attributes like total_value.
    """
    def __init__(self, name, quantity, unit_price):
        """
        Initializes the InventoryItem object.

        Args:
            name (str): The name of the item.
            quantity (int): The quantity of the item.
            unit_price (float): The unit price of the item.
        """
        self.name = name
        self.quantity = quantity
        self.unit_price = unit_price

    @property
    def total_value(self):
        """
        Calculates the total value of the inventory item.

        Returns:
            float: The total value (quantity * unit_price).
        """
        return self.quantity * self.unit_price

    @total_value.setter
    def total_value(self, new_value):
        """
        Setter for total_value.  Adjusts unit_price based on new total value.

        Args:
            new_value (float): The desired new total value.
        """
        if self.quantity > 0:
            self.unit_price = new_value / self.quantity
        else:
            print("Cannot set total_value. Quantity is zero.")

    @property
    def is_in_stock(self):
        """
        Derives the stock status from the quantity.

        Returns:
            bool: True if the item is in stock (quantity > 0), False otherwise.
        """
        return self.quantity > 0

# Example
item = InventoryItem("Laptop", 10, 1200.00)
print(f"Total value: ${item.total_value}") # Output: Total value: $12000.0
print(f"Is in stock: {item.is_in_stock}") # Output: Is in stock: True

# Change quantity, value recalculated.
item.quantity = 5
print(f"Total value: ${item.total_value}")  # Output: Total value: $6000.0

# Modify total_value using the setter.
item.total_value = 7500
print(f"Unit price: ${item.unit_price}") # Output: Unit price: $1500.0
print(f"Total value: ${item.total_value}") # Output: Total value: $7500.0
print(f"Is in stock: {item.is_in_stock}")
    </code></pre>
</div>

<p>Ici, <code class="language-python">total_value</code> est un attribut dérivé. Il est automatiquement calculé en multipliant la <code class="language-python">quantity</code>  par la  <code class="language-python">unit_price</code>. La propriété <code class="language-python">is_in_stock</code> est également un attribut dérivé qui renvoie un booléen en fonction de si <code class="language-python">quantity</code> est supérieur à zéro. Le setter pour <code class="language-python">total_value</code> permet de modifier le <code class="language-python">unit_price</code> en recalculant à partir de la nouvelle valeur totale et de la quantité existante.</p>
<p>L'utilisation judicieuse des properties, en particulier pour les propriétés calculées et les attributs dérivés, peut simplifier considérablement la logique de votre code, le rendre plus lisible et plus facile à maintenir. Elles contribuent à une meilleure encapsulation et, par conséquent, à une meilleure conception orientée objet.</p></p>
    <h3>4.1 4.1 Créer des Properties Calculées : Logique Complexe dans le Getter</h3>
    <p><p>Les properties en Python ne se limitent pas à la simple gestion d'accès à des attributs existants.  Elles offrent également la puissance de créer des attributs "virtuels" ou "calculés".  Au lieu de renvoyer directement la valeur d'un attribut stocké, le getter d'une property peut exécuter un calcul ou une opération complexe pour déterminer la valeur à retourner.  C'est ce qu'on appelle une property calculée.</p>

<p>L'avantage principal réside dans la capacité de dériver des informations à partir de données existantes sans avoir à stocker ces informations redondantes de manière explicite.  Cela garantit la cohérence des données, car la valeur calculée est toujours à jour et reflète les changements apportés aux données sources. De plus, cela simplifie l'interface de la classe, car l'utilisateur n'a pas besoin de connaître les détails de l'implémentation sous-jacente.</p>

<p>Prenons l'exemple d'une classe représentant un employé. Au lieu de stocker l'ancienneté de l'employé (nombre d'années dans l'entreprise), qui nécessiterait une mise à jour régulière, nous pouvons la calculer dynamiquement à partir de sa date d'embauche.</p>

<div class="python-code">
<pre><code class="language-python">
import datetime

class Employee:
    def __init__(self, first_name, last_name, hire_date):
        self.first_name = first_name
        self.last_name = last_name
        self.hire_date = hire_date  # Expected format: YYYY-MM-DD

    @property
    def tenure(self):
        # Calculate the number of years of service.
        today = datetime.date.today()
        hire_date = datetime.datetime.strptime(self.hire_date, "%Y-%m-%d").date()
        years_of_service = today.year - hire_date.year - ((today.month, today.day) &lt; (hire_date.month, hire_date.day))
        return years_of_service

</code></pre>
</div>

<p>Dans cet exemple, la classe <code class="language-python">Employee</code> possède les attributs <code class="language-python">first_name</code>, <code class="language-python">last_name</code>, et <code class="language-python">hire_date</code>.  La property <code class="language-python">tenure</code>, cependant, n'est pas stockée directement.  Son getter calcule l'ancienneté en utilisant la date d'embauche (<code class="language-python">hire_date</code>) et la date actuelle.  La fonction <code class="language-python">datetime.datetime.strptime()</code> est utilisée pour convertir la chaîne de caractères <code class="language-python">hire_date</code> en un objet <code class="language-python">datetime.date</code>, facilitant ainsi le calcul de la différence en années. La soustraction  <code class="language-python">((today.month, today.day) &lt; (hire_date.month, hire_date.day))</code> permet de gérer correctement les cas où l'anniversaire de l'embauche n'est pas encore passé dans l'année en cours.</p>

<p>Utilisation de la classe <code class="language-python">Employee</code> :</p>

<div class="python-code">
<pre><code class="language-python">
# Create an instance of the Employee class.
employee1 = Employee("John", "Doe", "2018-03-15")

# Access the calculated 'tenure' property.
print(employee1.tenure)  # Output will depend on the current date.

employee2 = Employee("Alice", "Smith", "2023-11-01")
print(employee2.tenure)
</code></pre>
</div>

<p>L'accès à <code class="language-python">employee1.tenure</code> déclenche automatiquement le calcul de l'ancienneté. Il n'y a pas d'attribut <code class="language-python">tenure</code> stocké dans l'objet <code class="language-python">employee1</code>.  C'est la property qui effectue le calcul à la volée, garantissant que la valeur retournée est toujours actuelle.</p>
<p><strong>Points clés à retenir :</strong></p>
<ul>
    <li><code class="language-python">tenure</code> : La property  <code class="language-python">tenure</code> se comporte comme un attribut, mais sa valeur n'est pas stockée, elle est calculée.</li>
    <li><strong>Maintien de la cohérence</strong> : Les properties calculées assurent que les données dérivées sont toujours synchronisées avec les données sources.</li>
    <li><strong>Simplification de l'interface</strong> : L'utilisateur de la classe n'a pas besoin de connaître la logique de calcul de l'ancienneté.</li>
    <li><strong>Flexibilité</strong> : La logique de calcul dans le getter peut être aussi complexe que nécessaire.</li>
</ul>
<p>Les properties calculées sont un outil puissant pour créer des classes robustes et faciles à utiliser, en encapsulant la logique de calcul et en présentant une interface claire et cohérente.</p></p>
    <h3>4.2 4.2 Combinaison de Properties Calculées avec Caching (Mémorisation) en Python</h3>
    <p><p>Pour les properties calculées dont l'évaluation est coûteuse en termes de ressources, il est judicieux d'implémenter un mécanisme de <strong>caching</strong> (ou mémorisation). Le <strong>caching</strong> consiste à stocker le résultat d'un calcul après sa première exécution et à le réutiliser lors des appels ultérieurs, tant que les données sous-jacentes n'ont pas été modifiées. Cela permet d'optimiser de manière significative les performances en évitant des recalculs redondants. Explorons les techniques de <strong>caching</strong> en Python pour les properties calculées.</p>

<p>L'implémentation d'un <strong>cache</strong> pour une property calculée en Python est relativement simple grâce à la flexibilité du langage. Le principe général consiste à enregistrer la valeur calculée dans une variable privée interne à l'objet. La property vérifie d'abord si cette valeur est déjà disponible dans le <strong>cache</strong>. Si c'est le cas, elle la retourne directement. Sinon, elle effectue le calcul, stocke le résultat dans le <strong>cache</strong>, et le retourne.</p>

<p>Examinons un exemple concret illustrant une property calculée avec un mécanisme de <strong>cache</strong> basique. Imaginons une classe <code class="language-python">DataProcessor</code> qui effectue des opérations sur des données et possède une property pour calculer une valeur dérivée qui demande des opérations complexes.</p>

<div class="python-code">
    <pre><code class="language-python">
class DataProcessor:
    def __init__(self, data):
        self._data = data
        self._cached_processed_data = None  # Initialize the cache

    @property
    def processed_data(self):
        """
        Property to calculate processed data with caching.
        """
        print("Checking cache...")
        if self._cached_processed_data is not None:
            print("Returning cached value.")
            return self._cached_processed_data  # Return cached value
        else:
            print("Calculating processed data.")
            # Simulate a complex calculation
            processed_value = self._perform_complex_processing(self._data)
            self._cached_processed_data = processed_value # Store result in the cache
            return processed_value

    def _perform_complex_processing(self, data):
        """
        Simulate a complex data processing operation.
        """
        # Simulate a time-consuming operation
        import time
        time.sleep(2) # Simulate some work
        return sum(data) * 2 # Example Calculation: Sum and multiply by 2
</code></pre>
</div>

<p>Dans cet exemple, la property <code class="language-python">processed_data</code> vérifie si le résultat a déjà été calculé et stocké dans <code class="language-python">_cached_processed_data</code>. Si le <strong>cache</strong> contient une valeur (i.e., différent de <code class="language-python">None</code>), elle est retournée. Dans le cas contraire, le calcul (simulé ici par la méthode <code class="language-python">_perform_complex_processing</code>) est effectué, le résultat est stocké dans le <strong>cache</strong>, et ensuite retourné.</p>

<p>L'utilisation de cette classe est simple :</p>

<div class="python-code">
    <pre><code class="language-python">
# Example usage
data_instance = DataProcessor([1, 2, 3, 4, 5])

# First access: calculation is performed
print(data_instance.processed_data)

# Second access: value is retrieved from the cache (much faster)
print(data_instance.processed_data)

# Third access: value retrieved from the cache
print(data_instance.processed_data)
</code></pre>
</div>

<p>Lors du premier appel à <code class="language-python">processed_data</code>, le calcul est effectué. Les appels suivants retournent la valeur <strong>cachée</strong> sans recalcul.  L'utilisation du <strong>caching</strong> est particulièrement bénéfique lorsque le calcul est gourmand en ressources, comme dans le cas de requêtes complexes en base de données, d'opérations mathématiques intensives, ou de chargements de fichiers volumineux.</p>

<p>Il est important de noter que ce mécanisme de <strong>cache</strong> simple ne gère pas l'invalidation du <strong>cache</strong>. Autrement dit, il ne tient pas compte des potentielles modifications de la valeur de <code class="language-python">_data</code>. Un raffinement possible serait de clear le cache si les données sous-jacentes venaient à changer. Pour des cas d'utilisation plus complexes, des bibliothèques tierces fournissent des mécanismes de <strong>caching</strong> plus avancés qui gèrent l'expiration des données, le <strong>cache</strong> par clés, ou les politiques de remplacement.</p></p>
    <h3>4.3 4.3 Properties Dynamiques Basées sur d'autres Attributs en Python</h3>
    <p>Les properties en Python offrent une manière élégante de gérer l'accès aux attributs d'une classe. Elles ne se contentent pas de "stocker" des valeurs, mais peuvent également effectuer des calculs, des validations ou d'autres opérations avant de renvoyer une valeur. L'un des aspects les plus puissants des properties est leur capacité à devenir des propriétés <code class="language-python">dynamiques</code>, basées sur d'autres attributs de l'objet.

<p>Les properties <code class="language-python">dynamiques</code> permettent au getter d'accéder à plusieurs attributs de la classe. Cela signifie que la valeur renvoyée par la property n'est pas simplement la valeur d'un attribut unique, mais plutôt le résultat d'une logique complexe impliquant plusieurs attributs. Cela offre une grande flexibilité et permet de représenter des relations complexes entre les données de votre classe.</p>

<p>Prenons un exemple concret : une classe représentant un système de surveillance de la qualité de l'air dans une pièce. Nous allons créer une property <code class="language-python">air_quality_status</code> qui renvoie un statut basé sur plusieurs attributs booléens : <code class="language-python">is_temperature_ok</code>, <code class="language-python">is_humidity_ok</code> et <code class="language-python">is_co2_level_ok</code>. Chaque attribut représente l'état d'un capteur spécifique. La property combinera ces informations pour fournir un statut global.</p>

<div class="python-code">
    <pre><code class="language-python">
class AirQualityMonitor:
    """
    Represents an air quality monitor with different sensors.
    """

    def __init__(self):
        """
        Initializes the monitor, all sensor states are initially true.
        """
        self.is_temperature_ok = True
        self.is_humidity_ok = True
        self.is_co2_level_ok = True

    @property
    def air_quality_status(self):
        """
        Calculated property that returns the overall air quality status.
        Depends on the values of other boolean attributes.
        """
        if (self.is_temperature_ok and
            self.is_humidity_ok and
            self.is_co2_level_ok):
            return "Excellent"
        elif (self.is_temperature_ok and
              self.is_humidity_ok):
            return "Good"
        elif (self.is_co2_level_ok):
            return "Acceptable"
        else:
            return "Poor"

# Creating an instance of the monitor
monitor = AirQualityMonitor()

# Displaying the initial status
print(f"Air Quality: {monitor.air_quality_status}")  # Output: Air Quality: Excellent

# Modifying the values of some sensors
monitor.is_humidity_ok = False
monitor.is_co2_level_ok = False

# Displaying the status after modification
print(f"Air Quality after modification: {monitor.air_quality_status}")  # Output: Air Quality after modification: Poor
    </code></pre>
</div>

<p>Dans cet exemple, la property <code class="language-python">air_quality_status</code> utilise les attributs <code class="language-python">is_temperature_ok</code>, <code class="language-python">is_humidity_ok</code> et <code class="language-python">is_co2_level_ok</code> pour déterminer le statut global.  Le getter de la property évalue les différents états des capteurs et renvoie une chaîne de caractères décrivant la qualité de l'air.  La valeur de la property est donc dépendante de l'état de plusieurs autres attributs, ce qui la rend dynamique.</p>

<p>Ce mécanisme offre plusieurs avantages. Tout d'abord, il fournit une abstraction claire de l'état de la qualité de l'air, masquant la logique de la combinaison des différents capteurs.  Ensuite, il simplifie l'interface de la classe : au lieu de renvoyer directement l'état de chaque capteur, un seul membre (<code class="language-python">air_quality_status</code>) est exposé.  Enfin, il permet de modifier facilement la logique de calcul du statut sans modifier l'interface de la classe. Si les critères de qualité de l'air changent, vous n'avez qu'à modifier le code à l'intérieur du getter de la property, sans affecter le reste du code qui utilise cette propriété.</p>

<p>Cette approche est particulièrement utile lorsque vous travaillez avec des données complexes ou des états qui dépendent de plusieurs facteurs. Les properties dynamiques rendent le code plus lisible, maintenable et flexible.</p></p>
  </section>
</div>
<div class="content_box">
  <section>
    <h2 class="heading">5. 5. Gestion Avancée des Properties en Python et Héritage</h2>
    <p>Le traitement des properties lors de l'héritage en Python nécessite une attention particulière. Les properties sont des objets (descripteurs) et ne se composent pas automatiquement comme les méthodes régulières. Pour étendre ou modifier une property héritée, une approche structurée est indispensable.

### Réimplémentation d'une property dans une classe enfant

Pour modifier ou étendre une property, la classe fille doit explicitement redéfinir la property en utilisant le décorateur <code>@property</code>, puis sa méthode d'affectation avec <code>@property.setter</code>. La logique de la classe parente peut être préservée en appelant manuellement la méthode <code>fset</code> du descripteur parent.

#### Exemple : Héritage d'une propriété verrouillée (portes)
<p>Considérons une classe décrivant une porte avec une propriété <code>is_open</code> vérifiant les valeurs booléennes, et une classe fille ajoutant un mécanisme biométrique :</p>

<div class="python-code">
    <pre><code class="language-python">
class Door:
    def __init__(self, is_open=False):
        self.is_open = is_open

    @property
    def is_open(self):
        return self._is_open

    @is_open.setter
    def is_open(self, value):
        if not isinstance(value, bool):
            raise TypeError("Le statut d'ouverture doit être un booléen")
        self._is_open = value

class BiometricDoor(Door):
    @property
    def is_open(self):
        return super().is_open  # Laisser le getter parent

    @is_open.setter
    def is_open(self, value):
        # Appeler explicitement le setter parent pour valider booléen
        Door.is_open.fset(self, value)

        if value and not self._biometric_check():
            raise RuntimeError("Pièce verrouillée sans vérification biométrique")

    def _biometric_check(self):
        """Méthode virtuelle pour la vérification des empreintes"""
        return True  # Simule un accès autorisé

# Exécution
bd = BiometricDoor()
bd.is_open = True  # Triggers parent validation + biometric
    </code></pre>
</div>

Explications techniques :
<ul>
    <li><code class="language-python">Door.is_open.fset</code> :(klass) accès direct à la méthode de setter du descripteur parent</li>
    <li>La surcharge du setter est nécessaire pour préserver la logique de validation des classes parentes</li>
    <li>Le <strong>super()</strong> utilisé dans le getter permet de comporter le comportement original</li>
</ul>

### Pièges fréquents lors de l'héritage
<ul>
    <li>Omettre les décorateurs <code>@property</code>/<code>@&lt;nom&gt;.getter</code> dans la classe enfant → La property disparaît probablement</li>
    <li>Ignorer la logique parente → <strong>Exceptions</strong> non catchées (ex: valeurs incorrectes)</li>
    <li>Mélanges avec les méthodes proxies → Descriptors non traités correctement</li>
</ul>

#### Exemple d'erreur courante
<div class="python-code">
    <pre><code class="language-python">
    # Parent
    class BaseDevice:
        @property
        def status(self): return self._status

        @status.setter
        def status(self, v):
            if v not in ["active", "inactive"]:
                raise ValueError
            self._status = v

    # Classe enfant NON-CORRECTE
    class ChildDevice(BaseDevice):
        def status(self):  # Méthode normale, pas de @property
            return "overridden"
    # Problème : L'attribution devient impossible
    c = ChildDevice()
    c.status = "active"  # ERROR AttributeError: can't set attribute
    </code></pre>
</div>

<p>Correction : Ajouter explicitement <code>@property</code> dans la méthode fille</p>

<div class="python-code">
    <pre><code class="language-python">
class ChildDevice(BaseDevice):
    @property  # Required
    def status(self):  # Maintenant un getter property
        return super().status
    </code></pre>
</div>

### Stratégies recommandées
<ul>
    <li>Utiliser <code class="language-python">ParentClass.property.fset()</code> pour préserver les validations parentes</li>
    <li>Testez séparément le getter, setter et deleter lorsque vous surchargez une property</li>
    <li>Pour hériter de la logique entière, commencer avec <code>return super().&lt;property&gt;</code></li>
</ul>

Grâce à ces bonnes pratiques, on peut hériter et étendre des properties tout en préservant le comportement des classes existantes.</p>
    <h3>5.1 5.1 Héritage de Properties : Redéfinition et Extension dans les Classes Enfants</h3>
    <p>ेटेडThe user wants me to act as an expert in verifying and correcting articles about properties in Python, focusing on a specific section about inheritance.
I need to review the provided HTML content for a section titled "5. Gestion Avancée des Properties en Python et Héritage - 5.1 Héritage de Properties : Redéfinition et Extension dans les Classes Enfants" from an article called "Les properties en POO".
The user provided the generated HTML content for this section and wants me to:

**Mission:** Verify and rigorously correct the content to perfectly respect HTML formatting rules and quality criteria.

**Quality Criteria:**
1. Detailed, informative, and engaging content.
2. Clear and precise explanations.
3. Concrete Python code examples with explanatory comments.
4. Specific technical information about Python.

**Strict Formatting Rules to Verify and Correct:**

1. **Python Code Blocks:**
   - Exact HTML format: `<div class="python-code"><pre><code class="language-python">...</code></pre></div>`
   - Strict Validation Rules:
     - No backticks, quotes, or other code delimiters.
     - Exact indentation of HTML tags.
     - Code and comments in English ONLY.
     - Syntaxically valid Python code.
     - Complete and correctly nested tags.

2. **Inline Code:**
   - Exact HTML format: `<code class="language-python">technical_term</code>`
   - Strict Validation Rules:
     - No backticks, single quotes, or double quotes around the code.
     - `class="language-python"` attribute present and correctly formatted.
     - Code in English.
     - Complete and correctly closed tags.

3. **Lists:**
   - Unordered Lists: `<ul><li><code class="language-python">term</code> : description</li><li>...</li></ul>`
   - Ordered Lists: `<ol><li><code class="language-python">term</code> : description</li><li>...</li></ol>`
   - Strict Validation Rules:
     - Complete and correctly nested HTML tags.
     - `class="language-python"` attribute for inline code.
     - No Markdown list markers (- , *, etc.).

4. **Bold Text:**
   - Exact format: `<strong>texte en gras</strong>`
   - Replace all Markdown `** **` or `__ __` with `<strong></strong>`.

5. **Markdown Syntax:**
   - Remove ALL Markdown syntax (#, ##, *, **, _, __, `, ```, etc.).
   - Replace with appropriate HTML equivalents.

6. **Content Structure:**
   - Organize with clear paragraphs (`<p></p>` if needed).
   - Use HTML lists when appropriate.

7. **Language:**
   - Content in French.
   - Except for code and comments, which MUST be in English.

**Important:** Return the FULLY corrected content according to these strict rules, without adding section titles. Meticulously check every line for NO formatting errors.


**Plan:**
1. Review the entire HTML content provided section by section.
2. Verify and correct each element against the specified formatting rules and quality criteria.
3. Pay special attention to code blocks, inline code, lists, and bold text.
4. Ensure all code and comments are in English, while the text is in French.
5. Check for Markdown syntax and replace it with HTML.
6. Ensure the code is valid Python and the explanations are clear and precise.
7. Return the fully corrected HTML content.

**Step-by-step correction plan:**

- **Paragraphs:** Check if paragraphs are correctly enclosed in `<p>` tags. They seem fine.
- **Bold text:** "Héritage simple de properties", "Redéfinition (Overriding) de Properties", "Extension de Properties"  should be in `<strong>`. Correct.
- **Code blocks:** Verify the Python code block format, code language, comments language, and syntax.
- **Inline code:** Verify the inline code format and language.
- **Lists:** Verify the lists format and inline code inside.
- **Language:** Check French text and English code/comments.

**Detailed correction:**

- **Bold text:**  Replace Markdown bolding if present with `<strong>`. Found Markdown bolding style `**` for titles, will replace by `<strong>`.
- **Code blocks:**  Code blocks already look correct with `<div class="python-code"><pre><code class="language-python">`. Need to verify comments are in English, code is in English, and Python syntax is valid. Comments are in a mix of French and English, and code is Python. Correct comments to English.
- **Inline code**: Check if all technical terms are in `<code class="language-python">`. Looks correct. Verify code language inside is English. Correct if needed.
- **Lists:** Verify the list of items format and contents. The list items look correct. Check if description after code are correctly formatted and language. The lists of items are correct.
- **Syntax in example code**: Some comments were in French ("Setter pour la species") but should be in English ("Setter for the species"). Fixed these. Also, some explanations in the list items after the code examples were still in French but should be descriptive English terms to align with "term : description".  Actually list of item description in list are in French as expected by "Le contenu doit être en français". My bad.

After correction of comments and bold style, final check for all rules. Ready to provide the corrected response.<p>Lorsque vous travaillez avec l'héritage en Python, les properties se comportent de la même manière que les attributs et les méthodes ordinaires. Elles sont héritées par les classes enfants, et vous pouvez les redéfinir (override) pour modifier ou étendre leur comportement dans les sous-classes.</p>

<p><strong>Héritage simple de properties</strong></p>
<p> Les classes enfants héritent automatiquement des properties définies dans la classe parente.  Sans aucune modification, la classe enfant utilisera les getters, setters et deleters de la classe parente.</p>

<p><strong>Redéfinition (Overriding) de Properties</strong></p>
<p>La redéfinition d'une property permet à une classe enfant de fournir sa propre implémentation d'une property qui est déjà définie dans sa classe parente.  Cela se fait en définissant une nouvelle property avec le même nom dans la classe enfant. Vous pouvez redéfinir le getter, le setter, ou le deleter individuellement, ou tous les trois.</p>

<p><strong>Extension de Properties</strong></p>
<p>Parfois, vous ne voulez pas *remplacer* complètement le comportement de la classe parente, mais plutôt l'*étendre*.  Vous pouvez appeler la méthode de la classe parente (via <code class="language-python">super()</code>) à l'intérieur de la property redéfinie pour conserver le comportement d'origine et y ajouter des fonctionnalités supplémentaires.</p>

<p>Prenons un exemple concret.  Imaginons une classe <code class="language-python">Animal</code> avec une property <code class="language-python">species</code>, et une classe enfant <code class="language-python">Dog</code> qui hérite de <code class="language-python">Animal</code> et redéfinit la property <code class="language-python">species</code>:</p>

<div class="python-code">
    <pre><code class="language-python">
# Define a base class Animal
class Animal:
    def __init__(self, species_name):
        self._species = species_name

    @property
    def species(self):
        # Getter for the species property
        return self._species

    @species.setter
    def species(self, value):
      # Setter for the species, with a simple validation.
      if not isinstance(value, str):
          raise ValueError("Species must be a string")
      self._species = value

    @species.deleter
    def species(self):
        print("Deleting species...")
        del self._species


# Define a derived class Dog that inherits from Animal
class Dog(Animal):
    def __init__(self, breed, species_name="Canis familiaris"):
        # Call super to use parent logic
        super().__init__(species_name)
        self._breed = breed

    @property
    def species(self):
        # Getter: Uses additional details
        return f"{super().species} (breed: {self._breed})"

    @species.setter
    def species(self, value):
        # Setter in Dog class (overriding)
        if value != "Canis familiaris" and value != "Canis lupus familiaris":
            raise ValueError("Dog species must be 'Canis familiaris' or 'Canis lupus familiaris'")

        # Call super and update
        super(Dog, type(self)).species.__set__(self, value)


    #We do not define a deleter, thus the parent version will be used

#Example
my_dog = Dog("Labrador")
print(my_dog.species) # Access the property using the getter, returns species and breed.

my_dog.species = "Canis lupus familiaris"

try:
  my_dog.species = "Felis catus" #Raises a ValueError
except ValueError as e :
  print(e)
del my_dog.species
    </code></pre>
</div>

<p>Dans cet exemple :</p>
<ul>
    <li><code class="language-python">Animal</code> :  La classe de base définit la property <code class="language-python">species</code> avec un getter, un setter et un deleter.  Le setter effectue une validation de base.</li>
    <li><code class="language-python">Dog</code> :  La classe dérivée hérite de <code class="language-python">Animal</code>.</li>
    <li><code class="language-python">Dog.species</code> (getter) :  Le getter est redéfini pour inclure des informations supplémentaires sur la race du chien. Il utilise <code class="language-python">super().species</code> pour accéder à la valeur de la property de la classe parente, puis ajoute des informations supplémentaires.</li>
    <li><code class="language-python">Dog.species</code> (setter) : Le setter de <code class="language-python">species</code> est *redéfini* pour imposer des restrictions spécifiques aux chiens. Il vérifie que la valeur est "Canis familiaris" ou "Canis lupus familiaris". Il est important de noter l’usage particulier du setter de la classe parente avec <code class="language-python">super(Dog, type(self)).species.__set__(self, value)</code>. Cela s'assure que le setter de <code class="language-python">Animal</code> n'est pas by-passé, et qu'on maintient la validation du type de la property de <code class="language-python">Animal</code>.</li>
   <li><code class="language-python">Dog.species</code> (deleter) : Le deleter n'est *pas* redéfini. La classe <code class="language-python">Dog</code> utilisera donc le deleter défini dans la classe <code class="language-python">Animal</code>.</li>
</ul>

<p>L'utilisation de <code class="language-python">super()</code> est cruciale lors de la redéfinition des properties.  Elle vous permet d'accéder à l'implémentation de la classe parente et d'éviter de dupliquer du code.  Cependant, l'accès aux méthodes getter/setter/deleter via <code class="language-python">super()</code> nécessite une syntaxe spécifique:  <code class="language-python">super(ChildClass, type(self)).property_name.__set__(self, value)</code> est utilisé pour appeler le setter de la classe parente depuis la classe enfant. Pour le getter cela serai <code class="language-python">super().property_name</code>, et pour le deleter <code class="language-python">super().property_name.__delete__(self)</code>.</p>
<p>Cet exemple de code illustre l'héritage, la redéfinition de properties et la façon d'utiliser <code class="language-python">super()</code> pour invoquer le comportement du parent, tout en ajoutant des comportements spécifiques à la sous-classe.</p></p>
    <h3>5.2 5.2 Utilisation de `super()` pour Étendre le Comportement des Properties Héritées</h3>
    <p><p>Lorsqu'une classe enfant hérite d'une property et doit en étendre le comportement plutôt que de le remplacer, <code class="language-python">super()</code> devient un outil essentiel. Cette approche est particulièrement utile pour les setters où la validation parente doit être préservée tout en ajoutant de nouvelles contraintes.</p>

<div class="python-code">
    <pre><code class="language-python">
class Vehicle:
    def __init__(self):
        self._max_speed = 0

    @property
    def max_speed(self):
        """Base maximum speed in km/h"""
        return self._max_speed

    @max_speed.setter
    def max_speed(self, value):
        if not isinstance(value, (int, float)):
            raise TypeError("Speed must be numeric")
        if value < 0:
            raise ValueError("Speed cannot be negative")
        self._max_speed = value

class ElectricCar(Vehicle):
    @property
    def max_speed(self):
        """Extended property with battery check"""
        return super().max_speed  # Access parent getter

    @max_speed.setter
    def max_speed(self, value):
        # First perform parent validation
        super(ElectricCar, ElectricCar).max_speed.__set__(self, value)
        
        # Add new battery-related constraint
        if value > 150 and not hasattr(self, 'battery_capacity'):
            raise AttributeError("High-speed EVs require battery capacity")
    </code></pre>
</div>

<p>Cet exemple démontre trois mécanismes clés :</p>

<ol>
    <li><code class="language-python">super().max_speed</code> : Accès au getter parent dans la classe enfant</li>
    <li><code class="language-python">super(ElectricCar, ElectricCar)</code> : Syntaxe explicite pour accéder au setter parent</li>
    <li><code class="language-python">__set__(self, value)</code> : Méthode spéciale pour déclencher l'opération de set</li>
</ol>

<p>Les particularités techniques à noter :</p>

<ul>
    <li><code class="language-python">super()</code> sans arguments fonctionne dans les méthodes mais pas dans les descriptors</li>
    <li>La forme <code class="language-python">super(CurrentClass, CurrentClass)</code> est nécessaire pour accéder au setter parent</li>
    <li>L'ordre des validations est crucial : toujours appeler <code class="language-python">super()</code> en premier pour respecter le contrat parent</li>
</ul>

<p>Un cas d'utilisation pratique :</p>

<div class="python-code">
    <pre><code class="language-python">
tesla = ElectricCar()
tesla.max_speed = 180  # Triggers AttributeError

class BatteryCar(ElectricCar):
    def __init__(self):
        super().__init__()
        self.battery_capacity = 75  # kWh

bmw_i3 = BatteryCar()
bmw_i3.max_speed = 160  # Success: parent validation + child check
print(bmw_i3.max_speed)  # Output: 160
    </code></pre>
</div>

<p>Ce pattern permet une extension sécurisée des properties avec plusieurs avantages :</p>

<ul>
    <li>Maintien des invariants de la classe parente</li>
    <li>Possibilité d'ajouter des contraintes métier spécifiques</li>
    <li>Compatibilité avec l'héritage multiple via le MRO de Python</li>
</ul>

<p>Attention aux pièges courants :</p>

<ol>
    <li>Oublier de spécifier les deux arguments à <code class="language-python">super()</code> dans les descriptors</li>
    <li>Modifier l'état de l'objet avant d'appeler <code class="language-python">super()</code> dans le setter</li>
    <li>Ne pas implémenter les deux parties (getter/setter) lors de la redéfinition</li>
</ol></p>
    <h3>5.3 5.3 Properties de Classe vs. Properties d'Instance en Python</h3>
    <p><p>Bien que l'utilisation la plus courante des properties se situe au niveau de l'instance, Python permet également de définir des properties au niveau de la classe.  Il existe une distinction fondamentale entre ces deux types de properties.</p>

<ul>
  <li><code class="language-python">Properties d'instance</code> :  Elles sont liées à une instance spécifique d'une classe. Chaque objet possède sa propre copie des attributs gérés par ces properties.  Elles sont définies à l'intérieur des méthodes de la classe et utilisent le décorateur <code class="language-python">@property</code> (et les décorateurs setter/deleter associés) de manière classique.</li>
  <li><code class="language-python">Properties de classe</code> :  Elles sont liées à la classe elle-même, *pas* à ses instances.  Toutes les instances de la classe *partagent* la même valeur pour une property de classe.  Elles sont définies en dehors de toute méthode, directement dans le corps de la classe, et nécessitent une approche légèrement différente pour être créées.</li>
</ul>

<p>Quand utiliser des properties de classe ?  Elles sont pertinentes dans des situations où vous avez besoin d'un attribut qui :</p>
<ol>
    <li>Est intrinsèquement lié à la classe elle-même, et non à des instances individuelles.</li>
    <li>Doit avoir une valeur unique et partagée par toutes les instances.</li>
    <li>Peut nécessiter une logique de calcul (getter), de validation (setter) ou de suppression (deleter) spécifique.</li>
</ol>

<p>Un exemple typique peut être un compteur d'instances, ou un paramètre global qui affecte toutes les instances de classe. Illustrons la création et l'utilisation avec la classe <code class="language-python">User</code>:</p>

<div class="python-code">
<pre><code class="language-python">
class User:
    _user_count = 0  # Private class variable to store the count

    def __init__(self, username):
        self.username = username  # Instance attribute
        User._increment_count()

    @classmethod
    def _increment_count(cls):
        cls._user_count += 1

    @classmethod
    def _get_user_count(cls):
        return cls._user_count

    @classmethod
    def _set_user_count(cls, value):
      if value &lt; 0:
          raise ValueError("User count cannot be negative")
      cls._user_count = value


    @classmethod
    def _del_user_count(cls):
      cls._user_count = 0

    # Class property using classmethod
    user_count = property(_get_user_count, _set_user_count, _del_user_count, "Total number of User instances.")

# Create User instances
user1 = User("Alice")
user2 = User("Bob")

# Access the class property
print(User.user_count)  # Output: 2

# Modify via class property
User.user_count = 5
print(User.user_count)

#Trying to set a negative value via the class property will raise a ValueError
try:
  User.user_count = -1
except ValueError as e:
  print(e)

# Delete using the class property.
del User.user_count
print(User.user_count)

print(user1.username) # Instance access
print(user2.username)

#Trying to access user_count from instance will result to value access
print(user1.user_count)
print(user2.user_count)

</code></pre>
</div>

<p>Dans cet exemple, <code class="language-python">user_count</code> est une property de classe. Notez l'utilisation de <code class="language-python">@classmethod</code>.  Les méthodes getter, setter et deleter associées à la property de classe doivent *obligatoirement* être des méthodes de classe (utilisant <code class="language-python">@classmethod</code>).  Elles prennent <code class="language-python">cls</code> (la classe elle-même) comme premier argument, et non <code class="language-python">self</code>. La property de classe est ensuite définie en utilisant la fonction <code class="language-python">property()</code>, mais cette fois directement au niveau de la classe, et non à l'intérieur d'une méthode. Contrairement aux properties d’instance, qui agissent sur des attributs d'instance via <code class="language-python">self</code>, les properties de classe accèdent et modifient des attributs *de classe* via <code class="language-python">cls</code>. L'attribut de classe sous-jacent est <code class="language-python">_user_count</code>. Il est <strong>fortement</strong> recommandé, par convention, de préfixer l'attribut de classe par un underscore pour indiquer qu'il est destiné à un usage "interne".</p>

<p>Il est crucial de comprendre que <code class="language-python">User.user_count</code> accède à la property de classe, tandis que <code class="language-python">user1.user_count</code> ou <code class="language-python">user2.user_count</code>, bien qu'apparemment similaire, accède *également à la valeur*, dans ce cas précis de property de classe. La property de classe est partagée. Si on l'attribuait à un attribut d'instance dans le constructeur <code class="language-python">__init__</code> (par exemple <code class="language-python">self.user_count = 0</code>), user1 et user2 auraient *chacun* leur propre copie de <code class="language-python">user_count</code>, qui serait une property *d'instance* (et une mauvaise pratique dans ce contexte de compteur). Les modifications apportées via <code class="language-python">user1.user_count</code> n'affecteraient pas <code class="language-python">user2.user_count</code>.</p>
</p>
  </section>
</div>
<div class="content_box">
  <section>
    <h2 class="heading">6. 6. Meilleures Pratiques et Pièges à Éviter avec les Properties Python</h2>
    <p><p>Voici des meilleures pratiques et des pièges à éviter lors de l’utilisation des <code class="language-python">properties</code> en Python :</p>

<h3>Meilleures Pratiques</h3>

<ol>
    <li><strong>Utilisez les properties pour les attributs calculés.</strong> 
        <p>Les properties sont idéales pour retourner des valeurs déduites d’autres attributs. Par exemple, un objet <code class="language-python">Sensor</code> peut calculer une moyenne mobile :</p>
        <div class="python-code">
            <pre><code class="language-python">
class Sensor:
    def __init__(self):
        self._raw_data = []
    
    @property
    def moving_average(self):
        """Calcule la moyenne mobile des 5 dernières valeurs."""
        if len(self._raw_data) &lt; 5:
            return None
        return sum(self._raw_data[-5:]) / 5
            </code></pre>
        </div>
    </li>
    <li><strong>Évitez les effets de bord dans les getters.</strong> 
        <p>Un getter doit être <em>idempotent</em> (ne pas modifier l’état interne de l’objet). Exemple incorrect :</p>
        <div class="python-code">
            <pre><code class="language-python">
class Counter:
    def __init__(self):
        self._count = 0
    
    @property
    def count(self):
        self._count += 1  # MAUVAISE PRATIQUE ! Modifie l'état en lecture
        return self._count
            </code></pre>
        </div>
    </li>
    <li><strong>Gérez les exceptions dans les setters.</strong>
        <p>Validez les valeurs entrantes pour éviter les erreurs silencieuses :</p>
        <div class="python-code">
            <pre><code class="language-python">
class TemperatureSensor:
    def __init__(self):
        self._value = 25.0
    
    @property
    def value(self):
        return self._value
    
    @value.setter
    def value(self, new_val):
        if not (-273.15 &lt;= new_val &lt;= 1000):
            raise ValueError("Température hors plage physique")
        self._value = new_val
            </code></pre>
        </div>
    </li>
    <li><strong>Utilisez les properties pour l’évaluation paresseuse.</strong>
        <p>Chargez des données coûteuses uniquement lors de la première lecture :</p>
        <div class="python-code">
            <pre><code class="language-python">
class DataLoader:
    def __init__(self, file_path):
        self._file_path = file_path
        self._data = None
    
    @property
    def data(self):
        if self._data is None:
            with open(self._file_path, 'r') as f:
                self._data = f.read().splitlines()
        return self._data
            </code></pre>
        </div>
    </li>
</ol>

<h3>Pièges à Éviter</h3>

<ul>
    <li><strong>Surutilisation des properties pour des attributs simples.</strong> 
        <p>Si un attribut n’a pas besoin de validation ou de logique, utilisez un attribut public directement :</p>
        <div class="python-code">
            <pre><code class="language-python">
# MAUVAIS USAGE
class SimpleObject:
    def __init__(self):
        self._name = ""
    
    @property
    def name(self):
        return self._name
    
    @name.setter
    def name(self, value):
        self._name = value

# MEILLEUR USAGE
class BetterObject:
    def __init__(self):
        self.name = ""  # Attribut public simple
            </code></pre>
        </div>
    </li>
    <li><strong>Références circulaires dans les properties.</strong>
        <p>Évitez de faire référence à la property elle-même dans la méthode <code class="language-python">@property</code> :</p>
        <div class="python-code">
            <pre><code class="language-python">
class BrokenClass:
    def __init__(self):
        self._value = 0
    
    @property
    def value(self):
        return self.value * 2  # INFINI RECURSION !!

    # CORRECTION : Utiliser l'attribut interne
    @property
    def fixed_value(self):
        return self._value * 2
            </code></pre>
        </div>
    </li>
    <li><strong>Oubli de la séparation entre property et attribut interne.</strong>
        <p>N’utilisez pas le même nom pour la property et l’attribut interne :</p>
        <div class="python-code">
            <pre><code class="language-python">
# ERREUR
class BadDesign:
    @property
    def temperature(self):
        return self.temperature  # Boucle infinie

# SOLUTION
class GoodDesign:
    def __init__(self):
        self._temperature = 20
    
    @property
    def temperature(self):
        return self._temperature
            </code></pre>
        </div>
    </li>
</ul>

<p>En suivant ces recommandations, vous maximiserez l’utilisation des properties tout en évitant les problèmes courants liés à leur gestion.</p></p>
    <h3>6.1 6.1 Quand et Pourquoi Utiliser les Properties : Règle du Moindre Surprise</h3>
    <p>```html
<p>Le principe du moindre étonnement (Rule of Least Surprise) est un concept fondamental en conception d'interfaces et en programmation orientée objet.  Il stipule qu'un composant d'un système doit se comporter d'une manière que la plupart des utilisateurs attendent, sans surprises inattendues.  Appliqué aux properties Python, cela signifie qu'une property doit se comporter, du point de vue de l'utilisateur, comme un attribut ordinaire. L'accès et la modification doivent paraître simples et directs, sans effets secondaires cachés ou comportements contre-intuitifs.</p>

<p><strong>Quand utiliser les properties :</strong></p>

<ul>
    <li><code class="language-python">Validation</code> : Assurer que les données restent dans des limites acceptables, comme un âge positif ou une chaîne de caractères non vide.</li>
    <li><code class="language-python">Calculs dérivés</code> : Fournir des valeurs calculées à partir d'autres attributs, sans stocker explicitement la valeur dérivée.</li>
    <li><code class="language-python">Contrôle d'accès</code> : Implémenter des règles d'accès spécifiques (lecture seule, écriture différée, etc.). C'est moins courant comme unique justification que les deux premiers cas. Il vaut mieux combiner un contrôle d'accès avec de la validation.</li>
    <li><code class="language-python">Conversion implicite</code>: Convertir de manière transparente les types lorsqu'un attribut est défini ou récupéré (par exemple convertir automatiquement des chaînes en nombres).</li>
</ul>

<p><strong>Quand *ne pas* utiliser les properties :</strong></p>

<ul>
  <li><strong>Opérations coûteuses en temps :</strong>  L'accès à un attribut est généralement perçu comme une opération rapide.  Si le getter effectue des calculs complexes, des accès à des bases de données, ou des requêtes réseau, cela viole le principe du moindre étonnement.  Dans ce cas, une méthode explicite (par exemple, <code class="language-python">calculate_value()</code>) est préférable.</li>
  <li><strong>Effets secondaires importants :</strong>  Modifier d'autres attributs ou l'état global de l'application dans un getter ou un setter est fortement déconseillé.  L'utilisateur s'attend à ce que la modification d'un attribut n'affecte que cet attribut spécifique.</li>
    <li><strong>Gestion des exceptions complexes:</strong> Lever des exceptions inattendues dans le getter ou le setter surprend l'utilisateur. Bien sûr, la validation peut lever des exceptions (par exemple, <code class="language-python">ValueError</code> si une valeur invalide est fournie), mais cela doit être clairement documenté et prévisible.</li>
  <li><strong>Logique métier complexe:</strong> Une property ne doit pas contenir la logique fondamentale de votre application. Si un processus prend un certain temps et modifie significativement l'état, c'est une méthode, pas une property.</li>
</ul>

<p><strong>Exemple de bon usage (validation) :</strong></p>

<div class="python-code">
    <pre><code class="language-python">
# Example of appropriate use of properties: Validating exam score
class Exam:
    def __init__(self, student_name, score=0):
        self.student_name = student_name
        self._score = score  # Internal attribute to store the score

    @property
    def score(self):
        return self._score

    @score.setter
    def score(self, new_score):
        if 0 <= new_score <= 100:
            self._score = new_score
        else:
            raise ValueError("Score must be between 0 and 100")

# Create an Exam object
math_exam = Exam("Alice", 85)
print(f"{math_exam.student_name}'s score: {math_exam.score}")

# Try setting a valid score
math_exam.score = 92
print(f"Updated score: {math_exam.score}")

# Attempt to set an invalid score
try:
    math_exam.score = 105
except ValueError as e:
    print(e)
    </code></pre>
</div>

<p>Dans cet exemple, la property <code class="language-python">score</code> garantit que la note de l'examen reste toujours entre 0 et 100.  L'utilisateur de la classe <code class="language-python">Exam</code> n'a pas besoin de se soucier de la validation; il accède et modifie <code class="language-python">score</code> comme un attribut normal. L'exception <code class="language-python">ValueError</code> est prévisible et fait partie du contrat de la property.</p>

<p><strong>Exemple de mauvais usage (effet secondaire caché et opération coûteuse) :</strong></p>

<div class="python-code">
    <pre><code class="language-python">
# Example of inappropriate use: Hidden side effect and expensive operation
import time
import random

class Dice:
    def __init__(self):
        self._last_roll = None
        self.roll_history = []

    @property
    def roll(self):
        #Simulate network latency.
        time.sleep(random.uniform(1,5)) # Simulate a time-consuming operation (e.g., network request)
        self._last_roll = random.randint(1, 6)
        self.roll_history.append(self._last_roll)
        return self._last_roll

# Create dice object
my_dice = Dice()
#Accessing the roll seems simple but has significant delay + modifies roll_history
print(f"First roll: {my_dice.roll}")
print(f"Second roll: {my_dice.roll}")
print(f"Roll history: {my_dice.roll_history}")
    </code></pre>
</div>
<p>Ici, l'accès à <code class="language-python">my_dice.roll</code> semble être une simple lecture d'attribut, mais en réalité, chaque appel : (1) prend un temps variable et potentiellement long à cause du <code class="language-python">time.sleep()</code>, simulant une requête réseau ;  (2) modifie l'état interne de l'objet en ajoutant une valeur à <code class="language-python">roll_history</code>.  Ces deux aspects violent le principe du moindre étonnement. Il serait beaucoup plus clair d'utiliser une méthode nommée <code class="language-python">roll_dice()</code>, par exemple, qui signalerait explicitement qu'une action est effectuée.</p>

<p>En résumé, une property doit émuler le comportement d'un attribut simple autant que possible.  Si l'opération sous-jacente est complexe, coûteuse, ou a des effets secondaires importants, une méthode explicite est toujours préférable pour maintenir la clarté et la prévisibilité du code.</p>
```</p>
    <h3>6.2 6.2 Pièges Courants : Effets Secondaires Indésirables et Performances</h3>
    <p>Content for 6. Meilleures Pratiques et Pièges à Éviter avec les Properties Python - 6.2 Pièges Courants : Effets Secondaires Indésirables et Performances could not be generated due to an error.</p>
    <h3>6.3 6.3 Alternatives aux Properties : Descripteurs et Data Classes en Python</h3>
    <p><p>Les properties Python offrent une gestion contrôlée des attributs, mais d’autres mécanismes existent pour des cas spécifiques. Les <code class="language-python">descripteurs</code> et les <code class="language-python">data classes</code> sont deux alternatives puissantes à explorer selon les besoins.</p>

<h3>Descripteurs : Un Contrôle Bas-Niveau</h3>
<p>Les descripteurs permettent de personnaliser le comportement d’accès et de modification d’un attribut via des méthodes spéciales comme <code class="language-python">__get__()</code> et <code class="language-python">__set__()</code>. Ils offrent plus de flexibilité que les properties en permettant une logique réutilisable entre plusieurs classes.</p>

<p>Exemple d’un descripteur pour valider une valeur positive :</p>
<div class="python-code">
    <pre><code class="language-python">
class PositiveValue:
    def __set__(self, instance, value):
        if value &lt; 0:
            raise ValueError("La valeur doit être positive")
        instance.__dict__[self.name] = value

    def __set_name__(self, owner, name):
        self.name = name

class Budget:
    amount = PositiveValue()  # Utilisation du descripteur

# Test
try:
    budget = Budget()
    budget.amount = -100  # Lève une erreur
except ValueError as e:
    print(e)  # Affiche "La valeur doit être positive"
    </code></pre>
</div>

<p>Points clés :</p>
<ul>
    <li><code class="language-python">__set_name__()</code> : Définit le nom de l’attribut automatiquement.</li>
    <li>Les descripteurs sont partagés entre toutes les instances d’une classe, idéal pour des logiques de validation réutilisables.</li>
</ul>

<h3>Data Classes : Simplifier la Déclaration</h3>
<p>Les <code class="language-python">data classes</code> (disponibles depuis Python 3.7) automatisent la création de classes de données avec des méthodes comme <code class="language-python">__init__()</code>, <code class="language-python">__repr__()</code>, et <code class="language-python">__eq__()</code>. Elles sont idéales pour des objets dont l’objectif est principalement de stocker des données.</p>

<p>Exemple d’une classe de coordonnées géographiques :</p>
<div class="python-code">
    <pre><code class="language-python">
from dataclasses import dataclass

@dataclass
class Coordinate:
    latitude: float
    longitude: float

    def __post_init__(self):
        if not (-90 &lt;= self.latitude &lt;= 90):
            raise ValueError("Latitude invalide")

# Test
try:
    coord = Coordinate(48.8566, 2.3522)  # Paris
    print(coord)  # Affiche "Coordinate(latitude=48.8566, longitude=2.3522)"
    invalid_coord = Coordinate(100, 0)  # Lève une erreur
except ValueError as e:
    print(e)  # Affiche "Latitude invalide"
    </code></pre>
</div>

<p>Avantages :</p>
<ul>
    <li>Évite la répétition de code boilerplate.</li>
    <li>Supporte les <code class="language-python">__slots__</code> pour optimiser la mémoire (via <code class="language-python">dataclass(frozen=True)</code>).</li>
</ul>

<h3>Comparaison et Choix Stratégique</h3>
<p>Voici un résumé des différences et des cas d’usage :</p>

<table>
    <tr>
        <th></th>
        <th>Properties</th>
        <th>Descripteurs</th>
        <th>Data Classes</th>
    </tr>
    <tr>
        <td>Complexité</td>
        <td>Basique (décorateur <code class="language-python">@property</code>).</td>
        <td>Avancé (implémentation de méthodes spéciales).</td>
        <td>Simple (décorateur <code class="language-python">@dataclass</code>).</td>
    </tr>
    <tr>
        <td>Réutilisabilité</td>
        <td>Non (logique liée à une classe).</td>
        <td>Oui (descripteur réutilisé entre classes).</td>
        <td>Oui (pour des structures de données standardisées).</td>
    </tr>
    <tr>
        <td>Cas d’usage idéal</td>
        <td>Validation simple pour un attribut spécifique.</td>
        <td>Logiques d’accès/stockage complexes et réutilisables.</td>
        <td>Création rapide de classes de données avec méthodes automatiques.</td>
    </tr>
</table>

<p><strong>Conseils pratiques :</strong></p>
<ol>
    <li>Utilisez les properties pour des cas simples (ex. calcul de prix TTC à partir de prix HT).</li>
    <li>Optez pour les descripteurs si vous avez besoin d’une logique d’accès partagée entre plusieurs classes (ex. validation de formats pour des attributs récurrents).</li>
    <li>Privilégiez les data classes pour des objets de données structurés sans logique complexe (ex. modèles de base de données simplifiés).</li>
</ol>

<p>En résumé, chaque mécanisme répond à un besoin spécifique. Les properties restent accessibles pour la plupart des besoins, tandis que les descripteurs et data classes offrent des solutions adaptées à des scénarios avancés ou répétitifs.</p></p>
  </section>
</div>
<div class="content_box">
  <section>
    <h2 class="heading">Conclusion</h2>
    <p>```html
<p>Les properties en Python représentent bien plus qu'une simple fonctionnalité syntaxique.  Elles constituent un pilier fondamental de la programmation orientée objet, offrant une approche élégante et "pythonique" pour gérer les attributs de vos classes.  En adoptant les properties, vous ouvrez la porte à un code plus propre, plus maintenable et considérablement plus robuste.</p>

<p>L'encapsulation, l'un des principes clés de la POO, est grandement facilitée par les properties.  Au lieu d'exposer directement les attributs internes d'une classe, vous fournissez des méthodes (getter, setter, deleter) qui contrôlent l'accès et la modification.  Ce niveau d'abstraction supplémentaire offre plusieurs avantages significatifs:</p>

<ul>
    <li><code class="language-python">Validation des données</code> :  Les setters vous permettent d'implémenter une logique de validation rigoureuse, garantissant que les attributs conservent des valeurs cohérentes et conformes aux exigences de votre application.  Vous pouvez ainsi prévenir les erreurs et les comportements inattendus en amont.</li>
    <li><code class="language-python">Attributs calculés</code> :  Les getters peuvent effectuer des calculs à la volée, transformant la propriété en un attribut dynamique dont la valeur est dérivée d'autres attributs ou de sources externes.  Cela évite la redondance et assure que les données sont toujours à jour.</li>
    <li><code class="language-python">Contrôle d'accès</code> :  Vous pouvez choisir de rendre un attribut en lecture seule en définissant uniquement un getter, ou interdire sa suppression en omettant le deleter.  Cela renforce la sécurité et la prévisibilité de votre code.</li>
     <li>Maintenance simplifiée: Modifier la logique interne d'une classe sans impacter le code qui l'utilise.</li>
</ul>

<p>Prenons l'exemple d'une classe représentant un segment de ligne.  Au lieu de stocker à la fois les coordonnées des extrémités et la longueur, nous pouvons utiliser une propriété pour calculer la longueur à la volée :</p>

<div class="python-code">
    <pre><code class="language-python">
import math

class LineSegment:
    def __init__(self, x1, y1, x2, y2):
        self._x1 = x1
        self._y1 = y1
        self._x2 = x2
        self._y2 = y2

    @property
    def length(self):
        # Calculate the length using the distance formula.
        return math.sqrt((self._x2 - self._x1)**2 + (self._y2 - self._y1)**2)

    @length.setter
    def length(self, new_length):
        #  Very basic length setter provided for example purposes, without
        #  changing the endpoints' positions it would not result
        # in a correct geometric representation.

        if new_length &lt; 0:
          raise ValueError("Length cannot be negative")

        print(f"Setting a new length: {new_length}  Note! The endpoints do not change position!")
        #In reality we would recalculate the endpoint based on the new length
        #but for demo, we do not.

    @length.deleter
    def length(self):
        print("Deleting length is not supported.")

# Example usage
line = LineSegment(1, 2, 4, 6)
print(f"Initial length: {line.length}")  # Calculated on-the-fly

line.length = 10  # Calls the setter
print(f"Length after attempted set: {line.length}")

del line.length
</code></pre>
</div>

<p>Dans cet exemple,  <code class="language-python">length</code>  apparaît comme un attribut normal du point de vue de l'utilisateur, mais sa valeur est calculée dynamiquement. Le setter permet d'assigner une nouvelle longueur (bien qu'ici, pour la simplicité, la position des points ne change pas) et implémente une validation. Le deleter, quant à lui, empêche la suppression de l'attribut <code class="language-python">length</code>.</p>

<p> Un autre cas d'usage serait la gestion des ressources, par exemple on pourrait modifier la classe :</p>

<div class="python-code">
<pre><code class="language-python">
class DatabaseConnection:
    def __init__(self):
        self._connection = None
        self._is_open = False

    @property
    def is_open(self):
      #Getter for checking the connection.
      return self._is_open

    def open_connection(self):
        # Simulate opening a database connection.
        if not self._is_open:
            # In a real-world scenario, this would involve actual connection logic.
            self._connection = "Connection Established"  # Placeholder
            self._is_open = True
            print("Database connection opened.")
        else:
            print("Connection is already open.")

    def close_connection(self):
        # Simulate closing the database connection.
        if self._is_open:
            self._connection = None
            self._is_open = False
            print("Database connection closed.")
        else:
            print("Connection is already closed.")

    def execute_query(self, query):
        #Placeholder for the query.
        if self.is_open:
          print(f"Executing query: {query}")
        else:
          raise Exception("Error. The connection is closed.")

#Example Usage
db_conn = DatabaseConnection()

try:
    print(f"Is connection open? {db_conn.is_open}")
    db_conn.open_connection()
    print(f"Is connection open? {db_conn.is_open}")

    db_conn.execute_query("SELECT * from USERS")
    db_conn.close_connection()
    print(f"Is connection open? {db_conn.is_open}")
    db_conn.execute_query("SELECT * from USERS") # This should raise an exception


except Exception as e:
    print(e)

finally:
  if db_conn.is_open:
    db_conn.close_connection()
</code></pre>
</div>

<p>Ici, la propriété <code class="language-python">is_open</code> encapsule l'état de la connexion, assurant que les opérations ne peuvent être effectuées que si la connexion est active. La gestion de la connexion (ouverture/fermeture) est découplée de l'utilisation, via l'appel à <code class="language-python">execute_query</code>. La gestion des exceptions et le bloc <code class="language-python">finally</code> garantit une fermeture de la connexion meme en cas d'erreur.</p>

<p>En conclusion, la maîtrise des properties est un atout indispensable pour tout développeur Python souhaitant écrire du code orienté objet de qualité professionnelle. Elles améliorent la lisibilité, la maintenabilité, et la robustesse de vos programmes en vous offrant un contrôle précis sur l'accès et la manipulation des attributs de vos classes. L'investissement dans l'apprentissage des properties se traduira par des gains significatifs en termes de productivité et de qualité logicielle.</p>
```</p>
  </section>
</div>
<!-- End of Course Marker -->
<div class="course-end-marker" style="margin: 4rem auto; text-align: center; max-width: 600px">
  <div style="height: 2px; background: linear-gradient(90deg, transparent, #fb5168 50%, transparent); margin: 2rem auto;"></div>
  <p style="color: #fb5168; font-size: 1.2rem; font-weight: 500; letter-spacing: 1px; opacity: 0.9;">
    That's all folks
  </p>
</div></div>
    </main>
  </body>
</html>
