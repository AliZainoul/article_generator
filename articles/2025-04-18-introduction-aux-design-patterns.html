<!DOCTYPE html>
<html class="style-orange-3 custom_fonts comps live_website" lang="fr">
  <head>
    <!------------------- Essential Meta Tags ------------------>    
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta property="og:type" content="website" />
    <!------------------- Essential Meta Tags ------------------>    

    <!-------------------- Core SEO Elements -------------------->    
    <!-- Essential Title and SEO Meta Tags PLACEHOLDER -->
    <title>Introduction aux design patterns | Formateur</title>
    <meta name="description" content="Découvrez tout sur Introduction aux design patterns dans cet article détaillé." />
    <meta property="og:title" content="Introduction aux design patterns | Formateur" />
    <meta property="og:description" content="Découvrez tout sur Introduction aux design patterns dans cet article détaillé." />
    <meta name="twitter:title" content="Introduction aux design patterns | Formateur" />
    <meta name="twitter:description" content="Découvrez tout sur Introduction aux design patterns dans cet article détaillé." />
    <!-- Essential Title and SEO Meta Tags PLACEHOLDER -->
    <!-------------------- Core SEO Elements -------------------->    

    <!-- Structured Data PLACEHOLDER -->
    <!-- Structured Data -->

    <!-- End Structured Data -->
    <!-- Structured Data PLACEHOLDER -->

    <!-------------- Canonical and Alternate Links PLACEHOLDER ------------->
    <!-------------- Canonical and Alternate Links ------------->

    <!-------------- Canonical and Alternate Links ------------->
    <!-------------- Canonical and Alternate Links PLACEHOLDER ------------->

    <!----------------- Favicon and Assets ------------------->
    <!-- Favicon and Social Media Images -->
    <link
      rel="icon"
      type="image/png"
      href="https://www.clearcode.fr/assets/icons/favicon.ico"
      sizes="48x48"
    />
    <meta
      property="og:image"
      content="https://www.clearcode.fr/assets/images/og-image.png"
    />
    <meta property="og:image:width" content="1200" />
    <meta property="og:image:height" content="630" />
    <meta
      property="og:image:alt"
      content="ClearCode - Formations en mathématiques et programmation IT"
    />
    <meta property="og:image:type" content="image/png" />
    <!-- Fallback image format -->
    <meta
      property="og:image"
      content="https://www.clearcode.fr/assets/images/og-image.webp"
    />
    <meta
      name="twitter:image"
      content="https://www.clearcode.fr/assets/images/og-image.png"
    />
    <!----------------- Favicon and Assets ------------------->

    <script src="/src/js/code-preprocessor.js"></script>

    <!-- Stylesheets -->
    <link rel="stylesheet" href="/src/css/main.css" />
    <link rel="stylesheet" href="/src/css/dropdown.css" />
    <link rel="stylesheet" href="/src/css/mobile-course-navbar.css" />

    <!-- Prism.js core script -->
    <script
      src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"
      defer
    ></script>
    <!-- Prism.js language support for Python -->
    <script
      src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-python.min.js"
      defer
    ></script>
    <script 
      src="/src/js/reduce-prism-dom.js" 
      defer>
    </script>


    <!-- Python Code CSS -->
    <link rel="stylesheet" href="/src/css/python-code.css" />

    <!-- Scripts -->
  </head>

  <body class="comps">
    <main class="container">
      <!-- 0. TITRE -->
      <div class="content_box">
        <h1 class="heading heading--accent">Introduction aux design patterns</h1>
      </div>

<div class="content_box">
  <section>
    <h2 class="heading">Introduction</h2>
    <p><p>Bienvenue dans cette introduction aux design patterns en Python. Les design patterns sont des solutions de conception éprouvées pour résoudre des problèmes récurrents dans le développement logiciel. Ils offrent un vocabulaire commun, permettant aux développeurs de communiquer efficacement et de saisir rapidement l'architecture d'une application.</p>
<p>L'utilisation appropriée des design patterns en Python favorise un code plus clair, plus facile à maintenir et à réutiliser. Plutôt que de réinventer des solutions à chaque projet, vous pouvez vous appuyer sur ces modèles pour structurer votre code de manière élégante et efficiente, améliorant ainsi la qualité et la robustesse de vos applications.</p>
<p>Prenons l'exemple du pattern Singleton. Ce pattern assure qu'une classe possède une unique instance et fournit un point d'accès global à cette instance. Voici une implémentation possible en Python :</p>
<pre><code class="language-python">
class Singleton:
    _instance = None  # Private attribute to hold the instance

    def __new__(cls, *args, **kwargs):
        # Check if an instance already exists
        if not cls._instance:
            # If not, create a new instance
            cls._instance = super(Singleton, cls).__new__(cls, *args, **kwargs)
            # You can initialize your singleton instance here.
            # For example:
            # cls._instance.value = 10
        # Return the instance
        return cls._instance

# Example Usage:
first_instance = Singleton()
second_instance = Singleton()

print(first_instance is second_instance) # Output: True.  Both variables point to the same object.
</code></pre>
<p>Dans cet article, nous explorerons comment ces patterns peuvent vous aider à développer des applications Python fiables et évolutives. Nous insisterons sur la compréhension des principes fondamentaux de chaque pattern, vous permettant de les adapter à vos besoins spécifiques. Préparez-vous à perfectionner vos compétences en conception logicielle et à produire un code Python plus élégant et performant !</p>
</p>
  </section>
</div>


<div class="content_box">
  <section>
    <h2 class="heading">1. Les fondements des design patterns en Python</h2>
    <p><p>Les design patterns sont des solutions éprouvées à des problèmes de conception récurrents en développement logiciel. En Python, ils permettent de structurer le code de manière à le rendre plus lisible, maintenable et évolutif. Maîtriser les fondements de ces patterns est donc un atout majeur pour tout développeur Python souhaitant écrire un code de qualité professionnelle.</p>

<p>Un des socles des design patterns est l'adhésion aux principes SOLID. SOLID est un acronyme regroupant cinq principes de conception essentiels :</p>
<ul>
    <li><strong>S</strong>ingle Responsibility Principle (Principe de responsabilité unique) : Une classe doit avoir une seule raison de changer. Cela signifie qu'elle doit avoir une seule responsabilité bien définie.</li>
    <li><strong>O</strong>pen/Closed Principle (Principe ouvert/fermé) : Une entité logicielle (classe, module, fonction, etc.) doit être ouverte à l'extension, mais fermée à la modification.  On peut ajouter de nouvelles fonctionnalités sans modifier le code existant.</li>
    <li><strong>L</strong>iskov Substitution Principle (Principe de substitution de Liskov) : Les sous-types doivent être substituables à leurs types de base sans altérer le comportement correct du programme.  Une sous-classe doit pouvoir être utilisée à la place de sa classe mère sans provoquer d'erreurs.</li>
    <li><strong>I</strong>nterface Segregation Principle (Principe de ségrégation des interfaces) : Il est préférable d'avoir plusieurs interfaces spécifiques à un client plutôt qu'une interface unique à usage général. Cela évite d'obliger une classe à implémenter des méthodes qu'elle n'utilise pas.</li>
    <li><strong>D</strong>ependency Inversion Principle (Principe d'inversion des dépendances) : Les modules de haut niveau ne doivent pas dépendre des modules de bas niveau. Les deux doivent dépendre des abstractions. Les abstractions ne doivent pas dépendre des détails. Les détails doivent dépendre des abstractions. Ce principe favorise le découplage entre les modules.</li>
</ul>
<p>Le respect de ces principes conduit à des systèmes plus robustes et adaptables, plus simples à comprendre, à tester et à maintenir. Les design patterns offrent souvent des mises en œuvre pratiques de ces principes.</p>

<p>L'abstraction est un autre concept fondamental. Elle consiste à simplifier la représentation d'un système en masquant les détails complexes et en ne présentant que les informations pertinentes. En Python, l'abstraction se manifeste souvent à travers les classes abstraites et les interfaces implicites (grâce au typage dynamique du langage).</p>

<pre><code class="language-python">
from abc import ABC, abstractmethod

class Shape(ABC):
    """
    An abstract base class for shapes.  This class cannot be instantiated directly.
    """
    @abstractmethod
    def area(self):
        """
        Abstract method to calculate the area.
        Subclasses must implement this method.  Raises NotImplementedError if not implemented.
        """
        pass

class Circle(Shape):
    """
    A concrete class representing a circle.  This class can be instantiated.
    """
    def __init__(self, radius):
        """
        Initializes the circle with a given radius.
        :param radius: The radius of the circle.
        """
        self.radius = radius

    def area(self):
        """
        Calculates the area of the circle.
        :return: The area of the circle.
        """
        return 3.14 * self.radius * self.radius

# Attempting to instantiate Shape would raise a TypeError because it's abstract.
# shape = Shape() # This line would cause an error

circle = Circle(5)
print(f"The area of the circle is: {circle.area()}")
</code></pre>

<p>Dans cet exemple, <code class="language-python">Shape</code> est une classe abstraite qui définit une interface (<code class="language-python">area()</code>) que toutes les formes doivent implémenter. <code class="language-python">Circle</code> est une implémentation concrète de cette interface. L'abstraction permet ainsi de définir un comportement général sans imposer une implémentation spécifique.</p>

<p>Enfin, la composition est un concept clé qui permet de construire des objets complexes en les agrégeant à partir d'objets plus simples. En Python, cela se traduit par la définition de classes qui contiennent d'autres classes comme attributs, établissant une relation "a un".</p>

<pre><code class="language-python">
class Engine:
    """
    Represents an engine.
    """
    def start(self):
        """
        Starts the engine.
        :return: A message indicating that the engine has started.
        """
        return "Engine started"

class Car:
    """
    Represents a car.
    """
    def __init__(self):
        """
        Initializes the car with an engine.
        Composition: Car has-a Engine.
        """
        self.engine = Engine()

    def drive(self):
        """
        Drives the car by starting the engine.
        :return: A message indicating that the car is moving.
        """
        return self.engine.start() + " and car is moving"

my_car = Car()
print(my_car.drive())
</code></pre>

<p>Ici, la classe <code class="language-python">Car</code> "a un" <code class="language-python">Engine</code>. Au lieu d'hériter d'une classe <code class="language-python">Engine</code>, <code class="language-python">Car</code> utilise une instance de <code class="language-python">Engine</code>. La composition encourage la flexibilité et la réutilisation du code, car les composants peuvent être combinés de diverses manières, sans créer de hiérarchie d'héritage rigide.</p>

<p>En résumé, les design patterns reposent sur des principes fondamentaux comme SOLID, l'abstraction et la composition. Une compréhension approfondie de ces concepts est indispensable pour exploiter pleinement le potentiel des design patterns et produire un code Python de qualité supérieure.</p>
</p>
    <h3>1.1 Qu'est-ce qu'un design pattern ?</h3>
    <p><p>En Python, les design patterns sont des solutions éprouvées à des problèmes de conception récurrents. Ils fournissent un cadre de référence pour structurer votre code, le rendant plus lisible, maintenable et évolutif. L'adoption de ces modèles favorise une communication plus efficace au sein des équipes de développement, car ils établissent un vocabulaire commun et des approches standardisées.</p>

<p>Leur principal avantage réside dans la résolution de défis de conception fréquemment rencontrés. Imaginez, par exemple, que vous ayez besoin de créer une famille d'objets apparentés sans spécifier leurs classes concrètes à l'avance. Le pattern Abstract Factory serait une solution idéale. Ou, si vous devez gérer l'accès à une ressource partagée de manière centralisée, le pattern Singleton pourrait s'avérer crucial. En utilisant les design patterns, vous capitalisez sur l'expérience de la communauté et vous évitez de réinventer des solutions qui ont déjà fait leurs preuves.</p>

<p>Un atout majeur des design patterns est la réutilisation de l'architecture du code. Bien que l'implémentation exacte varie en fonction du contexte, la structure fondamentale du pattern reste constante. Cela vous permet d'appliquer le même pattern dans différents projets, en l'adaptant aux besoins spécifiques de chaque situation. Par conséquent, vous accélérez le processus de développement et vous améliorez la qualité globale de votre code.</p>

<p>Prenons l'exemple du pattern Observer. Il définit une dépendance un-à-plusieurs entre des objets, de sorte que lorsqu'un objet change d'état, tous ses dépendants sont notifiés et mis à jour automatiquement. Voici une illustration simple en Python:</p>

<pre><code class="language-python">
# Define the Subject class
class Subject:
    def __init__(self):
        self._observers = []  # list of observers
        self._state = None

    def attach(self, observer):
        self._observers.append(observer)

    def detach(self, observer):
        self._observers.remove(observer)

    def notify(self):
        for observer in self._observers:
            observer.update(self._state)

    @property
    def state(self):
        return self._state

    @state.setter
    def state(self, value):
        self._state = value
        self.notify()

# Define the Observer class
class Observer:
    def update(self, state):
        print(f"Observer received update. New state: {state}")

# Example usage
subject = Subject()
observer1 = Observer()
observer2 = Observer()

subject.attach(observer1)
subject.attach(observer2)

subject.state = "New State"  # This will notify all attached observers
</code></pre>

<p>Dans cet exemple, la classe <code class="language-python">Subject</code> maintient une liste d'objets <code class="language-python">Observer</code>. Lorsque l'état du sujet change, la méthode <code class="language-python">notify()</code> est appelée, informant tous les observateurs de la mise à jour. Ce pattern est particulièrement utile pour gérer les événements et les mises à jour en temps réel.</p>

<p>En résumé, les design patterns sont des outils puissants qui permettent aux développeurs Python de créer un code plus propre, plus modulable et plus maintenable. Ils facilitent la collaboration au sein des équipes, améliorent la compréhension du code et offrent des solutions élégantes et efficaces aux problèmes de conception complexes. L'investissement dans l'apprentissage et l'application des design patterns est un atout précieux pour tout développeur Python souhaitant maîtriser l'art de la conception logicielle.</p>
</p>
    <h3>1.2 Classification des design patterns (création, structure, comportement)</h3>
    <p><p>Les design patterns, bien qu'abstraits, peuvent être regroupés en catégories distinctes en fonction du problème qu'ils cherchent à résoudre. Cette classification aide à mieux comprendre leur rôle et à choisir le pattern le plus adapté à une situation donnée. On distingue principalement trois grandes familles : les patterns de création, les patterns de structure et les patterns de comportement.</p>

<p>Les <strong>patterns de création</strong> offrent des mécanismes pour instancier des objets de manière flexible et contrôlée. Ils permettent de masquer la logique d'instanciation complexe et de créer des objets sans spécifier leur classe concrète. Un exemple courant est le pattern Abstract Factory, qui permet de créer des familles d'objets liés sans dépendre de leurs classes concrètes.</p>

<p>Considérons un exemple simple avec différentes usines qui créent des meubles:</p>

<pre><code class="language-python">
# Abstract Factory
class AbstractFurnitureFactory:
    def create_chair(self):
        raise NotImplementedError

    def create_table(self):
        raise NotImplementedError

# Concrete Factories
class ModernFurnitureFactory(AbstractFurnitureFactory):
    def create_chair(self):
        return ModernChair()

    def create_table(self):
        return ModernTable()

class VictorianFurnitureFactory(AbstractFurnitureFactory):
    def create_chair(self):
        return VictorianChair()

    def create_table(self):
        return VictorianTable()

# Abstract Products
class AbstractChair:
    def __str__(self):
        raise NotImplementedError

class AbstractTable:
    def __str__(self):
        raise NotImplementedError

# Concrete Products
class ModernChair(AbstractChair):
    def __str__(self):
        return "Modern Chair"

class ModernTable(AbstractTable):
    def __str__(self):
        return "Modern Table"

class VictorianChair(AbstractChair):
    def __str__(self):
        return "Victorian Chair"

class VictorianTable(AbstractTable):
    def __str__(self):
        return "Victorian Table"

# Usage
modern_factory = ModernFurnitureFactory()
chair = modern_factory.create_chair()
table = modern_factory.create_table()
print(f"Modern Furniture: {chair}, {table}")

victorian_factory = VictorianFurnitureFactory()
chair = victorian_factory.create_chair()
table = victorian_factory.create_table()
print(f"Victorian Furniture: {chair}, {table}")
</code></pre>

<p>Les <strong>patterns de structure</strong> concernent la composition des classes et des objets pour former des structures plus vastes. Ils aident à définir des relations entre les entités, de manière à simplifier la conception et à accroître la flexibilité. Le pattern Decorator en est un bon exemple. Il permet d'ajouter dynamiquement des responsabilités à un objet sans modifier sa classe. Cela se fait en enveloppant l'objet original dans une série de décorateurs, chacun ajoutant une fonctionnalité spécifique.</p>

<p>Prenons un exemple d'un service de notification où l'on peut ajouter des décorateurs pour envoyer des notifications par email ou SMS :</p>

<pre><code class="language-python">
# Component Interface
class NotificationService:
    def send(self, message):
        raise NotImplementedError

# Concrete Component
class BaseNotificationService(NotificationService):
    def send(self, message):
        print(f"Sending notification: {message}")

# Decorator
class NotificationDecorator(NotificationService):
    def __init__(self, wrappee):
        self._wrappee = wrappee

    def send(self, message):
        self._wrappee.send(message)

# Concrete Decorators
class EmailNotificationDecorator(NotificationDecorator):
    def send(self, message):
        super().send(message)
        print(f"Sending email: {message}")

class SMSNotificationDecorator(NotificationDecorator):
    def send(self, message):
        super().send(message)
        print(f"Sending SMS: {message}")

# Usage
service = BaseNotificationService()
email_service = EmailNotificationDecorator(service)
sms_service = SMSNotificationDecorator(email_service)

sms_service.send("Hello, world!")
</code></pre>

<p>Les <strong>patterns de comportement</strong> s'intéressent aux algorithmes et à l'assignation des responsabilités entre les objets. Ils décrivent les schémas de communication entre les objets et contrôlent la façon dont les différents objets interagissent entre eux.  Un exemple pertinent est le pattern Strategy, qui permet de définir une famille d'algorithmes, de les encapsuler chacun dans une classe, et de les rendre interchangeables. Cela permet de choisir l'algorithme approprié au moment de l'exécution.</p>

<p>Voici un exemple avec différentes stratégies de paiement :</p>

<pre><code class="language-python">
# Strategy Interface
class PaymentStrategy:
    def pay(self, amount):
        raise NotImplementedError

# Concrete Strategies
class CreditCardPayment(PaymentStrategy):
    def __init__(self, card_number, cvv):
        self.card_number = card_number
        self.cvv = cvv

    def pay(self, amount):
        print(f"Paying {amount} using Credit Card {self.card_number}")

class PayPalPayment(PaymentStrategy):
    def __init__(self, email):
        self.email = email

    def pay(self, amount):
        print(f"Paying {amount} using PayPal account {self.email}")

# Context
class ShoppingCart:
    def __init__(self, payment_strategy: PaymentStrategy):
        self.payment_strategy = payment_strategy
        self.total_amount = 0

    def add_item(self, price):
        self.total_amount += price

    def checkout(self):
        self.payment_strategy.pay(self.total_amount)

# Usage
credit_card = CreditCardPayment("1234-5678-9012-3456", "123")
cart = ShoppingCart(credit_card)
cart.add_item(100)
cart.add_item(50)
cart.checkout()

paypal = PayPalPayment("test@example.com")
cart = ShoppingCart(paypal)
cart.add_item(200)
cart.checkout()
</code></pre>

<p>Cette classification en trois catégories est cruciale car elle offre une perspective structurée sur la manière dont les design patterns peuvent être appliqués pour résoudre différents types de problèmes de conception. En comprenant ces catégories, les développeurs peuvent identifier plus facilement le pattern approprié pour une situation donnée et améliorer la qualité et la maintenabilité de leur code Python.</p>
</p>
  </section>
</div>


<div class="content_box">
  <section>
    <h2 class="heading">2. Design patterns de création en Python</h2>
    <p><p>Les design patterns de création offrent des solutions pour instancier des objets de manière flexible et réutilisable. Ils permettent de masquer la logique d'instanciation complexe et de découpler le code client de la création concrète des objets, améliorant ainsi la modularité et la maintenabilité du code.</p>

<p><strong>Singleton</strong></p>

<p>Le pattern Singleton garantit qu'une classe n'a qu'une seule instance et fournit un point d'accès global à celle-ci.  C'est particulièrement utile pour gérer des ressources partagées, des configurations globales ou des caches, où avoir plusieurs instances pourrait entraîner des incohérences ou des conflits.</p>

<pre><code class="language-python">
class ConfigurationManager:
    _instance = None  # Private attribute to hold the instance

    def __new__(cls, *args, **kwargs):
        # Called before __init__
        if cls._instance is None:
            cls._instance = super(ConfigurationManager, cls).__new__(cls)
            # Initialize configuration (e.g., load from file)
            cls._instance.config = {}
        return cls._instance

    def load_config(self, filename):
        # Load configuration from a file
        self.config['filename'] = filename
        print(f"Configuration loaded from {filename}")

# Example Usage
config_manager1 = ConfigurationManager()
config_manager1.load_config("app.config")

config_manager2 = ConfigurationManager()
print(config_manager1 is config_manager2)  # Output: True

# Demonstrate that both variables point to the same configuration
config_manager2.load_config("new_app.config") # This will also affect config_manager1
print(config_manager1.config)
</code></pre>

<p>Dans cet exemple, <code class="language-python">ConfigurationManager</code> est implémenté comme un Singleton. La méthode <code class="language-python">__new__</code> est utilisée pour contrôler la création d'instances. Si aucune instance n'existe, elle en crée une nouvelle; sinon, elle retourne l'instance existante.  Toutes les références à <code class="language-python">ConfigurationManager</code> pointeront vers la même instance, assurant un accès unique et cohérent à la configuration.</p>

<p><strong>Factory Method</strong></p>

<p>Le pattern Factory Method définit une interface pour créer un objet, mais laisse les sous-classes décider quelle classe instancier. Il favorise le découplage en déléguant la logique d'instanciation aux classes filles.  Cela permet d'ajouter facilement de nouveaux types d'objets sans modifier le code client existant.</p>

<pre><code class="language-python">
from abc import ABC, abstractmethod

class Document(ABC):  # Abstract Base Class
    @abstractmethod
    def __init__(self):
        self.content = ""

    @abstractmethod
    def display(self):
        pass

class PdfDocument(Document):
    def __init__(self):
        super().__init__()
        self.content = "PDF Document Content"

    def display(self):
        print(self.content)

class WordDocument(Document):
    def __init__(self):
        super().__init__()
        self.content = "Word Document Content"

    def display(self):
        print(self.content)

class DocumentFactory:
    def create_document(self, doc_type):
        if doc_type == "pdf":
            return PdfDocument()
        elif doc_type == "word":
            return WordDocument()
        else:
            raise ValueError("Invalid document type")

# Example Usage
factory = DocumentFactory()
pdf_doc = factory.create_document("pdf")
pdf_doc.display()

word_doc = factory.create_document("word")
word_doc.display()
</code></pre>

<p>Ici, <code class="language-python">DocumentFactory</code> est responsable de la création des objets <code class="language-python">PdfDocument</code> et <code class="language-python">WordDocument</code>. Le code client interagit avec la factory via la méthode <code class="language-python">create_document</code>, sans avoir besoin de connaître les classes concrètes des documents. Cela simplifie le code client et le rend plus facile à maintenir et à étendre.</p>

<p><strong>Abstract Factory</strong></p>

<p>Le pattern Abstract Factory fournit une interface pour créer des familles d'objets liés sans spécifier leurs classes concrètes. Il est particulièrement utile lorsque vous avez plusieurs familles d'objets qui doivent être utilisées ensemble et que vous voulez assurer la cohérence entre les objets créés.</p>

<pre><code class="language-python">
from abc import ABC, abstractmethod

class AbstractButton(ABC):
    @abstractmethod
    def display(self):
        pass

class AbstractCheckbox(ABC):
    @abstractmethod
    def display(self):
        pass

class WindowsButton(AbstractButton):
    def display(self):
        return "Windows Button"

class WindowsCheckbox(AbstractCheckbox):
    def display(self):
        return "Windows Checkbox"

class MacButton(AbstractButton):
    def display(self):
        return "Mac Button"

class MacCheckbox(AbstractCheckbox):
    def display(self):
        return "Mac Checkbox"

class AbstractGUIFactory(ABC):
    @abstractmethod
    def create_button(self):
        pass

    @abstractmethod
    def create_checkbox(self):
        pass

class WindowsGUIFactory(AbstractGUIFactory):
    def create_button(self):
        return WindowsButton()

    def create_checkbox(self):
        return WindowsCheckbox()

class MacGUIFactory(AbstractGUIFactory):
    def create_button(self):
        return MacButton()

    def create_checkbox(self):
        return MacCheckbox()

# Example Usage
def create_ui(factory: AbstractGUIFactory):
    button = factory.create_button()
    checkbox = factory.create_checkbox()
    print(button.display())
    print(checkbox.display())

windows_factory = WindowsGUIFactory()
create_ui(windows_factory)

mac_factory = MacGUIFactory()
create_ui(mac_factory)
</code></pre>

<p>Dans cet exemple, <code class="language-python">AbstractGUIFactory</code> définit une interface pour créer des boutons et des cases à cocher. Les usines concrètes, comme <code class="language-python">WindowsGUIFactory</code> et <code class="language-python">MacGUIFactory</code>, implémentent cette interface pour créer des objets spécifiques à chaque plateforme. Le client utilise une fabrique abstraite pour créer des objets sans connaître leurs classes concrètes, ce qui permet de changer facilement de thème ou de style d'interface utilisateur.</p>

<p><strong>Builder</strong></p>

<p>Le pattern Builder sépare la construction d'un objet complexe de sa représentation. Cela permet au même processus de construction de créer différentes représentations. Il est utile lorsque la création d'un objet implique plusieurs étapes complexes et que vous voulez éviter un constructeur avec un grand nombre de paramètres.</p>

<pre><code class="language-python">
class Pizza:
    def __init__(self):
        self.dough = None
        self.sauce = None
        self.topping = None

    def __str__(self):
        return f"Pizza with dough: {self.dough}, sauce: {self.sauce}, topping: {self.topping}"

class PizzaBuilder:
    def __init__(self):
        self.pizza = Pizza()

    def add_dough(self, dough):
        self.pizza.dough = dough
        return self  # Return self for chaining

    def add_sauce(self, sauce):
        self.pizza.sauce = sauce
        return self  # Return self for chaining

    def add_topping(self, topping):
        self.pizza.topping = topping
        return self  # Return self for chaining

    def build(self):
        return self.pizza

# Example Usage
builder = PizzaBuilder()
pizza = builder.add_dough("thin").add_sauce("tomato").add_topping("mushrooms").build()
print(pizza)

# Creating another pizza with different toppings
veggie_pizza = PizzaBuilder().add_dough("thick").add_sauce("pesto").add_topping("spinach").add_topping("olives").build()
print(veggie_pizza)
</code></pre>

<p>Ici, <code class="language-python">PizzaBuilder</code> fournit une interface fluide (grâce au chaînage des méthodes) pour construire un objet <code class="language-python">Pizza</code> étape par étape. Le code client peut choisir les étapes à exécuter et l'ordre dans lequel elles sont exécutées, ce qui offre une grande flexibilité dans la création de l'objet.</p>

<p><strong>Prototype</strong></p>

<p>Le pattern Prototype spécifie les types d'objets à créer à partir d'une instance prototype, et crée de nouveaux objets en copiant ce prototype. Il est utile lorsque la création d'objets est coûteuse ou complexe, et que les nouveaux objets sont similaires à des objets existants. Cela peut améliorer les performances en évitant de répéter des processus de création coûteux.</p>

<pre><code class="language-python">
import copy

class Sheep:
    def __init__(self, name, age):
        self.name = name
        self.age = age

    def __str__(self):
        return f"Sheep named {self.name}, {self.age} years old"

    def clone(self):
        # Create a deep copy to avoid sharing references
        return copy.deepcopy(self)

# Example Usage
original_sheep = Sheep("Dolly", 5)
cloned_sheep = original_sheep.clone()
cloned_sheep.name = "Dolly2"  # Modify the cloned sheep

print(original_sheep)
print(cloned_sheep)

# Verify that the objects are distinct
print(original_sheep is cloned_sheep) # Output: False
</code></pre>

<p>Dans cet exemple, <code class="language-python">Sheep</code> implémente une méthode <code class="language-python">clone</code> qui crée une copie profonde de l'objet à l'aide de <code class="language-python">copy.deepcopy()</code>. Cela permet de créer de nouveaux objets <code class="language-python">Sheep</code> en copiant un prototype existant, sans affecter l'objet original. La copie profonde assure que les attributs de l'objet sont également copiés récursivement, évitant ainsi des problèmes de partage de références.</p>

<p>En résumé, les design patterns de création offrent des outils puissants pour gérer la création d'objets de manière flexible et maintenable. Le choix du pattern approprié dépend des exigences spécifiques du projet, notamment la complexité de la création des objets, la nécessité de découpler le code client des classes concrètes, et les contraintes de performance.</p>
</p>
    <h3>2.1 Singleton</h3>
    <p><p>Le pattern Singleton est un patron de conception de création qui garantit qu'une classe n'a qu'une seule instance et fournit un point d'accès global à cette instance. Il est particulièrement utile lorsque l'on souhaite contrôler strictement l'instanciation d'une classe, par exemple pour gérer des ressources partagées, des configurations globales ou des connexions à une base de données.</p>

<p>Une manière courante d'implémenter le Singleton en Python consiste à utiliser la méthode spéciale <code class="language-python">__new__</code>. Cette méthode est appelée avant <code class="language-python">__init__</code> lors de la création d'une instance. En la surchargeant, on peut contrôler le processus d'instanciation et s'assurer qu'une seule instance est créée.</p>

<pre><code class="language-python">
class DatabaseConnection:
    _instance = None  # Private attribute to hold the instance

    def __new__(cls, *args, **kwargs):
        if cls._instance is None:
            cls._instance = super().__new__(cls, *args, **kwargs)
            # Initialize the instance (optional)
            cls._instance.connection = "Established"
            print("New connection created")
        else:
            print("Connection already exists")
        return cls._instance

    def get_connection_status(self):
        return self.connection

# Example usage
db1 = DatabaseConnection()
db2 = DatabaseConnection()

print(db1.get_connection_status())
print(db2.get_connection_status())

print(db1 is db2)  # Verify that they are the same instance
</code></pre>

<p>Dans cet exemple, <code class="language-python">DatabaseConnection</code> est une classe Singleton. La première fois que <code class="language-python">DatabaseConnection()</code> est appelé, une nouvelle instance est créée et stockée dans l'attribut de classe <code class="language-python">_instance</code>.  Les appels suivants à <code class="language-python">DatabaseConnection()</code> renvoient simplement l'instance existante, évitant ainsi la création de nouvelles connexions. L'attribut <code class="language-python">connection</code> sert ici à illustrer une initialisation (optionnelle) de l'instance.</p>

<p>Une autre approche pour implémenter le pattern Singleton en Python est d'utiliser un décorateur. Les décorateurs offrent une manière élégante de modifier le comportement d'une fonction ou d'une classe sans modifier son code source.</p>

<pre><code class="language-python">
def singleton(cls):
    _instance = {}

    def get_instance(*args, **kwargs):
        if cls not in _instance:
            _instance[cls] = cls(*args, **kwargs)
        return _instance[cls]

    return get_instance

@singleton
class Logger:
    def __init__(self):
        self.log_file = "application.log"
        print("Logger initialized")

    def log_message(self, message):
        with open(self.log_file, "a") as f:
            f.write(message + "\n")

# Example usage
logger1 = Logger()
logger2 = Logger()

logger1.log_message("This is a log message from logger1")
logger2.log_message("This is a log message from logger2")

print(logger1 is logger2)  # Verify that they are the same instance
</code></pre>

<p>Ici, le décorateur <code class="language-python">singleton</code> prend une classe en argument et renvoie une fonction <code class="language-python">get_instance</code>. Cette fonction maintient un dictionnaire <code class="language-python">_instance</code> pour garder une trace des instances de la classe décorée. La première fois que <code class="language-python">Logger()</code> est appelé, une nouvelle instance de <code class="language-python">Logger</code> est créée et stockée dans ce dictionnaire. Les appels suivants renvoient simplement la même instance. Dans ce cas, cela permet d'assurer qu'il n'y ait qu'un seul fichier de log utilisé par l'application.</p>

<p>Le pattern Singleton doit être utilisé avec discernement. Une utilisation excessive peut conduire à un code plus difficile à tester et à maintenir, en introduisant un état global implicite. Il est donc crucial de bien évaluer la nécessité d'un Singleton avant de l'implémenter. Cependant, dans les cas appropriés, il offre une solution propre et efficace pour garantir qu'une seule instance d'une classe soit disponible, facilitant ainsi la gestion de ressources partagées et la cohérence de l'état global de l'application.</p>
</p>
    <h3>2.2 Factory Method</h3>
    <p><p>Le pattern Factory Method est un patron de conception de création qui délègue l'instanciation d'une classe à ses sous-classes. Il définit une interface pour créer un objet, mais laisse les sous-classes décider quelle classe instancier. Cette approche permet de créer des objets sans spécifier explicitement leur type concret, améliorant la flexibilité et la maintenabilité du code. L'intérêt principal réside dans la séparation des responsabilités : la classe cliente ne se soucie pas de la logique de création des objets.</p>

<p>L'idée centrale est de définir une "factory" (fabrique) qui contient une méthode "factory method". Les classes concrètes implémentent cette méthode pour créer des objets spécifiques. Le code client utilise ensuite cette fabrique pour obtenir des instances d'objets sans avoir à connaître les classes concrètes impliquées, ni la logique de création sous-jacente. Cela favorise un couplage faible et facilite l'ajout de nouvelles classes sans modifier le code existant.</p>

<p>Illustrons cela avec une hiérarchie de classes d'animaux (<code class="language-python">Dog</code>, <code class="language-python">Cat</code>) et une fabrique pour les créer. Cet exemple démontre clairement comment le Factory Method sépare la création des objets de leur utilisation, rendant le code plus modulaire et extensible.</p>

<pre><code class="language-python">
# Define the base class for animals
class Animal:
    def __init__(self, name):
        self.name = name

    def speak(self):
        raise NotImplementedError("Subclasses must implement the speak method")

# Define concrete animal classes
class Dog(Animal):
    def speak(self):
        return "Woof!"

class Cat(Animal):
    def speak(self):
        return "Meow!"

# Define the AnimalFactory class
class AnimalFactory:
    def create_animal(self, animal_type, name):
        if animal_type == "dog":
            return Dog(name)
        elif animal_type == "cat":
            return Cat(name)
        else:
            raise ValueError("Invalid animal type")

# Usage
factory = AnimalFactory()
dog = factory.create_animal("dog", "Buddy")
cat = factory.create_animal("cat", "Whiskers")

print(f"{dog.name} says: {dog.speak()}")
print(f"{cat.name} says: {cat.speak()}")
</code></pre>

<p>Analysons cet exemple :</p>

<ul>
    <li><code class="language-python">Animal</code> est la classe de base, fournissant une interface commune pour tous les animaux. Elle déclare une méthode abstraite <code class="language-python">speak()</code>.</li>
    <li><code class="language-python">Dog</code> et <code class="language-python">Cat</code> sont des sous-classes concrètes d'<code class="language-python">Animal</code>. Chacune implémente la méthode <code class="language-python">speak()</code> pour retourner le son spécifique à l'animal.</li>
    <li><code class="language-python">AnimalFactory</code> est la fabrique. Sa méthode <code class="language-python">create_animal()</code> agit comme le factory method. Elle prend le type d'animal en paramètre et retourne une instance de la classe correspondante.</li>
</ul>

<p>Le client (dans la section "Usage") interagit avec la <code class="language-python">AnimalFactory</code> pour créer des objets <code class="language-python">Dog</code> et <code class="language-python">Cat</code>. Il n'a pas besoin de connaître les détails de l'implémentation concrète de ces classes. L'ajout d'un nouveau type d'animal (par exemple, <code class="language-python">Bird</code>) se ferait en créant une nouvelle classe <code class="language-python">Bird</code> héritant d'<code class="language-python">Animal</code>, puis en modifiant la méthode <code class="language-python">create_animal()</code> dans <code class="language-python">AnimalFactory</code> pour gérer le nouveau type. Le code client resterait inchangé, démontrant ainsi l'extensibilité du pattern.</p>

<p>Le Factory Method est particulièrement pertinent dans les situations suivantes :</p>

<ul>
    <li>Une classe ne connaît pas à l'avance le type d'objets qu'elle doit créer.</li>
    <li>Une classe délègue à ses sous-classes la responsabilité de spécifier les objets à créer.</li>
    <li>La centralisation de la logique de création d'objets simplifie la maintenance et réduit la duplication de code.</li>
</ul>

<p>En résumé, le Factory Method offre une solution élégante pour découpler la création d'objets de leur utilisation, améliorant la flexibilité, la maintenabilité et l'extensibilité du code.</p>
</p>
    <h3>2.3 Abstract Factory</h3>
    <p><p>Le pattern Abstract Factory est un patron de conception de création qui fournit une interface pour créer des familles d'objets liés ou dépendants sans spécifier leurs classes concrètes. Il encapsule la logique de création, permettant de masquer la complexité et d'assurer la cohérence entre les objets d'une même famille. Il est particulièrement utile lorsque le système doit être indépendant de la façon dont ses objets sont créés, composés et représentés.</p>

<p>Prenons l'exemple d'une application devant supporter différents thèmes d'interface utilisateur (UI), tels que "light" et "dark". Chaque thème nécessite un ensemble spécifique de widgets (boutons, zones de texte, etc.) avec un style visuel distinct. L'Abstract Factory est parfaitement adapté pour gérer cette diversité de thèmes.</p>

<p>Voici une implémentation possible de l'Abstract Factory en Python :</p>

<pre><code class="language-python">
# Abstract Product: Button
class AbstractButton:
    def draw(self):
        raise NotImplementedError

# Concrete Product: Light Button
class LightButton(AbstractButton):
    def draw(self):
        return "Light Button"

# Concrete Product: Dark Button
class DarkButton(AbstractButton):
    def draw(self):
        return "Dark Button"

# Abstract Product: Text Field
class AbstractTextField:
    def display(self):
        raise NotImplementedError

# Concrete Product: Light Text Field
class LightTextField(AbstractTextField):
    def display(self):
        return "Light Text Field"

# Concrete Product: Dark Text Field
class DarkTextField(AbstractTextField):
    def display(self):
        return "Dark Text Field"

# Abstract Factory
class AbstractThemeFactory:
    def create_button(self):
        raise NotImplementedError

    def create_text_field(self):
        raise NotImplementedError

# Concrete Factory: Light Theme Factory
class LightThemeFactory(AbstractThemeFactory):
    def create_button(self):
        return LightButton()

    def create_text_field(self):
        return LightTextField()

# Concrete Factory: Dark Theme Factory
class DarkThemeFactory(AbstractThemeFactory):
    def create_button(self):
        return DarkButton()

    def create_text_field(self):
        return DarkTextField()

# Client code
def create_ui(factory: AbstractThemeFactory):
    button = factory.create_button()
    text_field = factory.create_text_field()
    return button.draw(), text_field.display()

# Usage
light_theme_factory = LightThemeFactory()
light_button, light_text_field = create_ui(light_theme_factory)
print(light_button)
print(light_text_field)

dark_theme_factory = DarkThemeFactory()
dark_button, dark_text_field = create_ui(dark_theme_factory)
print(dark_button)
print(dark_text_field)
</code></pre>

<p>Dans cet exemple :</p>

<ul>
    <li><code class="language-python">AbstractButton</code> et <code class="language-python">AbstractTextField</code> sont les produits abstraits, définissant les interfaces communes pour les boutons et les champs de texte.</li>
    <li><code class="language-python">LightButton</code>, <code class="language-python">DarkButton</code>, <code class="language-python">LightTextField</code> et <code class="language-python">DarkTextField</code> sont les produits concrets, fournissant les implémentations spécifiques pour chaque thème.</li>
    <li><code class="language-python">AbstractThemeFactory</code> est la factory abstraite, définissant les méthodes pour créer des boutons et des champs de texte.</li>
    <li><code class="language-python">LightThemeFactory</code> et <code class="language-python">DarkThemeFactory</code> sont les factories concrètes, chacune créant une famille d'objets UI pour un thème spécifique (light ou dark).</li>
    <li>La fonction <code class="language-python">create_ui</code> représente le client. Elle utilise la factory abstraite pour créer l'interface utilisateur sans connaître les classes concrètes.  Ceci permet une flexibilité accrue et un couplage faible entre le client et les implémentations spécifiques des thèmes.</li>
</ul>

<p>L'Abstract Factory permet de garantir que les objets créés appartiennent à la même famille et sont cohérents entre eux.  Dans notre exemple, on s'assure qu'un thème donné n'aura pas des éléments d'UI provenant d'un autre thème.  De plus, l'Abstract Factory facilite l'ajout de nouveaux thèmes sans modifier le code client existant, respectant ainsi le principe d'ouverture/fermeture (Open/Closed Principle) de la conception orientée objet. En résumé, l'Abstract Factory améliore la modularité, la maintenabilité et l'extensibilité du code.</p>
</p>
  </section>
</div>


<div class="content_box">
  <section>
    <h2 class="heading">3. Design patterns structurels en Python</h2>
    <p><p>Les design patterns structurels se concentrent sur la manière d'organiser les classes et les objets pour construire des structures plus vastes et complexes. Ils visent à simplifier la conception en identifiant des relations entre les entités, rendant ainsi le système plus facile à comprendre et à maintenir.</p>

<p>Voici quelques design patterns structurels courants en Python:</p>

<ul>
    <li><b>Adapter</b>: Permet à des classes avec des interfaces incompatibles de collaborer en traduisant l'interface d'une classe en une autre que le client attend.</li>
    <li><b>Bridge</b>: Dissocie une abstraction de son implémentation, permettant aux deux de varier indépendamment.</li>
    <li><b>Composite</b>: Permet de traiter un groupe d'objets de la même manière qu'un seul objet.</li>
    <li><b>Decorator</b>: Ajoute dynamiquement des responsabilités à un objet sans modifier sa structure.</li>
    <li><b>Facade</b>: Fournit une interface simplifiée pour un sous-système complexe.</li>
    <li><b>Flyweight</b>: Réduit la consommation de mémoire en partageant autant de données que possible entre des objets similaires.</li>
    <li><b>Proxy</b>: Fournit un substitut pour un autre objet, contrôlant l'accès à celui-ci.</li>
</ul>

<p>Illustrons le pattern <b>Adapter</b> avec un exemple concret.  Imaginez que vous travaillez avec une ancienne API qui renvoie des données au format XML, mais votre application attend des données JSON.</p>

<pre><code class="language-python">
class XMLData:
    def __init__(self):
        # Simulate XML data
        self.data = '&lt;root&gt;&lt;item name="example" value="123" /&gt;&lt;/root&gt;'

    def get_xml_data(self):
        return self.data
</code></pre>

<p>Vous avez une nouvelle classe qui traite et affiche les données JSON :</p>

<pre><code class="language-python">
import json

class JSONDisplayer:
    def display_json(self, json_data):
        print(f"JSON Data: {json_data}")
</code></pre>

<p>L'adaptateur convertit les données XML en JSON:</p>

<pre><code class="language-python">
import xml.etree.ElementTree as ET

class XMLToJSONAdapter:
    def __init__(self, xml_data_provider):
        # The adapter receives the XML data provider
        self.xml_data_provider = xml_data_provider

    def convert_to_json(self):
        # Get XML data
        xml_data = self.xml_data_provider.get_xml_data()
        # Parse XML
        root = ET.fromstring(xml_data)
        # Convert to JSON
        json_data = {}
        for element in root:
            json_data[element.get('name')] = element.get('value')
        return json.dumps(json_data)
</code></pre>

<p>Voici comment utiliser l'adaptateur pour afficher les données XML au format JSON:</p>

<pre><code class="language-python">
xml_data = XMLData()
json_displayer = JSONDisplayer()
adapter = XMLToJSONAdapter(xml_data)
json_data = adapter.convert_to_json()
json_displayer.display_json(json_data)
</code></pre>

<p>L'exemple montre comment l'<b>Adapter</b> permet à deux classes avec des interfaces incompatibles de fonctionner ensemble harmonieusement. Il encapsule la logique de conversion, ce qui rend le code plus propre et plus maintenable.</p>

<p>Le pattern <b>Decorator</b> permet d'étendre les fonctionnalités d'un objet dynamiquement. Prenons l'exemple d'une classe de base représentant un service de notification. On peut ajouter des fonctionnalités comme la journalisation ou la gestion des erreurs sans modifier la classe de base.</p>

<pre><code class="language-python">
class NotificationService:
    def send(self, message):
        return f"Sending notification: {message}"

class LoggingDecorator:
    def __init__(self, service):
        self._service = service

    def send(self, message):
        print(f"Logging: Sending message: {message}")
        return self._service.send(message)

class ErrorHandlingDecorator:
    def __init__(self, service):
        self._service = service

    def send(self, message):
        try:
            return self._service.send(message)
        except Exception as e:
            print(f"Error: {e}")
            return None
</code></pre>

<p>L'utilisation des décorateurs est transparente :</p>

<pre><code class="language-python">
service = NotificationService()
logged_service = LoggingDecorator(service)
error_handled_service = ErrorHandlingDecorator(logged_service)

print(service.send("Hello"))
print(logged_service.send("Hello"))
print(error_handled_service.send("Hello"))
</code></pre>

<p>Dans ce cas, <code class="language-python">LoggingDecorator</code> et <code class="language-python">ErrorHandlingDecorator</code> ajoutent des comportements supplémentaires (journalisation et gestion des erreurs) à l'objet <code class="language-python">NotificationService</code> sans impacter son code original.  Cela respecte le principe d'ouverture/fermeture.</p>

<p>En conclusion, les design patterns structurels fournissent un ensemble d'outils pour créer des architectures logicielles robustes, modulaires et évolutives. Leur application judicieuse permet d'améliorer la qualité du code et de faciliter sa maintenance à long terme.</p>
</p>
    <h3>3.1 Adapter</h3>
    <p><p>Le pattern Adapter est un patron de conception structurel qui permet à des classes ayant des interfaces incompatibles de collaborer. Il agit comme un adaptateur, convertissant l'interface d'une classe en une interface compatible attendue par un client. Ce pattern est particulièrement utile lorsque l'on interagit avec du code existant, des bibliothèques tierces ou des systèmes legacy où la modification du code source original n'est pas possible ou souhaitable.</p>
<p>L'idée principale est d'encapsuler une des classes incompatibles à l'intérieur d'une classe "Adapter". Cette classe Adapter implémente l'interface attendue par le client. L'Adapter traduit ensuite les requêtes du client en appels appropriés vers la classe qu'elle enveloppe.</p>
<p>Considérons un exemple pratique. Supposons que nous ayons une ancienne API de gestion de documents qui fonctionne avec un format de données spécifique. Nous souhaitons utiliser une nouvelle bibliothèque d'analyse de données qui attend un format de données différent. Le pattern Adapter peut être utilisé pour résoudre ce problème d'incompatibilité.</p>
<pre><code class="language-python">
# Old API for document management
class LegacyDocumentManager:
    def __init__(self, filename):
        self.filename = filename

    def load_document(self):
        # Simulate loading data from the old format
        # This could involve specific parsing logic
        return f"Legacy data from {self.filename}"

# New data analysis library
class DataAnalyzer:
    def __init__(self):
        pass

    def analyze_data(self, data):
        # Simulate analyzing data
        return f"Analysis result: {data}"

# Adapter class to make LegacyDocumentManager compatible with DataAnalyzer
class DocumentDataAdapter:
    def __init__(self, legacy_document_manager):
        self.legacy_document_manager = legacy_document_manager

    def get_data(self):
        # Adapt the data from LegacyDocumentManager to the format expected by DataAnalyzer
        legacy_data = self.legacy_document_manager.load_document()
        # Perform necessary adaptation steps here
        adapted_data = f"Adapted: {legacy_data}"
        return adapted_data

# Usage
legacy_manager = LegacyDocumentManager("old_document.txt")
analyzer = DataAnalyzer()
adapter = DocumentDataAdapter(legacy_manager)
data = adapter.get_data()
analysis_result = analyzer.analyze_data(data)
print(analysis_result)
</code></pre>
<p>Dans cet exemple, <code class="language-python">LegacyDocumentManager</code> représente l'ancienne API, et <code class="language-python">DataAnalyzer</code> représente la nouvelle bibliothèque. La classe <code class="language-python">DocumentDataAdapter</code> agit comme l'adapter. Elle reçoit une instance de <code class="language-python">LegacyDocumentManager</code> et implémente une méthode <code class="language-python">get_data()</code> qui extrait et adapte les données de l'ancienne API dans un format compatible avec <code class="language-python">DataAnalyzer</code>. L'adaptation pourrait impliquer une conversion de format de données, un remapping de champs ou toute autre transformation nécessaire.</p>
<p>Le pattern Adapter offre plusieurs avantages :</p>
<ul>
    <li>Il permet de réutiliser des classes existantes ayant des interfaces incompatibles.</li>
    <li>Il respecte le principe de responsabilité unique en séparant la logique d'adaptation du reste du code.</li>
    <li>Il améliore la flexibilité du code en permettant de changer facilement les classes utilisées sans impacter le reste du système.</li>
    <li>Il facilite l'intégration de bibliothèques tierces ou de systèmes legacy.</li>
</ul>
<p>En conclusion, le pattern Adapter est un outil puissant pour faire collaborer des composants incompatibles au sein d'un système, ce qui facilite la réutilisation du code et améliore la maintenabilité. Il est particulièrement utile dans les situations où la modification des classes existantes n'est pas possible ou souhaitable, ou lorsqu'on doit intégrer des systèmes hétérogènes.</p>
</p>
    <h3>3.2 Decorator</h3>
    <p><p>Le pattern Decorator est un patron de conception structurel qui permet d'ajouter dynamiquement des responsabilités à un objet existant, sans pour autant modifier sa structure interne. Il offre une alternative flexible à l'héritage pour étendre les fonctionnalités d'un objet. En Python, les décorateurs bénéficient d'une syntaxe particulièrement élégante via l'utilisation du symbole <code class="language-python">@decorator</code>.</p>

<p>L'idée centrale du pattern Decorator est d'envelopper l'objet original (appelé "composant") dans un ou plusieurs objets "décorateurs". Chaque décorateur ajoute une responsabilité spécifique au composant. L'objet décoré conserve son interface originale, ce qui permet d'ajouter ou de retirer des décorations de manière transparente, sans impacter le code client existant.</p>

<p>Prenons un exemple concret avec une classe simple représentant un composant d'interface utilisateur. Imaginons que nous souhaitions ajouter dynamiquement des bordures et des ombres à ce composant.</p>

<pre><code class="language-python">
class UIComponent:
    def __init__(self, name):
        self.name = name

    def render(self):
        return f"Rendering {self.name}"
</code></pre>

<p>Nous pouvons créer des classes décorateurs pour ajouter les fonctionnalités de bordure et d'ombre :</p>

<pre><code class="language-python">
class BorderDecorator:
    def __init__(self, component, border_width):
        self.component = component  # The component to decorate
        self.border_width = border_width

    def render(self):
        # Add border to the component's rendering
        return f"&lt;border width={self.border_width}&gt;{self.component.render()}&lt;/border&gt;"

class ShadowDecorator:
    def __init__(self, component, shadow_intensity):
        self.component = component  # The component to decorate
        self.shadow_intensity = shadow_intensity

    def render(self):
        # Add shadow to the component's rendering
        return f"&lt;shadow intensity={self.shadow_intensity}&gt;{self.component.render()}&lt;/shadow&gt;"
</code></pre>

<p>Voyons maintenant comment utiliser ces décorateurs pour enrichir notre composant :</p>

<pre><code class="language-python">
# Create a simple UI component
component = UIComponent("Button")

# Add a border
bordered_component = BorderDecorator(component, 2)

# Add a shadow
shadowed_bordered_component = ShadowDecorator(bordered_component, 5)

# Render the decorated component
print(shadowed_bordered_component.render())
# Output: <shadow intensity=5><border width=2>Rendering Button</border></shadow>
</code></pre>

<p>Un autre cas d'utilisation très courant des décorateurs est l'ajout de fonctionnalités de journalisation (logging).  Supposons que nous ayons une fonction et que nous souhaitions enregistrer (logger) chaque appel à cette fonction, ainsi que ses arguments et sa valeur de retour.</p>

<pre><code class="language-python">
import functools
import logging

# Configure logging (optional, but good practice)
logging.basicConfig(level=logging.INFO)

def log_calls(func):
    @functools.wraps(func)  # Preserves original function's metadata
    def wrapper(*args, **kwargs):
        logging.info(f"Calling function: {func.__name__} with arguments {args} and keyword arguments {kwargs}")
        result = func(*args, **kwargs)
        logging.info(f"Function {func.__name__} returned: {result}")
        return result
    return wrapper

@log_calls
def add(x, y):
    """Adds two numbers together."""
    return x + y

result = add(5, 3)
print(f"Final result: {result}")
</code></pre>

<p>Dans cet exemple, <code class="language-python">log_calls</code> est un décorateur qui "enveloppe" la fonction <code class="language-python">add</code>. Chaque fois que la fonction <code class="language-python">add</code> est appelée, le décorateur enregistre les arguments et la valeur de retour en utilisant le module <code class="language-python">logging</code>. L'utilisation de <code class="language-python">@functools.wraps(func)</code> est cruciale; elle permet de préserver les métadonnées de la fonction originale, telles que son nom, sa docstring et autres attributs.</p>

<p>Le pattern Decorator offre une grande flexibilité pour ajouter des comportements à des objets de manière dynamique, sans modifier leur code source directement. Cela favorise un code plus propre, plus modulaire et plus facile à maintenir, tout en respectant les principes de la programmation orientée objet.</p>
</p>
    <h3>3.3 Composite</h3>
    <p><p>Le pattern Composite est un patron de conception structurel qui permet de traiter des objets individuels et des groupes d'objets de manière uniforme. Il organise les objets dans une structure arborescente, représentant une hiérarchie partie-tout. L'intérêt majeur est de permettre au client de manipuler les objets individuels et les compositions d'objets via une interface commune.</p>

<p>L'avantage principal de ce pattern est la simplification du code client. Au lieu d'avoir une logique différente pour traiter un objet simple et un ensemble d'objets, le client interagit avec eux de la même façon, grâce à une interface unifiée.</p>

<p>Imaginez une organisation d'entreprise. Elle est composée d'employés (objets individuels) et de départements (groupes d'objets). Un département peut contenir d'autres départements ou directement des employés. L'objectif du pattern Composite est de pouvoir effectuer des opérations, comme le calcul des coûts salariaux, indifféremment sur un employé ou sur un département entier.</p>

<p>Voici une implémentation possible en Python :</p>

<pre><code class="language-python">
class Component:
    """
    Abstract class representing a component in the hierarchy.
    """
    def get_salary(self):
        """
        A method to get the salary. To be implemented by subclasses.
        """
        raise NotImplementedError("Subclasses must implement get_salary()")

    def __str__(self):
        raise NotImplementedError("Subclasses must implement __str__()")

class Employee(Component):
    """
    Represents an individual employee (leaf node).
    """
    def __init__(self, name, salary):
        self.name = name
        self.salary = salary

    def get_salary(self):
        return self.salary

    def __str__(self):
        return f"Employee: {self.name}, Salary: {self.salary}"


class Department(Component):
    """
    Represents a department, which can contain other departments or employees (composite node).
    """
    def __init__(self, name):
        self.name = name
        self.employees = []

    def add(self, employee):
        self.employees.append(employee)

    def remove(self, employee):
        self.employees.remove(employee)

    def get_salary(self):
        total_salary = 0
        for employee in self.employees:
            total_salary += employee.get_salary()
        return total_salary

    def __str__(self):
        employee_names = [str(employee) for employee in self.employees]
        return f"Department: {self.name}, Employees: {', '.join(employee_names)}"
</code></pre>

<p>Dans cet exemple, la classe <code class="language-python">Employee</code> représente la feuille de l'arbre (un employé), et la classe <code class="language-python">Department</code> représente le composite (un département). Les deux classes héritent d'une classe abstraite <code class="language-python">Component</code> et implémentent une méthode <code class="language-python">get_salary()</code>, permettant de calculer le salaire total de la même manière, et une méthode <code class="language-python">__str__()</code> pour une représentation en chaîne de caractères.</p>

<p>Voici un exemple d'utilisation:</p>

<pre><code class="language-python">
# Create employees
john = Employee("John", 50000)
jane = Employee("Jane", 60000)
mike = Employee("Mike", 70000)

# Create departments
sales_department = Department("Sales")
sales_department.add(john)
sales_department.add(jane)

engineering_department = Department("Engineering")
engineering_department.add(mike)

# Create the main organization
organization = Department("Organization")
organization.add(sales_department)
organization.add(engineering_department)

# Calculate total salary for the entire organization
print(f"Total salary for {sales_department.name}: {sales_department.get_salary()}")
print(f"Total salary for {engineering_department.name}: {engineering_department.get_salary()}")
print(f"Total salary for {organization.name}: {organization.get_salary()}")

# Print the organization structure
print(organization)

# Remove an employee
sales_department.remove(john)
print(f"Total salary for {sales_department.name} after removing John: {sales_department.get_salary()}")
print(sales_department)
</code></pre>

<p>Dans cet exemple, nous créons des employés et des départements, puis nous les organisons dans une structure hiérarchique. Nous pouvons ensuite calculer le salaire total de chaque département et de l'organisation entière en utilisant la même méthode <code class="language-python">get_salary()</code>.  On démontre aussi la suppression d'un élément.</p>

<p>Le pattern Composite est particulièrement adapté pour représenter des structures arborescentes, comme les interfaces graphiques (GUI), les systèmes de fichiers, ou les organigrammes, où des opérations doivent être appliquées uniformément à des éléments individuels et à des groupes d'éléments.</p>
</p>
  </section>
</div>


<div class="content_box">
  <section>
    <h2 class="heading">4. Design patterns comportementaux en Python</h2>
    <p><p>Les design patterns comportementaux s'intéressent à la manière dont les objets interagissent et se répartissent les responsabilités. Ils favorisent un code plus flexible, modulaire et maintenable en définissant des mécanismes de communication standardisés. Découvrons quelques exemples clés.</p>

<p><strong>Observer</strong>: Ce pattern établit une relation de dépendance un-à-plusieurs entre les objets. Ainsi, lorsqu'un objet change d'état, tous ses dépendants sont automatiquement notifiés et mis à jour.</p>

<pre><code class="language-python">
# Subject: the object that holds the state and notifies observers
class NewsPublisher:
    def __init__(self):
        self._observers = []  # List of observers
        self._news = None       # The latest news

    def attach(self, observer):
        # Add an observer to the list
        self._observers.append(observer)

    def detach(self, observer):
        # Remove an observer from the list
        self._observers.remove(observer)

    def _notify(self):
        # Notify all observers about the new news
        for observer in self._observers:
            observer.update(self._news)

    def set_news(self, news):
        # Set the news and notify observers
        self._news = news
        self._notify()

# Observer: the object that gets notified when the subject's state changes
class NewsSubscriber:
    def __init__(self, name):
        self.name = name  # Subscriber's name

    def update(self, news):
        # Update method called when news is received
        print(f"{self.name} received news: {news}")

# Usage
publisher = NewsPublisher()

subscriber1 = NewsSubscriber("Alice")
subscriber2 = NewsSubscriber("Bob")

publisher.attach(subscriber1)
publisher.attach(subscriber2)

publisher.set_news("Breaking news: Python 3.12 released!")

publisher.detach(subscriber2)

publisher.set_news("Another news: Python wins TIOBE index.")
</code></pre>

<p>Dans cet exemple, <code class="language-python">NewsPublisher</code> joue le rôle du sujet (Subject), tandis que <code class="language-python">NewsSubscriber</code> est l'observateur (Observer). Lorsque <code class="language-python">NewsPublisher</code> publie de nouvelles informations, tous les abonnés enregistrés sont avertis.</p>

<p><strong>Template Method</strong>: Ce pattern définit la structure d'un algorithme dans une méthode, tout en permettant aux sous-classes de redéfinir certaines étapes sans altérer la structure globale. Il offre une base commune pour des algorithmes similaires, tout en autorisant des variations spécifiques.</p>

<pre><code class="language-python">
# Abstract class defining the template method
from abc import ABC, abstractmethod

class DataProcessor(ABC):
    def process_data(self):
        # Template method defining the processing steps
        self.read_data()
        self.validate_data()
        self.transform_data()
        self.write_data()
    
    @abstractmethod
    def read_data(self):
        # Abstract method to be implemented by subclasses
        pass

    @abstractmethod
    def validate_data(self):
        # Abstract method to be implemented by subclasses
        pass

    def transform_data(self):
        # Concrete method with default implementation
        print("Transforming data...")

    @abstractmethod
    def write_data(self):
        # Abstract method to be implemented by subclasses
        pass

# Concrete class implementing the template method
class CSVDataProcessor(DataProcessor):
    def read_data(self):
        print("Reading data from CSV file...")

    def validate_data(self):
        print("Validating CSV data...")

    def write_data(self):
        print("Writing data to database...")

# Usage
processor = CSVDataProcessor()
processor.process_data()
</code></pre>

<p>Dans cet exemple, la classe <code class="language-python">DataProcessor</code> définit le squelette de l'algorithme, tandis que <code class="language-python">CSVDataProcessor</code> implémente les étapes spécifiques.  La méthode <code class="language-python">process_data</code>, la template method, orchestre l'exécution des différentes étapes.</p>

<p>Ces design patterns, ainsi que d'autres tels que Chain of Responsibility, Command, Iterator, Mediator, Memento, State et Visitor, fournissent des solutions éprouvées pour maîtriser la complexité des interactions entre les objets. Ils contribuent à l'élaboration d'une architecture logicielle plus robuste, flexible et facile à maintenir sur le long terme.</p>
</p>
    <h3>4.1 Observer</h3>
    <p><p>Le pattern Observer définit une relation de dépendance de type un-à-plusieurs entre des objets. Lorsqu'un objet change d'état, tous ses dépendants sont notifiés et mis à jour automatiquement. Ce pattern est particulièrement utile lorsqu'un objet (appelé le sujet) doit informer plusieurs autres objets (appelés observateurs) d'un changement d'état, sans avoir besoin de connaître leur identité ou leur nombre exact à l'avance. Cela permet de maintenir un couplage faible entre le sujet et ses observateurs.</p>

<p>En Python, l'implémentation du pattern Observer implique généralement une classe sujet qui gère une liste d'observateurs. Cette classe fournit des méthodes pour ajouter (<code class="language-python">attach()</code>) et supprimer (<code class="language-python">detach()</code>) des observateurs, ainsi qu'une méthode pour notifier (<code class="language-python">notify()</code>) tous les observateurs lorsqu'un changement se produit. Les observateurs, quant à eux, implémentent une interface commune, souvent sous la forme d'une méthode <code class="language-python">update()</code>, qui est appelée par le sujet lors de la notification.</p>

<p>Prenons l'exemple d'un capteur de température (le sujet) qui notifie différents affichages (les observateurs) de sa valeur actuelle.</p>

<pre><code class="language-python">
class TemperatureSensor:
    """
    The Subject class manages observers and notifies them of state changes.
    """

    def __init__(self):
        self._observers = []  # List of observers
        self._temperature = 0  # Current temperature

    def attach(self, observer):
        """
        Attach an observer to the subject's list.
        """
        self._observers.append(observer)

    def detach(self, observer):
        """
        Detach an observer from the subject's list.
        """
        self._observers.remove(observer)

    def notify(self):
        """
        Notify all observers about a state change.
        """
        for observer in self._observers:
            observer.update(self._temperature)

    def set_temperature(self, temperature):
        """
        Set the current temperature and notify observers.
        """
        self._temperature = temperature
        self.notify()


class TemperatureDisplay:
    """
    Concrete Observers react to the updates issued by the Subject.
    """

    def __init__(self, sensor, name):
        self._sensor = sensor
        self._sensor.attach(self)  # Subscribe to the sensor
        self._name = name  # Display name

    def update(self, temperature):
        """
        Receive update from subject and display the new temperature.
        """
        print(f"{self._name}: Temperature updated to {temperature}°C")

    def detach(self):
        """
        Detach from the subject.
        """
        self._sensor.detach(self)


# Client code demonstrating the Observer pattern
sensor = TemperatureSensor()

display1 = TemperatureDisplay(sensor, "Display 1")
display2 = TemperatureDisplay(sensor, "Display 2")

sensor.set_temperature(25)  # Temperature change triggers notifications
sensor.set_temperature(30)

display1.detach()  # Unsubscribe display1

sensor.set_temperature(35)  # Only display2 will be notified
</code></pre>

<p>Dans cet exemple :</p>
<ul>
    <li>La classe <code class="language-python">TemperatureSensor</code> représente le sujet. Elle maintient une liste d'observateurs et fournit les méthodes <code class="language-python">attach()</code>, <code class="language-python">detach()</code> et <code class="language-python">notify()</code> pour gérer les observateurs et les informer des changements de température.</li>
    <li>La classe <code class="language-python">TemperatureDisplay</code> est un observateur concret. Elle s'abonne au capteur lors de sa création et implémente la méthode <code class="language-python">update()</code> pour réagir aux changements de température en affichant la nouvelle valeur.</li>
</ul>

<p>Ce pattern permet de découpler le capteur (le sujet) des affichages (les observateurs).  De nouveaux types d'affichages peuvent être ajoutés sans qu'il soit nécessaire de modifier le code du capteur.  Le capteur n'a pas besoin de connaître les détails d'implémentation des affichages, ce qui facilite la maintenance et l'évolution du système.</p>

<p>En résumé, le pattern Observer est un mécanisme puissant pour gérer les dépendances entre objets et assurer la cohérence des états dans un système. Il favorise un couplage faible, une extensibilité élevée et une meilleure modularité du code.</p>
</p>
    <h3>4.2 Strategy</h3>
    <p><p>Le pattern Strategy permet de définir une famille d'algorithmes, de les encapsuler chacun dans une classe séparée, et de les rendre interchangeables. Il permet de choisir l'algorithme à utiliser au moment de l'exécution. L'idée clé est de séparer l'algorithme de l'objet (appelé "contexte") qui l'utilise. Le contexte maintient une référence à un objet Strategy et délègue l'exécution de l'algorithme à cette stratégie.</p>

<p>Voici un exemple illustrant différentes stratégies de tri :</p>

<pre><code class="language-python">
from abc import ABC, abstractmethod

# Define the Strategy abstract base class
class SortingStrategy(ABC):
    @abstractmethod
    def sort(self, data):
        pass

# Concrete strategy: Bubble Sort
class BubbleSortStrategy(SortingStrategy):
    def sort(self, data):
        n = len(data)
        for i in range(n):
            for j in range(0, n-i-1):
                if data[j] > data[j+1]:
                    data[j], data[j+1] = data[j+1], data[j]
        return data

# Concrete strategy: Merge Sort
class MergeSortStrategy(SortingStrategy):
    def sort(self, data):
        if len(data) > 1:
            mid = len(data) // 2
            left_half = data[:mid]
            right_half = data[mid:]

            self.sort(left_half)
            self.sort(right_half)

            i = j = k = 0

            while i < len(left_half) and j < len(right_half):
                if left_half[i] < right_half[j]:
                    data[k] = left_half[i]
                    i += 1
                else:
                    data[k] = right_half[j]
                    j += 1
                k += 1

            while i < len(left_half):
                data[k] = left_half[i]
                i += 1
                k += 1

            while j < len(right_half):
                data[k] = right_half[j]
                j += 1
                k += 1
        return data

# Context class: Data Sorter
class DataSorter:
    def __init__(self, strategy: SortingStrategy):
        self._strategy = strategy

    def set_strategy(self, strategy: SortingStrategy):
        self._strategy = strategy

    def sort(self, data):
        return self._strategy.sort(data)

# Client code
if __name__ == "__main__":
    data = [5, 2, 8, 1, 9, 4]

    # Using Bubble Sort
    bubble_sort = BubbleSortStrategy()
    sorter = DataSorter(bubble_sort)
    sorted_data_bubble = sorter.sort(data.copy())  # Use a copy to avoid modifying the original
    print(f"Bubble Sort: {sorted_data_bubble}")

    # Using Merge Sort
    merge_sort = MergeSortStrategy()
    sorter.set_strategy(merge_sort)
    sorted_data_merge = sorter.sort(data.copy())  # Use a copy to avoid modifying the original
    print(f"Merge Sort: {sorted_data_merge}")
</code></pre>

<p>Dans cet exemple :</p>

<ul>
    <li><code class="language-python">SortingStrategy</code> est une classe abstraite qui définit l'interface pour toutes les stratégies de tri.</li>
    <li><code class="language-python">BubbleSortStrategy</code> et <code class="language-python">MergeSortStrategy</code> sont des implémentations concrètes de la stratégie de tri.</li>
    <li><code class="language-python">DataSorter</code> est le contexte. Il maintient une référence à une stratégie et l'utilise pour trier les données.  La méthode <code class="language-python">set_strategy()</code> permet de changer dynamiquement la stratégie utilisée.</li>
</ul>

<p>Ce pattern offre une grande flexibilité.  Il permet d'ajouter facilement de nouvelles stratégies de tri sans modifier le code du <code class="language-python">DataSorter</code>. De plus, le client peut choisir la stratégie à utiliser au moment de l'exécution, ce qui rend le code plus adaptable aux différents besoins.</p>
</p>
    <h3>4.3 Template Method</h3>
    <p><p>Le patron de conception Template Method est un patron de conception comportemental qui définit le squelette d'un algorithme dans une méthode, en déléguant certaines étapes à des sous-classes. Il permet de définir la structure de l'algorithme une seule fois et de laisser les sous-classes redéfinir certaines étapes sans modifier la structure globale de l'algorithme.</p>

<p>Ce pattern est particulièrement utile lorsque plusieurs classes doivent exécuter des opérations similaires dans un ordre précis, mais que certaines étapes de ces opérations varient d'une classe à l'autre. Il encourage la réutilisation du code et l'adhésion au principe DRY ("Don't Repeat Yourself").</p>

<p>Voici une implémentation en Python illustrant ce concept, avec une classe abstraite <code class="language-python">HouseBuilder</code> et des sous-classes concrètes <code class="language-python">WoodHouseBuilder</code> et <code class="language-python">BrickHouseBuilder</code> :</p>

<pre><code class="language-python">
from abc import ABC, abstractmethod

class HouseBuilder(ABC):
    """
    Abstract base class that defines the template method.
    """
    def build_house(self):
        """
        Template method that defines the sequence of steps for building a house.
        """
        self.build_foundation()
        self.build_walls()
        self.build_roof()
        self.add_finishing()

    @abstractmethod
    def build_foundation(self):
        """
        Abstract method to build the foundation.  Must be implemented by subclasses.
        """
        pass

    @abstractmethod
    def build_walls(self):
        """
        Abstract method to build the walls. Must be implemented by subclasses.
        """
        pass

    @abstractmethod
    def build_roof(self):
        """
        Abstract method to build the roof. Must be implemented by subclasses.
        """
        pass

    def add_finishing(self):
        """
        Concrete method to add finishing touches.  Can be overridden by subclasses.
        """
        print("Adding basic finishing.")


class WoodHouseBuilder(HouseBuilder):
    """
    Concrete class that builds a wood house.
    """
    def build_foundation(self):
        print("Building a wooden foundation.")

    def build_walls(self):
        print("Building wooden walls.")

    def build_roof(self):
        print("Building a wooden roof.")

class BrickHouseBuilder(HouseBuilder):
    """
    Concrete class that builds a brick house.
    """
    def build_foundation(self):
        print("Building a brick foundation.")

    def build_walls(self):
        print("Building brick walls.")

    def build_roof(self):
        print("Building a brick roof.")

# Example usage
wood_house_builder = WoodHouseBuilder()
wood_house_builder.build_house()

print("\\n")

brick_house_builder = BrickHouseBuilder()
brick_house_builder.build_house()
</code></pre>

<p>Dans cet exemple :</p>
<ul>
    <li>La classe abstraite <code class="language-python">HouseBuilder</code> définit la méthode template <code class="language-python">build_house()</code>, qui spécifie l'ordre des étapes à suivre pour construire une maison.</li>
    <li>Les méthodes <code class="language-python">build_foundation()</code>, <code class="language-python">build_walls()</code> et <code class="language-python">build_roof()</code> sont déclarées comme abstraites (<code class="language-python">@abstractmethod</code>). Cela signifie qu'elles doivent obligatoirement être implémentées par les sous-classes concrètes.</li>
    <li>La méthode <code class="language-python">add_finishing()</code> est une méthode concrète qui fournit une implémentation par défaut. Les sous-classes peuvent choisir de la redéfinir (override) si nécessaire.</li>
    <li>Les classes <code class="language-python">WoodHouseBuilder</code> et <code class="language-python">BrickHouseBuilder</code> sont des implémentations concrètes de <code class="language-python">HouseBuilder</code>.  Elles fournissent des implémentations spécifiques pour les méthodes abstraites, permettant de construire respectivement une maison en bois et une maison en brique.</li>
</ul>

<p>En résumé, le Template Method pattern permet de centraliser la logique commune (l'ordre des étapes) dans une classe de base, tout en offrant aux sous-classes la flexibilité de personnaliser certaines étapes spécifiques. Cette approche réduit considérablement la duplication de code et simplifie la maintenance et l'évolution du système.</p>
</p>
  </section>
</div>


<div class="content_box">
  <section>
    <h2 class="heading">5. Design patterns avancés en Python</h2>
    <p><p>Les design patterns avancés en Python permettent de résoudre des problèmes de conception complexes et d'améliorer la modularité, la flexibilité et la maintenabilité du code. Ils s'appuient souvent sur les principes SOLID et les design patterns fondamentaux, mais les combinent et les étendent pour répondre à des besoins plus spécifiques.</p>

<p>L'un de ces patterns est le <strong>pattern Flyweight</strong>, particulièrement utile pour optimiser l'utilisation de la mémoire lorsqu'un grand nombre d'objets partagent des états intrinsèques similaires. L'idée est de séparer l'état intrinsèque (partagé) de l'état extrinsèque (unique à chaque objet) et de partager les objets intrinsèques entre plusieurs objets. Prenons l'exemple de la représentation d'arbres dans une forêt :</p>

<pre><code class="language-python">
class TreeType:
    """
    The Flyweight class. Stores intrinsic state that is shared by all objects.
    """
    def __init__(self, name: str, color: str, texture: str):
        self.name = name
        self.color = color
        self.texture = texture

    def draw(self, x: int, y: int):
        print(f"Drawing {self.name} at ({x}, {y}) with color {self.color} and texture {self.texture}")


class TreeFactory:
    """
    The Flyweight Factory. Creates and manages Flyweight objects.
    Ensures that objects are shared correctly. When the client requests a flyweight,
    the factory either returns an existing instance or creates a new one if it doesn't exist yet.
    """
    _tree_types = {}

    @staticmethod
    def get_tree_type(name: str, color: str, texture: str) -> TreeType:
        key = (name, color, texture)
        if key not in TreeFactory._tree_types:
            TreeFactory._tree_types[key] = TreeType(name, color, texture)
        return TreeFactory._tree_types[key]


# Client code
if __name__ == "__main__":
    forest = []
    for i in range(5):
        tree_type = TreeFactory.get_tree_type("Oak", "Green", "Rough")
        forest.append(tree_type)
        tree_type.draw(i, i*2)

    for i in range(5, 10):
        tree_type = TreeFactory.get_tree_type("Birch", "White", "Smooth")
        forest.append(tree_type)
        tree_type.draw(i, i*2)

    # Only two TreeType objects are created and shared.
    print(f"Number of TreeType objects created: {len(TreeFactory._tree_types)}")
</code></pre>

<p>Dans cet exemple, la classe <code class="language-python">TreeType</code> représente l'état intrinsèque des arbres (nom, couleur, texture). La classe <code class="language-python">TreeFactory</code> crée et gère les instances de <code class="language-python">TreeType</code>, en s'assurant qu'un seul objet <code class="language-python">TreeType</code> est créé pour chaque combinaison unique d'état intrinsèque. Les coordonnées x et y sont l'état extrinsèque, géré par le client. Ainsi, même avec un grand nombre d'arbres dans la forêt, seule une quantité limitée d'objets <code class="language-python">TreeType</code> est réellement créée, optimisant l'utilisation de la mémoire.</p>

<p>Un autre pattern avancé est le <strong>pattern Memento</strong>, qui permet de capturer et de restaurer l'état interne d'un objet sans violer le principe d'encapsulation. Cela est utile pour implémenter des fonctionnalités telles que l'annulation et la restauration (undo/redo). Considérons un éditeur de texte simple :</p>

<pre><code class="language-python">
class TextEditor:
    """
    The Originator class.
    """
    def __init__(self):
        self._text = ""

    def set_text(self, text: str):
        self._text = text

    def get_text(self) -> str:
        return self._text

    def create_memento(self) -> 'TextEditorMemento':
        return TextEditorMemento(self._text)

    def restore_memento(self, memento: 'TextEditorMemento'):
        self._text = memento.get_text()


class TextEditorMemento:
    """
    The Memento class. Stores the internal state of the Originator object.
    """
    def __init__(self, text: str):
        self._text = text

    def get_text(self) -> str:
        return self._text


class Caretaker:
    """
    The Caretaker class. Stores the mementos. Does not operate on the content of the mementos.
    """
    def __init__(self):
        self._mementos = []

    def add_memento(self, memento: 'TextEditorMemento'):
        self._mementos.append(memento)

    def get_memento(self, index: int) -> 'TextEditorMemento':
        return self._mementos[index]


# Client code
if __name__ == "__main__":
    editor = TextEditor()
    caretaker = Caretaker()

    editor.set_text("First version.")
    caretaker.add_memento(editor.create_memento())

    editor.set_text("Second version with some edits.")
    caretaker.add_memento(editor.create_memento())

    editor.set_text("Final version.")
    print(f"Current text: {editor.get_text()}")

    # Undo to the second version
    editor.restore_memento(caretaker.get_memento(1))
    print(f"Text after undo: {editor.get_text()}")

    # Undo to the first version
    editor.restore_memento(caretaker.get_memento(0))
    print(f"Text after another undo: {editor.get_text()}")
</code></pre>

<p>Dans cet exemple, la classe <code class="language-python">TextEditor</code> est l'objet "Originator" dont l'état est sauvegardé. La classe <code class="language-python">TextEditorMemento</code> représente un snapshot de l'état de l'éditeur. La classe <code class="language-python">Caretaker</code> stocke les mementos et permet de restaurer l'éditeur à un état antérieur. Le <code class="language-python">Caretaker</code> n'a pas besoin de connaître le contenu du Memento, il le stocke simplement.</p>

<p>Ces design patterns, combinés à une bonne compréhension des principes SOLID, permettent de construire des applications Python robustes, flexibles et maintenables. Ils offrent des solutions éprouvées à des problèmes de conception récurrents, favorisant ainsi la réutilisation du code et la collaboration entre développeurs.  L'utilisation judicieuse de ces patterns peut significativement améliorer la qualité et l'évolutivité de vos projets Python.</p>
</p>
    <h3>5.1 Flyweight</h3>
    <p><p>Le pattern Flyweight est un patron de conception structurel qui a pour objectif de minimiser l'utilisation de la mémoire ou les coûts de calcul en partageant au maximum l'état intrinsèque (interne) d'un objet entre plusieurs objets similaires. Il est particulièrement avantageux lorsqu'un grand nombre d'objets doivent être instanciés, mais que beaucoup d'entre eux possèdent les mêmes informations.</p>

<p>L'idée centrale est de diviser l'état d'un objet en deux parties distinctes : l'état intrinsèque, qui est partagé et immuable, et l'état extrinsèque, qui est unique à chaque instance de l'objet et est communiqué aux méthodes de l'objet Flyweight lorsque cela s'avère nécessaire.</p>

<p>Prenons l'exemple concret d'un éditeur de texte. Au lieu de conserver les données de formatage (police, taille, couleur) pour chaque caractère individuel, nous pouvons mettre en œuvre le pattern Flyweight pour partager ces données entre plusieurs caractères. L'état intrinsèque correspondrait alors à la police, la taille et la couleur du caractère, tandis que l'état extrinsèque serait la position du caractère dans le document.</p>

<p>Voici une implémentation possible en Python :</p>

<pre><code class="language-python">
class CharacterFlyweight:
    """
    Represents the intrinsic state of a character (font, size, color).
    These properties are shared among multiple character instances.
    """
    def __init__(self, font, size, color):
        self.font = font
        self.size = size
        self.color = color

    def render(self, x, y, character):
        """
        Renders the character at a given position. The x and y coordinates are
        the extrinsic state, which is different for each character instance.
        """
        print(f"Rendering '{character}' at ({x}, {y}) with font {self.font}, size {self.size}, color {self.color}")


class CharacterFlyweightFactory:
    """
    A factory for creating and managing CharacterFlyweight instances. It ensures that
    only one instance of each character type (with a specific font, size, and color) is created.
    """
    _flyweights = {}

    @staticmethod
    def get_flyweight(font, size, color):
        """
        Returns an existing CharacterFlyweight instance if one exists, or creates a new one if it doesn't.
        """
        key = (font, size, color)
        if key not in CharacterFlyweightFactory._flyweights:
            CharacterFlyweightFactory._flyweights[key] = CharacterFlyweight(font, size, color)
        return CharacterFlyweightFactory._flyweights[key]


class TextEditor:
    """
    Represents the text editor, which uses CharacterFlyweight instances to render characters.
    """
    def __init__(self):
        self.characters = []

    def add_character(self, character, x, y, font, size, color):
        """
        Adds a character to the text editor at a given position with specific formatting.
        """
        flyweight = CharacterFlyweightFactory.get_flyweight(font, size, color)
        self.characters.append((character, x, y, flyweight))

    def render_text(self):
        """
        Renders all the characters in the text editor.
        """
        for character, x, y, flyweight in self.characters:
            flyweight.render(x, y, character)


# Example usage:
if __name__ == "__main__":
    editor = TextEditor()
    editor.add_character("H", 10, 20, "Arial", 12, "black")
    editor.add_character("e", 15, 20, "Arial", 12, "black")
    editor.add_character("l", 20, 20, "Arial", 12, "black")
    editor.add_character("l", 25, 20, "Arial", 12, "black")
    editor.add_character("o", 30, 20, "Arial", 12, "black")
    editor.add_character("!", 35, 20, "Arial", 12, "black")

    editor.add_character("W", 10, 30, "Times New Roman", 14, "red")
    editor.add_character("o", 15, 30, "Times New Roman", 14, "red")
    editor.add_character("r", 20, 30, "Times New Roman", 14, "red")
    editor.add_character("l", 25, 30, "Times New Roman", 14, "red")
    editor.add_character("d", 30, 30, "Times New Roman", 14, "red")
    
    editor.render_text()
</code></pre>

<p>Dans cet exemple :</p>
<ul>
    <li><code class="language-python">CharacterFlyweight</code> représente l'état intrinsèque d'un caractère, à savoir sa police, sa taille et sa couleur.</li>
    <li><code class="language-python">CharacterFlyweightFactory</code> est une fabrique qui gère les instances de <code class="language-python">CharacterFlyweight</code>, garantissant qu'une seule instance de chaque type de caractère est créée, optimisant ainsi l'utilisation de la mémoire.</li>
    <li><code class="language-python">TextEditor</code> incarne l'éditeur de texte et exploite les instances de <code class="language-python">CharacterFlyweight</code> pour afficher les caractères à l'écran.</li>
</ul>

<p>Le pattern Flyweight se révèle particulièrement pertinent lors de la manipulation d'un grand nombre d'objets qui partagent des données communes. Il offre la possibilité de réduire considérablement l'empreinte mémoire en évitant de stocker inutilement les mêmes informations à plusieurs reprises. Par conséquent, il contribue à améliorer la performance globale de l'application, en particulier dans les contextes où la mémoire est une ressource limitée ou coûteuse.</p>
</p>
    <h3>5.2 Memento</h3>
    <p><p>Le pattern Memento est un patron de conception comportemental qui permet de sauvegarder et de restaurer l'état interne d'un objet sans exposer sa structure interne. Il est particulièrement utile lorsque vous avez besoin de fournir des fonctionnalités d'annulation/rétablissement (undo/redo) ou d'implémenter des points de contrôle (checkpoints) dans une application.</p>
<p>L'idée centrale du pattern Memento est de séparer les responsabilités en trois parties : l'<code class="language-python">Originator</code>, qui est l'objet dont l'état doit être sauvegardé ; le <code class="language-python">Memento</code>, qui stocke cet état ; et le <code class="language-python">Caretaker</code>, qui gère le stockage et la récupération des <code class="language-python">Memento</code>s. L'<code class="language-python">Originator</code> crée un <code class="language-python">Memento</code> contenant son état actuel et peut utiliser un <code class="language-python">Memento</code> pour revenir à un état antérieur. Le <code class="language-python">Caretaker</code> conserve une collection de <code class="language-python">Memento</code>s, mais n'a pas accès à leur contenu interne, préservant ainsi l'encapsulation de l'<code class="language-python">Originator</code>.</p>
<p>Voici un exemple concret avec un éditeur de texte simplifié :</p>
<pre><code class="language-python">
class TextDocument:
    """
    Originator: The object whose state needs to be saved.
    """
    def __init__(self):
        self._content = ""

    def write(self, text):
        self._content += text

    def get_content(self):
        return self._content

    def create_memento(self):
        """Creates a memento containing the current state of the document."""
        return TextDocumentMemento(self._content)

    def restore_from_memento(self, memento):
        """Restores the document's state from a memento."""
        self._content = memento.get_state()


class TextDocumentMemento:
    """
    Memento: Stores the internal state of the Originator.
    """
    def __init__(self, state):
        self._state = state

    def get_state(self):
        """Returns the saved state."""
        return self._state


class History:
    """
    Caretaker: Manages the sequence of mementos.
    """
    def __init__(self):
        self._mementos = []

    def save(self, memento):
        """Saves a memento to the history."""
        self._mementos.append(memento)

    def get_memento(self, index):
        """Retrieves a memento from the history by its index."""
        if 0 <= index < len(self._mementos):
            return self._mementos[index]
        else:
            return None


# Example Usage
document = TextDocument()
history = History()

# Write some text and save the state
document.write("First sentence. ")
history.save(document.create_memento())

document.write("Second sentence. ")
history.save(document.create_memento())

print(f"Current document: {document.get_content()}")  # Output: First sentence. Second sentence.

# Undo to the previous state
memento = history.get_memento(0)
if memento:
    document.restore_from_memento(memento)

print(f"Document after undo: {document.get_content()}")  # Output: First sentence.
</code></pre>
<p>Dans cet exemple, <code class="language-python">TextDocument</code> est l'<code class="language-python">Originator</code>, <code class="language-python">TextDocumentMemento</code> est le <code class="language-python">Memento</code>, et <code class="language-python">History</code> est le <code class="language-python">Caretaker</code>. L'objet <code class="language-python">TextDocument</code> expose les méthodes <code class="language-python">create_memento</code> et <code class="language-python">restore_from_memento</code> pour la sauvegarde et la restauration de son état. La classe <code class="language-python">History</code> maintient une liste des états passés du document et permet de les récupérer, implémentant ainsi une forme d'opération "undo". Il est important de noter que la classe <code class="language-python">History</code> ne manipule pas directement le contenu du <code class="language-python">Memento</code>, assurant ainsi la préservation de l'encapsulation de l'objet <code class="language-python">TextDocument</code>.</p>
<p>Le pattern Memento offre une manière élégante et structurée de gérer l'historique des états d'un objet, tout en respectant les principes d'encapsulation. Il est particulièrement pertinent dans les applications nécessitant des fonctionnalités d'annulation/rétablissement, de gestion de versions ou de points de contrôle, où la capacité de revenir à un état antérieur de l'objet est cruciale.</p>
</p>
  </section>
</div>


<div class="content_box">
  <section>
    <h2 class="heading">6. Anti-patterns en Python</h2>
    <p><p>Bien que les design patterns offrent des solutions éprouvées, il est tout aussi important d'identifier et d'éviter les <em>anti-patterns</em>, qui sont des pratiques courantes mais inefficaces ou nuisibles. En Python, certains anti-patterns sont particulièrement répandus et peuvent affecter la lisibilité, la maintenabilité et la performance du code.</p>

<p><strong>Shadowing de variables built-in:</strong> Évitez de réutiliser des noms de fonctions ou de classes intégrées de Python comme noms de variables. Cela peut masquer les fonctions d'origine et conduire à des erreurs inattendues.</p>

<pre><code class="language-python">
# Anti-pattern: Shadowing the built-in 'list'
list = [1, 2, 3]
# Now you can't use the list() constructor as expected
# list('abc') # This will raise a TypeError

# Correct approach: Use a more descriptive variable name
my_list = [1, 2, 3]
new_list = list(('a', 'b', 'c')) # Using the built-in list() function
print(new_list)
</code></pre>

<p><strong>Gestion d'exceptions excessivement large:</strong> Attraper toutes les exceptions avec un simple <code class="language-python">except:</code> rend le débogage difficile et peut masquer des erreurs importantes. Il est préférable de cibler les exceptions spécifiques que votre code est susceptible de rencontrer, permettant ainsi une gestion plus précise et informative des erreurs.</p>

<pre><code class="language-python">
# Anti-pattern: Catching all exceptions
try:
    result = 10 / 0
except:
    print("An error occurred") # Very unspecific, hard to debug

# Correct approach: Catch specific exceptions
try:
    result = 10 / 0
except ZeroDivisionError:
    print("Cannot divide by zero")
except TypeError:
    print("Invalid type for division")
</code></pre>

<p><strong>Utilisation excessive de <code class="language-python">global</code>:</strong> L'utilisation excessive de variables globales rend le code difficile à comprendre et à maintenir, car elle introduit des dépendances implicites et rend le flux de données moins clair. Préférez passer des variables explicitement en arguments aux fonctions, favorisant ainsi un code plus modulaire et testable.</p>

<pre><code class="language-python">
# Anti-pattern: Overusing global variables
counter = 0

def increment():
    global counter
    counter += 1

increment()
print(counter)

# Correct approach: Pass variables as arguments
def increment(count):
    return count + 1

counter = 0
counter = increment(counter)
print(counter)
</code></pre>

<p><strong>Mutabilité non intentionnelle des arguments par défaut:</strong> Les arguments par défaut qui sont des objets mutables (listes, dictionnaires) sont créés une seule fois, lors de la définition de la fonction. Si la fonction modifie l'argument par défaut, ces modifications persistent entre les appels, ce qui peut conduire à des comportements inattendus et difficiles à déboguer.  Pour éviter cela, utilisez <code class="language-python">None</code> comme valeur par défaut et créez une nouvelle instance de l'objet mutable à l'intérieur de la fonction si l'argument n'est pas fourni.</p>

<pre><code class="language-python">
# Anti-pattern: Mutable default argument
def append_to_list(value, my_list=[]):
    my_list.append(value)
    return my_list

print(append_to_list(1))   # Output: [1]
print(append_to_list(2))   # Output: [1, 2] - Unexpected!

# Correct approach: Use None as default and create a new list if needed
def append_to_list_correct(value, my_list=None):
    if my_list is None:
        my_list = []
    my_list.append(value)
    return my_list

print(append_to_list_correct(1))  # Output: [1]
print(append_to_list_correct(2))  # Output: [2] - Expected!
</code></pre>

<p><strong>Ignorer le principe DRY (Don't Repeat Yourself):</strong> La duplication de code est un anti-pattern classique. Encapsulez le code réutilisable dans des fonctions ou des classes pour éviter la redondance et faciliter la maintenance. Cela réduit les risques d'erreurs, améliore la lisibilité et simplifie les modifications futures.</p>

<pre><code class="language-python">
# Anti-pattern: Repeated code
def calculate_area_rectangle(length, width):
    area = length * width
    print(f"The area of the rectangle is: {area}")

def calculate_perimeter_rectangle(length, width):
    perimeter = 2 * (length + width)
    print(f"The perimeter of the rectangle is: {perimeter}")

calculate_area_rectangle(5, 10)
calculate_perimeter_rectangle(5, 10)

# Correct approach: Use functions to avoid repetition
def calculate_rectangle_properties(length, width):
    area = length * width
    perimeter = 2 * (length + width)
    return area, perimeter

area, perimeter = calculate_rectangle_properties(5, 10)
print(f"The area of the rectangle is: {area}")
print(f"The perimeter of the rectangle is: {perimeter}")
</code></pre>

<p>En évitant ces anti-patterns courants, vous améliorerez significativement la qualité, la lisibilité et la maintenabilité de votre code Python. Combinez cette vigilance avec l'application judicieuse de design patterns, et vous serez en mesure de construire des applications robustes et élégantes. Adopter une approche proactive pour identifier et corriger ces pièges courants est essentiel pour tout développeur Python soucieux de produire un code de haute qualité.</p>
</p>
    <h3>6.1 God Class</h3>
    <p><p>L'anti-pattern "God Class" (Classe Divine) se manifeste lorsqu'une classe unique au sein d'un système devient excessivement volumineuse et responsable de trop de fonctionnalités. Elle accumule un nombre disproportionné d'attributs et de méthodes, centralisant la logique métier et interagissant avec de nombreuses autres classes. Cette centralisation excessive viole le principe de responsabilité unique (Single Responsibility Principle), rendant le code difficile à comprendre, à tester et à maintenir.</p>

<p>Les problèmes engendrés par une God Class sont multiples :</p>
<ul>
    <li><strong>Manque de modularité :</strong> La concentration de nombreuses responsabilités dans une seule classe rend le code monolithique et difficile à décomposer en unités plus petites et réutilisables.</li>
    <li><strong>Difficulté de maintenance :</strong> Toute modification, même mineure, risque d'affecter de nombreuses parties de la classe, augmentant le risque d'introduction de bugs et rendant la maintenance coûteuse.</li>
    <li><strong>Complexité accrue :</strong> La taille et la complexité de la classe rendent sa compréhension difficile, même pour les développeurs qui l'ont initialement créée. La documentation devient ardue, et la courbe d'apprentissage pour les nouveaux membres de l'équipe s'en trouve abruptement augmentée.</li>
    <li><strong>Couplage fort :</strong> La God Class a tendance à être fortement couplée à de nombreuses autres classes, ce qui rend le système fragile et difficile à faire évoluer. Modifier une God Class peut involontairement affecter d'autres parties du système.</li>
    <li><strong>Difficulté de test :</strong> Tester une God Class nécessite de configurer un grand nombre d'états et de mocks, rendant les tests longs, complexes et peu fiables. Les tests unitaires deviennent un véritable cauchemar.</li>
</ul>

<p>Pour éviter de tomber dans le piège de la God Class en Python, plusieurs stratégies peuvent être mises en œuvre :</p>
<ol>
    <li><strong>Appliquer le principe de responsabilité unique (SRP) :</strong> Chaque classe doit avoir une seule responsabilité et une seule raison de changer. Cela simplifie la conception, la maintenance et les tests.</li>
    <li><strong>Extraire des classes :</strong> Identifier les responsabilités distinctes au sein de la classe et les extraire dans des classes séparées. Par exemple, si une classe gère à la fois la logique métier et la persistance des données, séparez ces responsabilités dans deux classes distinctes.</li>
    <li><strong>Utiliser la composition plutôt que l'héritage :</strong> La composition permet de créer des objets complexes en combinant des objets plus simples, favorisant la réutilisation et la flexibilité.  Privilégiez l'agrégation d'objets au sein d'une classe plutôt que de créer une hiérarchie d'héritage profonde.</li>
    <li><strong>Déléguer des responsabilités :</strong> Confier certaines responsabilités à d'autres classes ou fonctions. L'utilisation de fonctions d'ordre supérieur ou de décorateurs peut aider à déléguer certaines tâches.</li>
    <li><strong>Identifier et extraire les abstractions :</strong> Rechercher les abstractions communes et les encapsuler dans des classes abstraites ou des interfaces (en utilisant <code class="language-python">abc</code> module en Python).  Cela permet de définir des contrats clairs et de faciliter la réutilisation du code.</li>
    <li><strong>Refactoriser régulièrement :</strong> Effectuer des refactorings réguliers pour identifier et corriger les problèmes de conception avant qu'ils ne deviennent trop importants.  Utilisez des outils d'analyse statique comme <code class="language-python">pylint</code> ou <code class="language-python">flake8</code> pour identifier les violations des principes de conception.</li>
</ol>

<p>Voici un exemple illustrant comment décomposer une God Class :</p>
<pre><code class="language-python">
class OrderProcessor:
    """
    A God Class that handles order processing, validation, payment, and notification.
    """
    def __init__(self, order_data):
        self.order_data = order_data

    def validate_order(self):
        # Complex validation logic
        print("Validating order details...")
        return True

    def process_payment(self):
        # Payment processing logic
        print("Processing payment...")
        return True

    def send_notification(self):
        # Notification sending logic
        print("Sending notification...")
        return True

    def process_order(self):
        if self.validate_order() and self.process_payment():
            self.send_notification()
            print("Order processed successfully.")
        else:
            print("Order processing failed.")
</code></pre>

<p>Refactorisons cette God Class en classes plus petites et spécialisées :</p>

<pre><code class="language-python">
class OrderValidator:
    """Validates order details."""
    def validate(self, order_data):
        # Validation logic here
        print("Validating order...")
        return True

class PaymentService:
    """Processes payments."""
    def process_payment(self, order_data):
        # Payment processing logic
        print("Processing payment...")
        return True

class NotificationService:
    """Sends notifications."""
    def send_notification(self, order_data):
        # Notification sending logic
        print("Sending notification...")

class OrderProcessor:
    """Orchestrates order processing."""
    def __init__(self, validator, payment_service, notification_service):
        self.validator = validator
        self.payment_service = payment_service
        self.notification_service = notification_service

    def process_order(self, order_data):
        if self.validator.validate(order_data) and self.payment_service.process_payment(order_data):
            self.notification_service.send_notification(order_data)
            print("Order processed successfully.")
        else:
            print("Order processing failed.")

# Usage example:
order_data = {"item": "example", "quantity": 1}
validator = OrderValidator()
payment_service = PaymentService()
notification_service = NotificationService()
processor = OrderProcessor(validator, payment_service, notification_service)
processor.process_order(order_data)
</code></pre>

<p>En décomposant la God Class en classes plus petites et plus spécialisées, nous avons créé un système plus modulaire, plus facile à maintenir et à tester. Chaque classe a une seule responsabilité, ce qui facilite sa compréhension et sa modification. Le code est plus lisible et la réutilisation est facilitée grâce à la séparation des préoccupations (separation of concerns).</p>

<p>En conclusion, l'anti-pattern "God Class" est un écueil courant dans le développement logiciel. En appliquant les principes de conception SOLID, en particulier le principe de responsabilité unique, et en utilisant des techniques telles que l'extraction de classes, la composition et la délégation, il est possible d'éviter cet anti-pattern et de créer un code plus propre, plus maintenable et plus évolutif. Une architecture logicielle bien conçue favorise l'agilité et réduit les coûts de maintenance à long terme.</p>
</p>
    <h3>6.2 Spaghetti Code</h3>
    <p><p><strong>Comment identifier le Spaghetti Code :</strong></p>
<ul>
    <li><strong>Complexité cyclomatique élevée :</strong> Un nombre élevé de chemins d'exécution différents dans une fonction ou un module indique une complexité excessive. Des outils comme <code class="language-python">radon</code> peuvent aider à mesurer cette complexité.</li>
    <li><strong>Nombre important de variables globales :</strong> Une utilisation excessive de variables globales rend le code difficile à comprendre car l'état du programme devient imprévisible. Préférez les variables locales ou les attributs de classe.</li>
    <li><strong>Duplication de code :</strong> La présence de blocs de code similaires à plusieurs endroits indique un manque d'abstraction. Le principe DRY (Don't Repeat Yourself) doit être appliqué.</li>
    <li><strong>Longues fonctions ou classes :</strong> Les fonctions ou classes qui dépassent une certaine longueur (par exemple, plusieurs centaines de lignes) sont généralement difficiles à appréhender et à maintenir. Divisez-les en unités plus petites et plus cohérentes.</li>
    <li><strong>Fort couplage :</strong> Les composants du code sont fortement interdépendants, ce qui rend difficile la modification ou le remplacement d'un composant sans affecter les autres. Visez un faible couplage et une forte cohésion.</li>
    <li><strong>Manque de tests unitaires :</strong> L'absence de tests unitaires indique souvent une mauvaise conception et une difficulté à tester le code de manière isolée. Des tests unitaires robustes facilitent la refactorisation et la maintenance.</li>
</ul>

<p><strong>Exemple de Spaghetti Code en Python :</strong></p>
<pre><code class="language-python">
def process_data(data, option):
    """
    This function processes data based on a given option.
    It's long, complex, and hard to understand.
    """
    result = []
    if option == 1:
        for item in data:
            if item > 0:
                result.append(item * 2)
            else:
                result.append(0)
    elif option == 2:
        for item in data:
            if item < 0:
                result.append(abs(item))
            else:
                result.append(item)
    else:
        for item in data:
            result.append(item + 1)

    # Further complex calculations
    final_result = []
    for item in result:
        if item % 2 == 0:
            final_result.append(item / 2)
        else:
            final_result.append(item * 3)

    return final_result

# Example usage
data = [1, -2, 3, -4, 5]
option = 1
processed_data = process_data(data, option)
print(processed_data)
</code></pre>

<p><strong>Refactorisation du Spaghetti Code :</strong></p>
<ol>
    <li><strong>Extraire des fonctions :</strong> Découpez les longues fonctions en unités plus petites et plus spécifiques. Chaque fonction doit avoir une responsabilité unique.</li>
    <li><strong>Créer des classes :</strong> Regroupez les données et les fonctions associées en classes pour améliorer l'organisation et l'encapsulation. Utilisez les principes de la programmation orientée objet.</li>
    <li><strong>Réduire les variables globales :</strong> Remplacez les variables globales par des variables locales ou des attributs de classe. Utilisez le passage d'arguments pour la communication entre fonctions.</li>
    <li><strong>Éliminer la duplication de code :</strong> Identifiez et factorisez les blocs de code dupliqués en fonctions ou classes réutilisables. Créez des abstractions pour gérer les variations.</li>
    <li><strong>Ajouter des tests unitaires :</strong> Écrivez des tests unitaires pour chaque fonction et classe afin de garantir la fonctionnalité et de faciliter la refactorisation. Utilisez un framework de test comme <code class="language-python">pytest</code> ou <code class="language-python">unittest</code>.</li>
</ol>

<pre><code class="language-python">
def process_positive_numbers(data):
    """
    Processes positive numbers by doubling them.
    """
    return [item * 2 if item > 0 else 0 for item in data]

def process_negative_numbers(data):
    """
    Processes negative numbers by taking their absolute value.
    """
    return [abs(item) if item < 0 else item for item in data]

def process_all_numbers(data):
    """
    Processes all numbers by adding 1 to them.
    """
    return [item + 1 for item in data]

def finalize_results(data):
    """
    Finalizes the results by dividing even numbers by 2 and multiplying odd numbers by 3.
    """
    return [item / 2 if item % 2 == 0 else item * 3 for item in data]

def process_data_refactored(data, option):
    """
    Refactored function to process data based on a given option.
    """
    if option == 1:
        result = process_positive_numbers(data)
    elif option == 2:
        result = process_negative_numbers(data)
    else:
        result = process_all_numbers(data)

    final_result = finalize_results(result)
    return final_result

# Example usage
data = [1, -2, 3, -4, 5]
option = 1
processed_data = process_data_refactored(data, option)
print(processed_data)
</code></pre>

<p>En appliquant ces techniques de refactorisation, il est possible de transformer le "Spaghetti Code" en un code plus propre, plus lisible et plus maintenable, améliorant ainsi la qualité globale du projet Python. Une bonne architecture logicielle est essentielle pour la réussite à long terme d'un projet.</p>
</p>
  </section>
</div>


<div class="content_box">
  <section>
    <h2 class="heading">Conclusion</h2>
    <p><p>En conclusion, les design patterns constituent un atout majeur pour tout développeur Python. L'investissement initial dans l'apprentissage et la maîtrise de ces patrons se traduit par une amélioration notable de la qualité du code, tant en termes de maintenabilité que de réutilisabilité, permettant ainsi de construire des applications plus robustes et évolutives.</p>

<p>L'adoption des design patterns permet de résoudre des problèmes de conception récurrents de manière élégante et éprouvée. Prenons l'exemple du pattern <b>Singleton</b>. Ce pattern garantit qu'une classe n'ait qu'une seule instance et fournit un point d'accès global à cette instance. Cette approche est particulièrement pertinente pour gérer des ressources partagées, des configurations globales ou des connexions à une base de données.</p>

<pre><code class="language-python">
class Configuration:
    """
    A class that implements the Singleton pattern to manage application configuration.
    It ensures that only one instance of the Configuration class exists.
    """
    _instance = None  # Private class variable to hold the single instance

    def __new__(cls, *args, **kwargs):
        """
        Overrides the __new__ method to control the instance creation.
        If an instance already exists, it returns the existing instance; otherwise, it creates a new one.
        """
        if not cls._instance:
            cls._instance = super(Configuration, cls).__new__(cls, *args, **kwargs)
        return cls._instance

    def __init__(self, setting1=None, setting2=None):
        """
        Initializes the Configuration instance with default or provided settings.
        The 'initialized' attribute ensures that this method runs only once.
        """
        if not hasattr(self, 'initialized'):  # Ensure initialization only happens once
            self.setting1 = setting1 or "default_value_1"
            self.setting2 = setting2 or "default_value_2"
            self.initialized = True

    def display_settings(self):
        """
        Prints the current settings of the Configuration instance.
        """
        print(f"Setting 1: {self.setting1}")
        print(f"Setting 2: {self.setting2}")


# Usage example:
config1 = Configuration("custom_value_1")  # Create the first configuration instance with a custom setting
config2 = Configuration()  # Attempt to create another instance

config1.display_settings()  # Output: Setting 1: custom_value_1, Setting 2: default_value_2
config2.display_settings()  # Output: Setting 1: custom_value_1, Setting 2: default_value_2 (same values as config1)

print(config1 is config2)  # Output: True (config1 and config2 are the same instance)
</code></pre>

<p>Cet exemple illustre la simplicité et l'efficacité du pattern Singleton. En l'utilisant judicieusement, vous évitez les conflits potentiels liés à la gestion de multiples instances d'une classe critique, tout en assurant un accès centralisé et cohérent aux données qu'elle contient.</p>

<p>L'étude des design patterns ne se limite pas à l'acquisition de connaissances théoriques. Elle encourage une approche plus réfléchie et structurée de la résolution de problèmes, favorisant ainsi la production d'un code plus propre, plus lisible et plus conforme aux standards de l'industrie. C'est un investissement durable dans votre progression en tant que développeur Python.</p>
</p>
  </section>
</div>


<!-- End of Course Marker -->
<div class="course-end-marker" style="margin: 4rem auto; text-align: center; max-width: 600px">
  <div style="height: 2px; background: linear-gradient(90deg, transparent, #fb5168 50%, transparent); margin: 2rem auto;"></div>
  <p style="color: #fb5168; font-size: 1.2rem; font-weight: 500; letter-spacing: 1px; opacity: 0.9;">
    That's all folks
  </p>
</div></div>
    </main>

    <!-- (Non-critical JS after DOM parsing) -->
    <script src="/src/js/back-to-top.js" type="module" defer></script>
    <script src="/src/js/include-footer.js" type="module" defer></script>
    <script src="/src/js/include-navbar.js" type="module" defer></script>
    <script src="/src/js/include-course-navbar.js" type="module" defer></script>
    <script src="/src/js/include-mobile-course-navbar.js" type="module" defer></script>
    <script src="/src/js/slider.js" type="module" defer></script>
    <script src="/src/js/copy-code-button.js" type="module" defer></script>
    <!-- (Non-critical JS after DOM parsing) -->

 </body>
</html>