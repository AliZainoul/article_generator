#!/usr/bin/env python3
# -*- coding: utf-8 -*-

"""
HTML Generator Module

This module takes the article content generated by the AI models and
creates an HTML file based on the template.
"""

import os
import re
import logging

from typing import Dict, Any, Optional
from datetime import datetime

from article_generator.colored_logging import setup_colored_logging


# Configure colored logging
setup_colored_logging(
    level=logging.INFO,
    format_str='%(asctime)s - %(name)s - %(levelname)s - %(message)s'
)
logger = logging.getLogger(__name__)

class HTMLGenerator:
    """Class for generating HTML articles from AI-generated content."""

    def __init__(
            self,
            template_path: Optional[str] = None,
            output_dir: Optional[str] = None
        ) -> None:
        """Initialize the HTMLGenerator with template path and output directory.
        
        Args:
            template_path: Path to the HTML template file (optional)
            output_dir: Directory where generated HTML files will be saved (optional)
        """
        # Get the project root directory (two levels up from the module)
        base_dir = os.path.dirname(os.path.dirname(os.path.abspath(__file__)))
        self.template_path = template_path or os.path.join(base_dir, "_template_article.html")
        self.output_dir = output_dir or os.path.join(base_dir, "articles")

        # Ensure output directory exists
        os.makedirs(self.output_dir, exist_ok=True)

    def create_html_article(
            self,
            title: str,
            article_content: Dict[str, Any]
        ) -> str:
        """Create an HTML article from the generated content using the template.
        
        Args:
            title: The title of the article
            article_content: The generated article content
            
        Returns:
            The filename of the created HTML file
            
        Raises:
            FileNotFoundError: If the template file cannot be found
            IOError: If there's an error reading or writing files
        """
        try:
            # Load the template
            logger.info("Loading template from %s", self.template_path)
            with open(self.template_path, "r", encoding="utf-8") as f:
                template = f.read()

            # Create a sanitized filename from the title
            sanitized_title = self.sanitize_filename(title)
            current_date = datetime.now().strftime("%Y-%m-%d")
            _filename = f"{current_date}-{sanitized_title}.html"

            # Replace title in the template
            template = template.replace("Les Listes en Python", title)
            template = template.replace("Les Listes en Python | Formateur", f"{title} | Formateur")

            # Replace meta description
            meta_description = f"Découvrez tout sur {title} dans cet article détaillé."
            template = re.sub(
                r'<meta\s+name="description"\s+content="[^"]*"\s*/>', 
                f'<meta name="description" content="{meta_description}" />',
                template
            )
            template = re.sub(
                r'<meta\s+property="og:description"\s+content="[^"]*"\s*/>', 
                f'<meta property="og:description" content="{meta_description}" />',
                template
            )
            template = re.sub(
                r'<meta\s+name="twitter:description"\s+content="[^"]*"\s*/>', 
                f'<meta name="twitter:description" content="{meta_description}" />',
                template
            )

            # Generate the article HTML content
            article_html = self.generate_article_html(article_content)

            # Find the main content area in the template and replace it
            content_start = template.find('<div class="content_box">')
            content_end = template.rfind('</div>', 0, template.rfind('</main>'))

            if content_start != -1 and content_end != -1:
                # Keep the title section
                title_section_end = template.find('</div>', content_start) + 6
                header_part = template[:title_section_end]
                footer_part = template[content_end:]

                # Combine the parts
                template = header_part + article_html + footer_part
            else:
                logger.warning(
                    "Could not find content markers in template, appending content at the end")

            # Write the HTML file
            output_path = os.path.join(self.output_dir, _filename)
            logger.info("Writing HTML article to %s", {output_path})
            with open(output_path, "w", encoding="utf-8") as f:
                f.write(template)

            return _filename

        except FileNotFoundError as e:
            logger.error("Template file not found: %s" ,{str(e)})
            raise
        except IOError as e:
            logger.error("IO error when creating HTML article: %s",{str(e)})
            raise
        except Exception as e:
            logger.error("Unexpected error when creating HTML article: %s",{str(e)})
            raise

    def generate_article_html(self, article_content: Dict[str, Any]) -> str:
        """Generate the HTML content for the article.
        
        Args:
            article_content: The generated article content
            
        Returns:
            The HTML content for the article
        """
        html = []

        # Introduction
        html.append('\n')
        html.append('<div class="content_box">')
        html.append('  <section>')
        html.append('    <h2 class="heading">Introduction</h2>')
        html.append(f'    <p>{article_content["introduction"]}</p>')
        html.append('  </section>')
        html.append('</div>')

        # Sections
        for i, section in enumerate(article_content["sections"]):
            html.append('\n')
            html.append('<div class="content_box">')
            html.append('  <section>')
            html.append(f'    <h2 class="heading">{i+1}. {section["title"]}</h2>')
            html.append(f'    <p>{section["content"]}</p>')

            # Subsections
            for j, subsection in enumerate(section["subsections"]):
                html.append(f'    <h3>{i+1}.{j+1} {subsection["title"]}</h3>')
                html.append(f'    <p>{subsection["content"]}</p>')

            html.append('  </section>')
            html.append('</div>')

        # Conclusion
        html.append('\n')
        html.append('<div class="content_box">')
        html.append('  <section>')
        html.append('    <h2 class="heading">Conclusion</h2>')
        html.append(f'    <p>{article_content["conclusion"]}</p>')
        html.append('  </section>')
        html.append('</div>')

        # End of Course Marker
        html.append('\n')
        html.append('<!-- End of Course Marker -->')
        html.append('<div class="course-end-marker" style="'
                   'margin: 4rem auto; '
                   'text-align: center; '
                   'max-width: 600px">')
        html.append('  <div style="'
                   'height: 2px; '
                   'background: linear-gradient(90deg, transparent, #fb5168 50%, transparent); '
                   'margin: 2rem auto;"></div>')
        html.append('  <p style="'
                   'color: #fb5168; '
                   'font-size: 1.2rem; '
                   'font-weight: 500; '
                   'letter-spacing: 1px; '
                   'opacity: 0.9;">')
        html.append('    That\'s all folks')
        html.append('  </p>')
        html.append('</div>')

        return '\n'.join(html)

    def sanitize_filename(self, title: str) -> str:
        """Sanitize the title to create a valid filename.
        
        Args:
            title: The title of the article
            
        Returns:
            A sanitized filename
        """
        # Replace special characters and spaces
        _filename = title.lower()
        _filename = re.sub(r'[^\w\s-]', '', _filename)
        _filename = re.sub(r'[\s]+', '-', _filename)
        return _filename


# For backwards compatibility
def create_html_article(title: str, article_content: Dict[str, Any]) -> str:
    """Legacy function for creating an HTML article from the generated content.
    
    Args:
        title: The title of the article
        article_content: The generated article content
        
    Returns:
        The filename of the created HTML file
    """
    _generator = HTMLGenerator()
    return _generator.create_html_article(title, article_content)


def generate_article_html(article_content: Dict[str, Any]) -> str:
    """Legacy function for generating the HTML content for the article.
    
    Args:
        article_content: The generated article content
        
    Returns:
        The HTML content for the article
    """
    _generator = HTMLGenerator()
    return _generator.generate_article_html(article_content)


def sanitize_filename(title: str) -> str:
    """Legacy function for sanitizing the title to create a valid filename.
    
    Args:
        title: The title of the article
        
    Returns:
        A sanitized filename
    """
    _generator = HTMLGenerator()
    return _generator.sanitize_filename(title)


# For testing purposes
if __name__ == "__main__":
    try:
        # Create a simple test content
        test_content = {
            "title": "Test Article",
            "introduction": "This is the introduction to the test article.",
            "sections": [
                {
                    "title": "First Section",
                    "content": "This is the content of the first section.",
                    "subsections": [
                        {
                            "title": "First Subsection",
                            "content": "This is the content of the first subsection."
                        }
                    ]
                }
            ],
            "conclusion": "This is the conclusion of the test article."
        }

        # Create a test HTML article
        generator = HTMLGenerator()
        filename = generator.create_html_article("Test Article", test_content)
        logger.info("Test article created: %s" ,{filename})
    except Exception as e:
        logger.error("Test failed: %s" ,{str(e)})
